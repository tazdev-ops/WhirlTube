diff --git a/src/whirltube/dialogs.py b/src/whirltube/dialogs.py
index 3bcab4b..b4ed200 100644
--- a/src/whirltube/dialogs.py
+++ b/src/whirltube/dialogs.py
@@ -15,6 +15,7 @@ from gi.repository import Adw, Gio, Gtk
 class PreferencesWindow(Adw.PreferencesWindow):
     def __init__(self, parent: Gtk.Window, settings: dict) -> None:
         super().__init__(transient_for=parent, modal=True, title="Preferences")
         self.settings = settings
         self.set_search_enabled(False)
@@ -21,6 +22,9 @@ class PreferencesWindow(Adw.PreferencesWindow):
         # Playback page
         page_play = Adw.PreferencesPage(title="Playback")
         group_play = Adw.PreferencesGroup(title="Player")
         page_play.add(group_play)

+        # Provider page
+        page_provider = Adw.PreferencesPage(title="Provider")

         # Playback mode
         self.playback_mode = Adw.ComboRow(
             title="Default playback mode",
             model=Gtk.StringList.new(["External MPV", "In-window (X11 only)"]),
         )
@@ -65,6 +69,23 @@ class PreferencesWindow(Adw.PreferencesWindow):
         cookies_group.add(self.entry_container)

+        # Provider group (Invidious)
+        group_provider = Adw.PreferencesGroup(title="Invidious")
+        page_provider.add(group_provider)
+        self.use_invidious = Adw.SwitchRow(title="Use Invidious backend for search/channel")
+        self.use_invidious.set_active(bool(settings.get("use_invidious", False)))
+        group_provider.add(self.use_invidious)

+        self.entry_invidious = Adw.EntryRow(title="Invidious instance")
+        self.entry_invidious.set_text(settings.get("invidious_instance", "https://yewtu.be"))
+        group_provider.add(self.entry_invidious)

         # Downloads page
         page_dl = Adw.PreferencesPage(title="Downloads")
         group_dl = Adw.PreferencesGroup(title="Location")
         page_dl.add(group_dl)
@@ -108,6 +129,7 @@ class PreferencesWindow(Adw.PreferencesWindow):
         group_net.add(self.entry_proxy)

         # Queue / concurrency
         group_queue = Adw.PreferencesGroup(title="Queue")
         page_dl.add(group_queue)
@@ -120,6 +142,7 @@ class PreferencesWindow(Adw.PreferencesWindow):
         group_queue.add(self.spin_concurrent)

         self.add(page_play)
+        self.add(page_provider)
         self.add(page_dl)

         self.connect("close-request", self._on_close)
@@ -151,6 +174,10 @@ class PreferencesWindow(Adw.PreferencesWindow):
         self.settings["mpv_cookies_profile"] = self.entry_profile.get_text()
         self.settings["mpv_cookies_container"] = self.entry_container.get_text()
         # Global proxy
         self.settings["http_proxy"] = self.entry_proxy.get_text()
         # Concurrency
         self.settings["max_concurrent_downloads"] = int(self.spin_concurrent.get_value())
+        # Provider settings
+        self.settings["use_invidious"] = bool(self.use_invidious.get_active())
+        self.settings["invidious_instance"] = self.entry_invidious.get_text().strip() or "https://yewtu.be"
         return False
diff --git a/src/whirltube/window.py b/src/whirltube/window.py
index d674648..706a8bb 100644
--- a/src/whirltube/window.py
+++ b/src/whirltube/window.py
@@ -116,6 +116,8 @@ class MainWindow(Adw.ApplicationWindow):
         menu.append("Import Subscriptions…", "win.subs_import")
         menu.append("Export Subscriptions…", "win.subs_export")
         menu.append("Keyboard Shortcuts", "win.shortcuts")
         menu.append("Download History", "win.download_history")
+        menu.append("Cancel All Downloads", "win.cancel_all_downloads")
+        menu.append("Clear Finished Downloads", "win.clear_finished_downloads")
         menu.append("Quit", "app.quit")
         menu_btn = Gtk.MenuButton(icon_name="open-menu-symbolic")
         menu_btn.set_menu_model(menu)
         header.pack_start(menu_btn)
@@ -309,6 +311,16 @@ class MainWindow(Adw.ApplicationWindow):
         dlh.connect("activate", self._on_download_history)
         self.add_action(dlh)

+        cancel_all = Gio.SimpleAction.new("cancel_all_downloads", None)
+        cancel_all.connect("activate", lambda *_: self.download_manager.cancel_all())
+        self.add_action(cancel_all)

+        clear_fin = Gio.SimpleAction.new("clear_finished_downloads", None)
+        clear_fin.connect("activate", lambda *_: self.download_manager.clear_finished())
+        self.add_action(clear_fin)

         # Subscriptions actions (menu entries exist, actions were missing)
         subs = Gio.SimpleAction.new("subscriptions", None)
         subs.connect("activate", self._on_subscriptions)
         self.add_action(subs)
@@ -462,6 +474,7 @@ class ResultRow(Gtk.Box):
         on_related: Callable[[Video], None],
         on_comments: Callable[[Video], None],
         thumb_loader_pool: ThreadPoolExecutor,
         http_proxy: str | None = None,
         on_follow: Callable[[Video], None] | None = None,
         on_unfollow: Callable[[Video], None] | None = None,
         followed: bool = False,
     ) -> None:
@@ -520,7 +533,11 @@ class ResultRow(Gtk.Box):
         open_web = Gtk.Button(label="Open in Browser")
         open_web.connect("clicked", lambda *_: self._open_in_browser())
         copy_url = Gtk.Button(label="Copy URL")
         copy_url.connect("clicked", lambda *_: self._copy_url())
         copy_title = Gtk.Button(label="Copy Title")
         copy_title.connect("clicked", lambda *_: self._copy_title())
+        # Add spacing between common actions group and primary actions
+        sep = Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL)
+        btn_box.append(sep)
         btn_box.append(open_web)
         btn_box.append(copy_url)
         btn_box.append(copy_title)
         self.append(btn_box)
diff --git a/src/whirltube/download_manager.py b/src/whirltube/download_manager.py
index f1e1f0a..a946b36 100644
--- a/src/whirltube/download_manager.py
+++ b/src/whirltube/download_manager.py
@@ -1,9 +1,10 @@
 from __future__ import annotations

 import logging
 from pathlib import Path
 from collections.abc import Callable
 from typing import Any
 from functools import partial
+from copy import deepcopy

 import gi

@@ -22,14 +23,18 @@ from .download_history import add_download

 log = logging.getLogger(__name__)

 class DownloadRow(Gtk.Box):
-    def __init__(self, task: Any | None = None, title: str | None = None, on_cancel: Callable[[], None] | None = None) -> None:
+    def __init__(self, task: Any | None = None, title: str | None = None, on_cancel: Callable[[], None] | None = None, on_retry: Callable[[], None] | None = None, on_remove: Callable[[], None] | None = None) -> None:
         super().__init__(orientation=Gtk.Orientation.VERTICAL, spacing=6)
         self.task = task
         self._base_title = title or getattr(getattr(task, "video", None), "title", "Download")
         self._on_cancel = on_cancel
+        self._on_retry = on_retry
+        self._on_remove = on_remove
+        # Metadata for retry
+        self._video: Video | None = None
+        self._opts: DownloadOptions | None = None
+        self._dest_dir: Path | None = None
+        self._state: str = "queued" if task is None else "downloading"

         self.set_margin_top(6)
         self.set_margin_bottom(6)
@@ -45,12 +50,20 @@ class DownloadRow(Gtk.Box):
         self.status = Gtk.Label(label="", xalign=0.0)

         # Actions row (open folder/file)
         self.actions = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
         self.btn_cancel = Gtk.Button(label="Cancel")
         self.btn_cancel.connect("clicked", lambda *_: self._on_cancel_clicked())
+        self.btn_retry = Gtk.Button(label="Retry")
+        self.btn_retry.set_sensitive(False)
+        self.btn_retry.connect("clicked", lambda *_: self._on_retry_clicked())
+        self.btn_remove = Gtk.Button(label="Remove")
+        self.btn_remove.set_sensitive(False)
+        self.btn_remove.connect("clicked", lambda *_: self._on_remove_clicked())
         self.btn_open_folder = Gtk.Button(label="Open folder")
         self.btn_open_folder.set_sensitive(False)
         self.btn_open_folder.connect("clicked", self._open_folder)
         self.btn_open_file = Gtk.Button(label="Open file")
         self.btn_open_file.set_sensitive(False)
         self.btn_open_file.connect("clicked", self._open_file)

         self.actions.append(self.btn_cancel)
+        self.actions.append(self.btn_retry)
+        self.actions.append(self.btn_remove)
         self.actions.append(self.btn_open_folder)
         self.actions.append(self.btn_open_file)

         self.append(self.label)
@@ -62,6 +75,20 @@ class DownloadRow(Gtk.Box):
     def _on_cancel_clicked(self) -> None:
         try:
             if self._on_cancel:
                 self._on_cancel()
         finally:
             # Disable cancel to avoid repeated presses
             self.btn_cancel.set_sensitive(False)

+    def _on_retry_clicked(self) -> None:
+        try:
+            if self._on_retry:
+                self._on_retry()
+        except Exception:
+            pass

+    def _on_remove_clicked(self) -> None:
+        try:
+            if self._on_remove:
+                self._on_remove()
+        except Exception:
+            pass

     def set_queued(self) -> None:
         try:
             self.label.set_text(f"Queued: {self._base_title}")
             self.progress.set_fraction(0.0)
             self.progress.set_text("")
             self.status.set_text("")
+            self._state = "queued"
         except Exception:
             pass

+    def set_metadata(self, video: Video, opts: DownloadOptions, dest_dir: Path) -> None:
+        # Deepcopy opts to decouple from future UI edits
+        try:
+            self._video = video
+            self._opts = deepcopy(opts)
+            self._dest_dir = dest_dir
+        except Exception:
+            self._video, self._opts, self._dest_dir = video, opts, dest_dir

     def attach_task(self, task: Any) -> None:
         self.task = task
         try:
             self.label.set_text(f"Downloading: {self._base_title}")
+            self._state = "downloading"
+            # While running, ensure retry/remove disabled
+            self.btn_retry.set_sensitive(False)
+            self.btn_remove.set_sensitive(False)
         except Exception:
             pass

@@ -85,6 +125,7 @@ class DownloadRow(Gtk.Box):
             try:
                 self.label.set_text(f"Downloading: {self._base_title}")
             except Exception:
                 pass
+            self._state = "downloading"
         frac = 0.0
         if p.bytes_total and p.bytes_total > 0:
             frac = min(1.0, max(0.0, p.bytes_downloaded / p.bytes_total))
         self.progress.set_fraction(frac)
@@ -94,14 +135,22 @@ class DownloadRow(Gtk.Box):
         if p.status == "finished":
             # Enable actions
             self.btn_open_folder.set_sensitive(True)
             if p.filename:
                 self.btn_open_file.set_sensitive(True)
             # Disable cancel when done
             self.btn_cancel.set_sensitive(False)
+            self.btn_retry.set_sensitive(False)
+            self.btn_remove.set_sensitive(True)
+            self._state = "finished"
         elif p.status == "error":
             # Disable cancel after error
             self.btn_cancel.set_sensitive(False)
+            self.btn_retry.set_sensitive(True)
+            self.btn_remove.set_sensitive(True)
+            self._state = "error"

     def _open_folder(self, *_a) -> None:
         try:
             dest = getattr(self.task, "dest_dir", None)
             if isinstance(dest, Path) and dest.exists():
                 Gio.AppInfo.launch_default_for_uri(f"file://{dest}", None)
@@ -127,13 +176,21 @@ class DownloadRow(Gtk.Box):
             self.progress.set_fraction(0.0)
             self.progress.set_text("")
             self.btn_cancel.set_sensitive(False)
             # Keep folder/file buttons disabled
+            self.btn_retry.set_sensitive(True)
+            self.btn_remove.set_sensitive(True)
+            self._state = "cancelled"
         except Exception:
             pass

+    def state(self) -> str:
+        return self._state

 def _fmt_dl_text(p: DownloadProgress) -> str:
     if p.status == "finished":
         return "100% (done)"
     if p.bytes_total:
         pct = int((p.bytes_downloaded / p.bytes_total) * 100)
         return f"{pct}%"
@@ -150,12 +207,18 @@ class DownloadManager:
         self._max_concurrent: int = 3
         self._active: int = 0
         # queue of (video, opts, dest_dir, row)
         self._queue: list[tuple[Video, DownloadOptions, Path, DownloadRow]] = []
+        self._rows: list[DownloadRow] = []

     def set_download_dir(self, path: Path) -> None:
         self.download_dir = path

     def set_max_concurrent(self, n: int) -> None:
         try:
             self._max_concurrent = max(1, int(n))
         except Exception:
             self._max_concurrent = 1
         self._maybe_start_next()
@@ -170,10 +233,14 @@ class DownloadManager:
         dest_dir = opts.target_dir or Path(self.get_setting("download_dir") or str(self.download_dir))
         if not self._ensure_download_dir(dest_dir):
             return
         # Create a queued row immediately
-        row = DownloadRow(None, title=video.title, on_cancel=partial(self._cancel_row, None))
+        row = DownloadRow(None, title=video.title, on_cancel=partial(self._cancel_row, None), on_retry=partial(self._retry_row, None), on_remove=partial(self._remove_row, None))
         # Store a weak binding to this specific row into the callback
+        row._on_cancel = partial(self._cancel_row, row)  # type: ignore[attr-defined]
+        row._on_retry = partial(self._retry_row, row)  # type: ignore[attr-defined]
+        row._on_remove = partial(self._remove_row, row)  # type: ignore[attr-defined]
         row.set_queued()
+        row.set_metadata(video, opts, dest_dir)
         self.downloads_box.append(row)
+        self._rows.append(row)
         self.show_downloads_view()
         # Enqueue and attempt to start
         self._queue.append((video, opts, dest_dir, row))
@@ -190,6 +257,64 @@ class DownloadManager:
             video, opts, dest_dir, row = self._queue.pop(0)
             self._start_task(video, opts, dest_dir, row)

+    def _retry_row(self, row: DownloadRow | None) -> None:
+        if row is None:
+            return
+        # If running or queued, ignore
+        if row.state() in ("downloading", "queued"):
+            return
+        v, o, d = row._video, row._opts, row._dest_dir  # type: ignore[attr-defined]
+        if not v or not o or not d:
+            return
+        # Re-enqueue fresh
+        row.set_queued()
+        self._queue.append((v, o, d, row))
+        self._maybe_start_next()

+    def _remove_row(self, row: DownloadRow | None) -> None:
+        if row is None:
+            return
+        # If queued, remove from queue first
+        for i, (_v, _o, _d, r) in enumerate(list(self._queue)):
+            if r is row:
+                try:
+                    self._queue.pop(i)
+                except Exception:
+                    pass
+                break
+        # If running, attempt cancel
+        if row.state() == "downloading":
+            self._cancel_row(row)
+        # Remove from UI and internal list
+        try:
+            self.downloads_box.remove(row)
+        except Exception:
+            pass
+        try:
+            self._rows.remove(row)
+        except Exception:
+            pass

+    def cancel_all(self) -> None:
+        # Cancel running and drop queued
+        for video, opts, dest_dir, row in list(self._queue):
+            try:
+                row.mark_cancelled()
+            except Exception:
+                pass
+        self._queue.clear()
+        # Running: cancel
+        for row in list(self._rows):
+            if row.state() == "downloading":
+                self._cancel_row(row)

+    def clear_finished(self) -> None:
+        # Remove rows that are done (finished, cancelled, error)
+        for row in list(self._rows):
+            if row.state() in ("finished", "cancelled", "error"):
+                try:
+                    self.downloads_box.remove(row)
+                except Exception:
+                    pass
+                try:
+                    self._rows.remove(row)
+                except Exception:
+                    pass

     def _cancel_row(self, row: DownloadRow | None) -> None:
         # If None passed (shouldn't happen), ignore
         if row is None:
             return
@@ -233,6 +358,7 @@ class DownloadManager:
         self._active += 1
         advanced = (
             bool(opts.extra_flags.strip())
             or bool(opts.sort_string.strip())
             or bool(opts.sb_mark.strip())
@@ -269,6 +395,7 @@ class DownloadManager:
                 GLib.idle_add(_done)

         if advanced:
             cli = opts.raw_cli_list()
             # Inject global proxy if configured and not set explicitly
@@ -287,8 +414,10 @@ class DownloadManager:
             task = RunnerDownloadTask(video, dest_dir, cli, bin_path=ytdlp_path)
             row.attach_task(task)
             # Update cancel binding to running task
             row._on_cancel = lambda: self._cancel_row(row)  # type: ignore[attr-defined]
             task.start(_on_update)
             return

         ydl_override = opts.to_ydl_opts()
         proxy = self.get_setting("http_proxy")
         if isinstance(proxy, str) and proxy.strip():
             ydl_override["proxy"] = proxy.strip()

         dl_task = DownloadTask(video=video, dest_dir=dest_dir, ydl_opts_override=ydl_override)
         row.attach_task(dl_task)
         row._on_cancel = lambda: self._cancel_row(row)  # type: ignore[attr-defined]
         dl_task.start(_on_update)
         return
diff --git a/src/whirltube/__init__.py b/src/whirltube/__init__.py
index 4a9860a..f5dba0b 100644
--- a/src/whirltube/__init__.py
+++ b/src/whirltube/__init__.py
@@ -1,5 +1,5 @@
 from __future__ import annotations

 __all__ = ["__version__"]
-__version__ = "0.4.3"
+__version__ = "0.4.4"