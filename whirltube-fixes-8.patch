diff --git a/src/whirltube/dialogs.py b/src/whirltube/dialogs.py
index 5e1ce59..3bcab4b 100644
--- a/src/whirltube/dialogs.py
+++ b/src/whirltube/dialogs.py
 @@ -20,6 +20,7 @@ from gi.repository import Adw, Gio, Gtk
 class PreferencesWindow(Adw.PreferencesWindow):
     def __init__(self, parent: Gtk.Window, settings: dict) -> None:
         super().__init__(transient_for=parent, modal=True, title="Preferences")
         self.settings = settings
         self.set_search_enabled(False)
 @@ -88,10 +89,20 @@ class PreferencesWindow(Adw.PreferencesWindow):
         self.entry_proxy.set_text(settings.get("http_proxy", ""))
         group_net.add(self.entry_proxy)
 
+        # Queue / concurrency
+        group_queue = Adw.PreferencesGroup(title="Queue")
+        page_dl.add(group_queue)
+        self.spin_concurrent = Adw.SpinRow.new_with_range(1, 8, 1)
+        self.spin_concurrent.set_title("Max concurrent downloads")
+        try:
+            self.spin_concurrent.set_value(float(int(settings.get("max_concurrent_downloads", 3) or 3)))
+        except Exception:
+            self.spin_concurrent.set_value(3.0)
+        group_queue.add(self.spin_concurrent)
+
         self.add(page_play)
         self.add(page_dl)
 
         self.connect("close-request", self._on_close)
 @@ -121,6 +132,8 @@ class PreferencesWindow(Adw.PreferencesWindow):
         self.settings["mpv_cookies_profile"] = self.entry_profile.get_text()
         self.settings["mpv_cookies_container"] = self.entry_container.get_text()
         # Global proxy
         self.settings["http_proxy"] = self.entry_proxy.get_text()
+        # Concurrency
+        self.settings["max_concurrent_downloads"] = int(self.spin_concurrent.get_value())
         return False
diff --git a/src/whirltube/window.py b/src/whirltube/window.py
index ac9f5f8..d674648 100644
--- a/src/whirltube/window.py
+++ b/src/whirltube/window.py
 @@ -85,6 +85,7 @@ class MainWindow(Adw.ApplicationWindow):
         self.settings.setdefault("mpv_cookies_profile", "")
         self.settings.setdefault("mpv_cookies_container", "")
 
+        self.settings.setdefault("max_concurrent_downloads", 3)
         # Initialize provider with global proxy and optional Invidious
         proxy = (self.settings.get("http_proxy") or "").strip() or None
         if bool(self.settings.get("use_invidious")):
 @@ -171,6 +172,7 @@ class MainWindow(Adw.ApplicationWindow):
             show_error=self._show_error,
         )
         self.download_manager.set_download_dir(self.download_dir)
+        self.download_manager.set_max_concurrent(int(self.settings.get("max_concurrent_downloads") or 3))
 
         self._create_actions()
         self._set_welcome()
 @@ -284,6 +286,8 @@ class MainWindow(Adw.ApplicationWindow):
                 else:
                     self.provider = YTDLPProvider(proxy or None)
             except Exception:
                 # fallback to yt-dlp
                 self.provider = YTDLPProvider(proxy or None)
+            # Update concurrency at runtime
+            self.download_manager.set_max_concurrent(int(self.settings.get("max_concurrent_downloads") or 3))
 
         win.connect("close-request", persist)
 @@ -457,6 +461,18 @@ class ResultRow(Gtk.Box):
             btn_box.append(rel_btn)
             btn_box.append(cmt_btn)
         else:
             # Non-playable: show Open; if channel, also Follow/Unfollow
             open_btn = Gtk.Button(label="Open")
             open_btn.set_tooltip_text("Open this playlist/channel")
             open_btn.connect("clicked", lambda *_: self.on_open(self.video))
             btn_box.append(open_btn)
             if self.video.kind == "channel":
                 label = "Unfollow" if self._followed else "Follow"
                 follow_btn = Gtk.Button(label=label)
                 def _toggle_follow(_btn):
                     try:
                         if self._followed:
                             if self.on_unfollow: self.on_unfollow(self.video)
                             self._followed = False
                             _btn.set_label("Follow")
                         else:
                             if self.on_follow: self.on_follow(self.video)
                             self._followed = True
                             _btn.set_label("Unfollow")
                     except Exception:
                         pass
                 follow_btn.connect("clicked", _toggle_follow)
                 btn_box.append(follow_btn)
+        # Common actions: open in browser, copy URL
+        open_web = Gtk.Button(label="Open in Browser")
+        open_web.connect("clicked", lambda *_: self._open_in_browser())
+        copy_url = Gtk.Button(label="Copy URL")
+        copy_url.connect("clicked", lambda *_: self._copy_url())
+        btn_box.append(open_web)
+        btn_box.append(copy_url)
         self.append(btn_box)
 
         # Load thumbnail
         if video.thumb_url:
             self.thumb_loader_pool.submit(self._load_thumb)
         else:
             # No URL -> placeholder
             GLib.idle_add(self._set_thumb_placeholder)
 @@ -516,6 +532,18 @@ class ResultRow(Gtk.Box):
         # Put the placeholder at the start (thumbnail slot)
         self.prepend(ph)
 
+    def _open_in_browser(self) -> None:
+        try:
+            if self.video and self.video.url:
+                Gio.AppInfo.launch_default_for_uri(self.video.url, None)
+        except Exception:
+            pass
+
+    def _copy_url(self) -> None:
+        try:
+            disp = Gdk.Display.get_default()
+            if disp and self.video and self.video.url:
+                disp.get_clipboard().set_text(self.video.url)
+        except Exception:
+            pass
+
 def _fmt_meta(v: Video) -> str:
     ch = v.channel or "Unknown channel"
     dur = v.duration_str
diff --git a/src/whirltube/download_manager.py b/src/whirltube/download_manager.py
index 7a93083..58f5118 100644
--- a/src/whirltube/download_manager.py
+++ b/src/whirltube/download_manager.py
 @@ -1,9 +1,10 @@
 from __future__ import annotations
 
 import logging
 from pathlib import Path
 from collections.abc import Callable
+from typing import Any
 
 import gi
 
 @@ -17,36 +18,58 @@ from .models import Video
 from .dialogs import DownloadOptions
 from .download_history import add_download
 
 log = logging.getLogger(__name__)
 
 class DownloadRow(Gtk.Box):
-    def __init__(self, task) -> None:
+    def __init__(self, task: Any | None = None, title: str | None = None) -> None:
         super().__init__(orientation=Gtk.Orientation.VERTICAL, spacing=6)
-        self.task = task
+        self.task = task
+        self._base_title = title or getattr(getattr(task, "video", None), "title", "Download")
 
         self.set_margin_top(6)
         self.set_margin_bottom(6)
 
-        video = getattr(task, "video", None)
-        title = video.title if video else "Download"
-        self.label = Gtk.Label(label=f"Downloading: {title}", xalign=0.0, wrap=True)
+        start_label = "Downloading" if task else "Queued"
+        self.label = Gtk.Label(label=f"{start_label}: {self._base_title}", xalign=0.0, wrap=True)
         self.progress = Gtk.ProgressBar(show_text=True)
         self.status = Gtk.Label(label="", xalign=0.0)
 
         # Actions row (open folder/file)
         self.actions = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
         self.btn_open_folder = Gtk.Button(label="Open folder")
         self.btn_open_folder.set_sensitive(False)
         self.btn_open_folder.connect("clicked", self._open_folder)
         self.btn_open_file = Gtk.Button(label="Open file")
         self.btn_open_file.set_sensitive(False)
         self.btn_open_file.connect("clicked", self._open_file)
 
         self.actions.append(self.btn_open_folder)
         self.actions.append(self.btn_open_file)
 
         self.append(self.label)
         self.append(self.progress)
         self.append(self.status)
         self.append(self.actions)
 
+    def set_queued(self) -> None:
+        try:
+            self.label.set_text(f"Queued: {self._base_title}")
+            self.progress.set_fraction(0.0)
+            self.progress.set_text("")
+            self.status.set_text("")
+        except Exception:
+            pass
+
+    def attach_task(self, task: Any) -> None:
+        self.task = task
+        try:
+            self.label.set_text(f"Downloading: {self._base_title}")
+        except Exception:
+            pass
+
     def update_progress(self, p: DownloadProgress) -> None:
+        # Switch label when we get the first real progress
+        if p.status == "downloading":
+            try:
+                self.label.set_text(f"Downloading: {self._base_title}")
+            except Exception:
+                pass
         frac = 0.0
         if p.bytes_total and p.bytes_total > 0:
             frac = min(1.0, max(0.0, p.bytes_downloaded / p.bytes_total))
         self.progress.set_fraction(frac)
         self.progress.set_text(_fmt_dl_text(p))
 @@ -79,10 +102,19 @@ def _fmt_dl_status(p: DownloadProgress) -> str:
     return " â€¢ ".join(parts)
 
 
 class DownloadManager:
     def __init__(self, downloads_box: Gtk.Box, show_downloads_view: Callable[[], None], get_setting: Callable[[str], str|bool|int|None], show_error: Callable[[str], None]) -> None:
         self.downloads_box = downloads_box
         self.show_downloads_view = show_downloads_view
         self.get_setting = get_setting
         self.show_error = show_error
         self.download_dir: Path | None = None # This will be set by MainWindow
+        self._max_concurrent: int = 3
+        self._active: int = 0
+        # queue of (video, opts, dest_dir, row)
+        self._queue: list[tuple[Video, DownloadOptions, Path, DownloadRow]] = []
 
     def set_download_dir(self, path: Path) -> None:
         self.download_dir = path
+
+    def set_max_concurrent(self, n: int) -> None:
+        try:
+            self._max_concurrent = max(1, int(n))
+        except Exception:
+            self._max_concurrent = 1
+        self._maybe_start_next()
 
     def _ensure_download_dir(self, path: Path) -> bool:
         try:
             path.mkdir(parents=True, exist_ok=True)
             return True
 @@ -92,52 +124,119 @@ class DownloadManager:
 
     def start_download(self, video: Video, opts: DownloadOptions) -> None:
         dest_dir = opts.target_dir or Path(self.get_setting("download_dir") or str(self.download_dir))
         if not self._ensure_download_dir(dest_dir):
             return
+        # Create a queued row immediately
+        row = DownloadRow(None, title=video.title)
+        row.set_queued()
+        self.downloads_box.append(row)
+        self.show_downloads_view()
+        # Enqueue and attempt to start
+        self._queue.append((video, opts, dest_dir, row))
+        self._maybe_start_next()
 
+    def _maybe_start_next(self) -> None:
+        # Start as many as allowed
+        while self._active < self._max_concurrent and self._queue:
+            video, opts, dest_dir, row = self._queue.pop(0)
+            self._start_task(video, opts, dest_dir, row)
+
+    def _start_task(self, video: Video, opts: DownloadOptions, dest_dir: Path, row: DownloadRow) -> None:
+        self._active += 1
+        advanced = (
+            bool(opts.extra_flags.strip())
+            or bool(opts.sort_string.strip())
+            or bool(opts.sb_mark.strip())
+            or bool(opts.sb_remove.strip())
+            or opts.embed_metadata
+            or opts.embed_thumbnail
+            or opts.write_thumbnail
+            or bool(opts.limit_rate.strip())
+            or (opts.concurrent_fragments > 0)
+            or bool(opts.impersonate.strip())
+            or (opts.use_cookies and bool(opts.cookies_browser.strip()))
+        )
+
+        def _on_update(p: DownloadProgress) -> None:
+            GLib.idle_add(row.update_progress, p)
+            if p.status in ("finished", "error"):
+                # Book-keeping on main loop
+                def _done():
+                    try:
+                        if p.status == "finished":
+                            try:
+                                add_download(video, dest_dir, p.filename)
+                            except Exception:
+                                pass
+                    finally:
+                        self._active = max(0, self._active - 1)
+                        self._maybe_start_next()
+                    return False
+                GLib.idle_add(_done)
+
+        if advanced:
+            cli = opts.raw_cli_list()
+            # Inject global proxy if configured and not set explicitly
+            proxy = self.get_setting("http_proxy")
+            if isinstance(proxy, str) and proxy.strip() and "--proxy" not in cli:
+                cli = ["--proxy", proxy.strip()] + cli
+            # Optional custom yt-dlp binary path from settings
+            ytdlp_path = self.get_setting("ytdlp_path")
+            if not isinstance(ytdlp_path, str) or not ytdlp_path.strip():
+                ytdlp_path = None
+            task = RunnerDownloadTask(video, dest_dir, cli, bin_path=ytdlp_path)
+            row.attach_task(task)
+            task.start(_on_update)
+            return
+
+        ydl_override = opts.to_ydl_opts()
+        proxy = self.get_setting("http_proxy")
+        if isinstance(proxy, str) and proxy.strip():
+            ydl_override["proxy"] = proxy.strip()
+
+        dl_task = DownloadTask(video=video, dest_dir=dest_dir, ydl_opts_override=ydl_override)
+        row.attach_task(dl_task)
+        dl_task.start(_on_update)
+        return
-
-        advanced = (
-            bool(opts.extra_flags.strip())
-            or bool(opts.sort_string.strip())
-            or bool(opts.sb_mark.strip())
-            or bool(opts.sb_remove.strip())
-            or opts.embed_metadata
-            or opts.embed_thumbnail
-            or opts.write_thumbnail
-            or bool(opts.limit_rate.strip())
-            or (opts.concurrent_fragments > 0)
-            or bool(opts.impersonate.strip())
-            or (opts.use_cookies and bool(opts.cookies_browser.strip()))
-        )
-
-        if advanced:
-            cli = opts.raw_cli_list()
-            # Inject global proxy if configured and not set explicitly
-            proxy = self.get_setting("http_proxy")
-            if isinstance(proxy, str) and proxy.strip() and "--proxy" not in cli:
-                cli = ["--proxy", proxy.strip()] + cli
-            # Optional custom yt-dlp binary path from settings
-            ytdlp_path = self.get_setting("ytdlp_path")
-            if not isinstance(ytdlp_path, str) or not ytdlp_path.strip():
-                ytdlp_path = None
-            task = RunnerDownloadTask(video, dest_dir, cli, bin_path=ytdlp_path)
-            row = DownloadRow(task)
-            self.downloads_box.append(row)
-            self.show_downloads_view()
-
-            def on_update(p: DownloadProgress) -> None:
-                GLib.idle_add(row.update_progress, p)
-                if p.status == "finished":
-                    try:
-                        add_download(video, dest_dir, p.filename)
-                    except Exception:
-                        pass
-
-            task.start(on_update)
-            return
-
-        ydl_override = opts.to_ydl_opts()
-        proxy = self.get_setting("http_proxy")
-        if isinstance(proxy, str) and proxy.strip():
-            ydl_override["proxy"] = proxy.strip()
-
-        dl_task = DownloadTask(video=video, dest_dir=dest_dir, ydl_opts_override=ydl_override)
-            row = DownloadRow(dl_task)
-            self.downloads_box.append(row)
-            self.show_downloads_view()
-
-        def on_update(p: DownloadProgress) -> None:
-            GLib.idle_add(row.update_progress, p)
-            if p.status == "finished":
-                try:
-                    add_download(video, dest_dir, p.filename)
-                except Exception:
-                    pass
-
-        dl_task.start(on_update)
diff --git a/src/whirltube/__init__.py b/src/whirltube/__init__.py
index b1f8a7b..4a9860a 100644
--- a/src/whirltube/__init__.py
+++ b/src/whirltube/__init__.py
 @@ -1,5 +1,5 @@
 from __future__ import annotations
 
 __all__ = ["__version__"]
-__version__ = "0.4.2"
+__version__ = "0.4.3"
PATCH