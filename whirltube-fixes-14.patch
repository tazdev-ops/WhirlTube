diff --git a/pyproject.toml b/pyproject.toml
index ca0493a..a3a3a1c 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -16,6 +16,7 @@ dependencies = [
 [project.optional-dependencies]
 dev = [
   "ruff>=0.6.9",
   "mypy>=1.11",
   "pytest>=8.3",
   "pytest-cov>=5.0",
 ]
@@ -42,6 +43,7 @@ include = [
   "README.md",
   "CHANGELOG.md",
   "LICENSE",
   "pyproject.toml",
   "mypy.ini",
   "ruff.toml",
   "tests/**",
   "data/**",
+  "flatpak/**",
 ]
diff --git a/src/whirltube/dialogs.py b/src/whirltube/dialogs.py
index 5f8f052..f9d66f1 100644
--- a/src/whirltube/dialogs.py
+++ b/src/whirltube/dialogs.py
@@ -98,6 +98,18 @@ class PreferencesWindow(Adw.PreferencesWindow):
         group_dl = Adw.PreferencesGroup(title="Location")
         page_dl.add(group_dl)
 
+        # After completion
+        group_after = Adw.PreferencesGroup(title="After completion")
+        page_dl.add(group_after)
+        self.sw_auto_open = Adw.SwitchRow(title="Open download folder when a download finishes")
+        self.sw_auto_open.set_active(bool(settings.get("download_auto_open_folder", False)))
+        group_after.add(self.sw_auto_open)
+
+        # Filename template
+        self.entry_template = Adw.EntryRow(title="Filename template")
+        self.entry_template.set_text(settings.get("download_template", "%(title)s.%(ext)s"))
+        self.entry_template.set_tooltip_text("yt-dlp template, e.g. %(title)s.%(ext)s or %(uploader)s/%(title)s.%(ext)s")
+        group_dl.add(self.entry_template)
 
         self.download_button = Adw.ActionRow(title="Download directory")
         self._download_dir_label = Gtk.Label(label=settings.get("download_dir", ""), xalign=1.0)
         self.download_button.add_suffix(self._download_dir_label)
         self.download_button.set_activatable(True)
@@ -180,6 +192,8 @@ class PreferencesWindow(Adw.PreferencesWindow):
         self.settings["mpv_cookies_container"] = self.entry_container.get_text()
         # Global proxy
         self.settings["http_proxy"] = self.entry_proxy.get_text()
         # Auto-hide MPV controls
         self.settings["mpv_autohide_controls"] = bool(self.autohide_controls.get_active())
+        # After completion + template
+        self.settings["download_auto_open_folder"] = bool(self.sw_auto_open.get_active())
         self.settings["download_template"] = self.entry_template.get_text().strip() or "%(title)s.%(ext)s"
         # Concurrency
         self.settings["max_concurrent_downloads"] = int(self.spin_concurrent.get_value())
         # Provider settings
         self.settings["use_invidious"] = bool(self.use_invidious.get_active())
diff --git a/src/whirltube/window.py b/src/whirltube/window.py
index c9c1c8f..3b396e2 100644
--- a/src/whirltube/window.py
+++ b/src/whirltube/window.py
@@ -80,6 +80,7 @@ class MainWindow(Adw.ApplicationWindow):
 
         self.settings.setdefault("max_concurrent_downloads", 3)
         self.settings.setdefault("mpv_autohide_controls", False)
         self.settings.setdefault("download_template", "%(title)s.%(ext)s")
+        self.settings.setdefault("download_auto_open_folder", False)
         # Window size persistence
         self.settings.setdefault("win_w", 1080)
         self.settings.setdefault("win_h", 740)
@@ -208,6 +209,7 @@ class MainWindow(Adw.ApplicationWindow):
             show_downloads_view=lambda: self.navigation_controller.show_view("downloads"),
             get_setting=self.settings.get,
             show_error=self._show_error,
             show_toast=self._show_toast,
         )
         self.download_manager.set_download_dir(self.download_dir)
         self.download_manager.set_max_concurrent(int(self.settings.get("max_concurrent_downloads") or 3))
+        self.download_manager.restore_queued()
 
         self._create_actions()
         self._set_welcome()
         self._install_shortcuts()
@@ -315,6 +317,8 @@ class MainWindow(Adw.ApplicationWindow):
 
     def _on_main_close(self, *_a) -> bool:
         # Persist current window size
         try:
             self.settings["win_w"], self.settings["win_h"] = int(self.get_width()), int(self.get_height())
         except Exception:
             pass
+        # Persist queue (best effort)
+        try: self.download_manager.persist_queue()
+        except Exception: pass
         save_settings(self.settings)
         return False
diff --git a/src/whirltube/download_manager.py b/src/whirltube/download_manager.py
index 9c314f2..8a142f8 100644
--- a/src/whirltube/download_manager.py
+++ b/src/whirltube/download_manager.py
@@ -1,13 +1,16 @@
 from __future__ import annotations
 
 import logging
+import json
 from pathlib import Path
 from collections.abc import Callable
 from typing import Any
 from functools import partial
 from copy import deepcopy
+from dataclasses import asdict
 
 import gi
 
 gi.require_version("Gtk", "4.0")
 gi.require_version("Adw", "1")
 from gi.repository import Adw, GLib, Gio, Gtk
@@ -16,7 +19,7 @@ from .downloader import DownloadProgress, DownloadTask, RunnerDownloadTask
 from .models import Video
 from .dialogs import DownloadOptions
 from .download_history import add_download
-
+from .util import xdg_data_dir
 log = logging.getLogger(__name__)
 
 def _notify(summary: str) -> None:
     # Best-effort desktop notification without requiring GI at import time.
@@ -30,6 +33,9 @@ def _notify(summary: str) -> None:
     except Exception:
         pass
 
+_QUEUE_FILE = xdg_data_dir() / "download_queue.json"
+
+
 class DownloadRow(Gtk.Box):
     def __init__(self, task: Any | None = None, title: str | None = None, on_cancel: Callable[[], None] | None = None, on_retry: Callable[[], None] | None = None, on_remove: Callable[[], None] | None = None) -> None:
         super().__init__(orientation=Gtk.Orientation.VERTICAL, spacing=6)
         self.task = task
@@ -85,6 +91,7 @@ class DownloadRow(Gtk.Box):
         self._btn_m_open_folder = Gtk.Button(label="Open folder")
         self._btn_m_open_folder.connect("clicked", self._open_folder)
         self._btn_m_show_containing = Gtk.Button(label="Show in folder")
         self._btn_m_show_containing.connect("clicked", self._show_in_folder)
+        self._btn_m_copy_path = Gtk.Button(label="Copy file path")
+        self._btn_m_copy_path.connect("clicked", self._copy_path)
         self._btn_m_open_file = Gtk.Button(label="Open file")
         self._btn_m_open_file.connect("clicked", self._open_file)
-        for b in (self._btn_m_cancel, self._btn_m_retry, self._btn_m_remove, self._btn_m_open_folder, self._btn_m_show_containing, self._btn_m_open_file):
+        for b in (self._btn_m_cancel, self._btn_m_retry, self._btn_m_remove, self._btn_m_open_folder, self._btn_m_show_containing, self._btn_m_copy_path, self._btn_m_open_file):
             vbox.append(b)
         pop.set_child(vbox)
         self.menu_btn.set_popover(pop)
         self.actions.append(self.menu_btn)
@@ -145,18 +152,21 @@ class DownloadRow(Gtk.Box):
         if p.status == "finished":
             # Adjust menu item sensitivity
             self._btn_m_cancel.set_sensitive(False)
             self._btn_m_retry.set_sensitive(False)
             self._btn_m_remove.set_sensitive(True)
             self._btn_m_open_folder.set_sensitive(True)
             self._btn_m_open_file.set_sensitive(True)
             self._btn_m_show_containing.set_sensitive(True)
+            self._btn_m_copy_path.set_sensitive(True)
             self._state = "finished"
         elif p.status == "error":
             # Disable cancel after error
             self._btn_m_cancel.set_sensitive(False)
             self._btn_m_retry.set_sensitive(True)
             self._btn_m_remove.set_sensitive(True)
             self._btn_m_open_folder.set_sensitive(True)
             self._btn_m_show_containing.set_sensitive(True)
+            # Copy path and open file may still not be resolvable; keep conservative
+            self._btn_m_copy_path.set_sensitive(False)
             self._state = "error"
 
     def _open_folder(self, *_a) -> None:
         try:
             dest = getattr(self.task, "dest_dir", None)
@@ -189,6 +199,23 @@ class DownloadRow(Gtk.Box):
         except Exception:
             pass
 
+    def _copy_path(self, *_a) -> None:
+        try:
+            p: DownloadProgress = getattr(self.task, "progress", None)
+            dest: Path = getattr(self.task, "dest_dir", None)
+            if p and p.filename:
+                fp = Path(p.filename)
+                if not fp.is_absolute() and isinstance(dest, Path):
+                    fp = dest / fp
+                disp = Gdk.Display.get_default()
+                if disp:
+                    disp.get_clipboard().set_text(str(fp))
+                return
+        except Exception:
+            pass
+        # Fallback: copy dest_dir
+        try:
+            disp = Gdk.Display.get_default()
+            if disp:
+                dest: Path = getattr(self.task, "dest_dir", None)
+                if isinstance(dest, Path):
+                    disp.get_clipboard().set_text(str(dest))
+        except Exception:
+            pass
+
     def mark_cancelled(self) -> None:
         try:
             self.label.set_text(f"Cancelled: {self._base_title}")
             self.status.set_text("Cancelled")
             self.progress.set_fraction(0.0)
@@ -193,6 +220,7 @@ class DownloadRow(Gtk.Box):
             self._btn_m_cancel.set_sensitive(False)
             self._btn_m_retry.set_sensitive(True)
             self._btn_m_remove.set_sensitive(True)
             self._btn_m_open_folder.set_sensitive(True)
             self._btn_m_show_containing.set_sensitive(True)
+            self._btn_m_copy_path.set_sensitive(False)
             self._state = "cancelled"
         except Exception:
             pass
@@ -213,6 +241,8 @@ class DownloadManager:
         self._active: int = 0
         # queue of (video, opts, dest_dir, row)
         self._queue: list[tuple[Video, DownloadOptions, Path, DownloadRow]] = []
         self._rows: list[DownloadRow] = []
+        # persistent queue path
+        self._queue_path: Path = _QUEUE_FILE
 
     def set_download_dir(self, path: Path) -> None:
         self.download_dir = path
 
@@ -241,6 +271,7 @@ class DownloadManager:
         self.downloads_box.append(row)
         self._rows.append(row)
         self.show_downloads_view()
         # Enqueue and attempt to start
         self._queue.append((video, opts, dest_dir, row))
+        self._persist_queue()
         self._maybe_start_next()
 
     def _maybe_start_next(self) -> None:
         # Start as many as allowed
         while self._active < self._max_concurrent and self._queue:
             video, opts, dest_dir, row = self._queue.pop(0)
+            self._persist_queue()
             self._start_task(video, opts, dest_dir, row)
 
     def _retry_row(self, row: DownloadRow | None) -> None:
         if row is None:
             return
@@ -275,6 +306,7 @@ class DownloadManager:
                 try:
                     self._queue.pop(i)
                 except Exception:
                     pass
                 row.mark_cancelled()
+                self._persist_queue()
                 return
         # If running: try to stop the task
         task = getattr(row, "task", None)
         if task is None:
             row.mark_cancelled()
@@ -298,6 +330,76 @@ class DownloadManager:
                 except Exception:
                     pass
 
+    def persist_queue(self) -> None:
+        """Public: persist current queued items to disk."""
+        self._persist_queue()
+
+    def _persist_queue(self) -> None:
+        """Write only queued items (not running) to a JSON file."""
+        try:
+            items = []
+            for v, o, d, r in self._queue:
+                # Serialize dataclasses; avoid Path in opts to keep JSON simple
+                vd = asdict(v)
+                od = asdict(o)
+                od.pop("target_dir", None)
+                items.append(
+                    {
+                        "video": vd,
+                        "opts": od,
+                        "dest_dir": str(d),
+                        "title": v.title,
+                    }
+                )
+            self._queue_path.parent.mkdir(parents=True, exist_ok=True)
+            tmp = self._queue_path.with_suffix(".tmp")
+            tmp.write_text(json.dumps(items, ensure_ascii=False, indent=2), encoding="utf-8")
+            tmp.replace(self._queue_path)
+        except Exception:
+            pass
+
+    def restore_queued(self) -> None:
+        """Restore queued items from disk and enqueue them."""
+        p = self._queue_path
+        if not p.exists():
+            return
+        try:
+            data = json.loads(p.read_text(encoding="utf-8"))
+            if not isinstance(data, list):
+                return
+        except Exception:
+            return
+        for it in data:
+            try:
+                if not isinstance(it, dict):
+                    continue
+                vraw = it.get("video") or {}
+                oraw = it.get("opts") or {}
+                dstr = it.get("dest_dir") or ""
+                if not isinstance(vraw, dict) or not isinstance(oraw, dict) or not isinstance(dstr, str):
+                    continue
+                video = Video(
+                    id=str(vraw.get("id") or ""),
+                    title=vraw.get("title") or "",
+                    url=vraw.get("url") or "",
+                    channel=vraw.get("channel"),
+                    duration=vraw.get("duration"),
+                    thumb_url=vraw.get("thumb_url"),
+                    kind=vraw.get("kind") or "video",
+                )
+                opts = DownloadOptions(**oraw)
+                dest_dir = Path(dstr)
+                # Create row in UI as queued and put into _queue
+                row = DownloadRow(None, title=video.title, on_cancel=partial(self._cancel_row, None), on_retry=partial(self._retry_row, None), on_remove=partial(self._remove_row, None))
+                row._on_cancel = partial(self._cancel_row, row)  # type: ignore[attr-defined]
+                row._on_retry = partial(self._retry_row, row)  # type: ignore[attr-defined]
+                row._on_remove = partial(self._remove_row, row)  # type: ignore[attr-defined]
+                row.set_metadata(video, opts, dest_dir)
+                row.set_queued()
+                self.downloads_box.append(row)
+                self._rows.append(row)
+                self._queue.append((video, opts, dest_dir, row))
+            except Exception:
+                continue
+        # Kick off any that fit concurrency
+        self._maybe_start_next()
+
     def _start_task(self, video: Video, opts: DownloadOptions, dest_dir: Path, row: DownloadRow) -> None:
         self._active += 1
         advanced = (
             bool(opts.extra_flags.strip())
             or bool(opts.sort_string.strip())
@@ -336,6 +438,18 @@ class DownloadManager:
                         if p.status == "finished":
                             try:
                                 add_download(video, dest_dir, p.filename)
                             except Exception:
                                 pass
                             _notify(f"Downloaded: {video.title}")
                             self.show_toast(f"Downloaded: {video.title}")
+                            # Auto-open download folder if enabled
+                            try:
+                                if bool(self.get_setting("download_auto_open_folder")):
+                                    self._open_folder(dest_dir)
+                            except Exception:
+                                pass
                         elif p.status == "error":
                             _notify(f"Download failed: {video.title}")
                             self.show_toast(f"Download failed: {video.title}")
                     finally:
                         self._active = max(0, self._active - 1)
                         self._maybe_start_next()
                     return False
                 GLib.idle_add(_done)
@@ -390,3 +504,12 @@ class DownloadManager:
         row._on_cancel = lambda: self._cancel_row(row)  # type: ignore[attr-defined]
         dl_task.start(_on_update)
         return
 
+    @staticmethod
+    def _open_folder(path: Path) -> None:
+        try:
+            if isinstance(path, Path) and path.exists():
+                Gio.AppInfo.launch_default_for_uri(f"file://{path}", None)
+        except Exception:
+            pass
+