diff --git a/src/whirltube/downloader.py b/src/whirltube/downloader.py
index 9385da8..d0af8bb 100644
--- a/src/whirltube/downloader.py
+++ b/src/whirltube/downloader.py
@@ -1,6 +1,7 @@
 from __future__ import annotations

 import subprocess
 import threading
+from threading import Event
 from collections.abc import Callable
 from dataclasses import dataclass, field
 from pathlib import Path
@@ -30,6 +31,7 @@
     progress: DownloadProgress = field(default_factory=DownloadProgress)
     _thread: threading.Thread | None = field(default=None, init=False)
     ydl_opts_override: dict | None = None  # allow per-download overrides
+    _cancel: Event = field(default_factory=Event, init=False)

     def start(self, on_update: Callable[[DownloadProgress], None]) -> None:
         """Start the download in a background thread using yt-dlp Python API."""
         if self._thread and self._thread.is_alive():
             return
@@ -37,6 +39,9 @@
         def hook(d: dict) -> None:
             st = d.get("status")
+            # Cancellation path: raising in hook aborts the download in yt-dlp
+            if self._cancel.is_set():
+                raise KeyboardInterrupt("Cancelled")
             if st == "downloading":
                 self.progress.status = "downloading"
                 self.progress.bytes_downloaded = int(d.get("downloaded_bytes") or 0)
                 tb = d.get("total_bytes") or d.get("total_bytes_estimate") or 0
                 self.progress.bytes_total = int(tb) or None
@@ -70,6 +75,16 @@
                 self.progress.status = "error"
                 self.progress.error = str(e)
                 on_update(self.progress)

         self._thread = threading.Thread(target=run, daemon=True)
         self._thread.start()
+
+    def stop(self) -> None:
+        """
+        Best-effort cancellation. For Python API we signal via hook and let yt-dlp abort soon.
+        """
+        try:
+            self._cancel.set()
+        except Exception:
+            pass
+        # Thread will exit after yt-dlp aborts; no force-termination here


 class SubprocessDownloadTask:
diff --git a/src/whirltube/provider.py b/src/whirltube/provider.py
index 0000000..3b2a2a0 100644
--- a/src/whirltube/provider.py
+++ b/src/whirltube/provider.py
@@ -1,6 +1,8 @@
 from __future__ import annotations

 import logging
 import datetime
 import time
+from typing import Optional

 from yt_dlp import YoutubeDL

@@ -197,6 +199,23 @@
                 except Exception as e:
                     log.debug("related fallback search failed: %s", e)
         return out
+    # ---------- Metadata helpers ----------
+    def channel_url_of(self, video_url: str) -> str | None:
+        """
+        Return the channel URL for a given video URL if available.
+        """
+        try:
+            info = self._ydl_full.extract_info(video_url, download=False)
+        except Exception:
+            return None
+        if not isinstance(info, dict):
+            return None
+        ch = info.get("channel_url") or info.get("uploader_url")
+        if isinstance(ch, str) and ch.strip():
+            return ch.strip()
+        cid = info.get("channel_id") or info.get("uploader_id")
+        if isinstance(cid, str) and cid.strip() and cid.startswith("UC"):
+            return f"https://www.youtube.com/channel/{cid.strip()}"
+        return None

     def comments(self, video_url: str, max_comments: int = 100) -> list[Video]:
         """Fetch top-level comments when available via yt-dlp API."""
diff --git a/src/whirltube/invidious_provider.py b/src/whirltube/invidious_provider.py
index e22e547..0d62dfa 100644
--- a/src/whirltube/invidious_provider.py
+++ b/src/whirltube/invidious_provider.py
@@ -170,6 +170,9 @@
     def fetch_formats(self, url: str) -> list[tuple[str, str]]:
         return self._fallback.fetch_formats(url)

+    def channel_url_of(self, video_url: str) -> str | None:
+        return self._fallback.channel_url_of(video_url)
+
diff --git a/src/whirltube/window.py b/src/whirltube/window.py
index 39113e6..40402d6 100644
--- a/src/whirltube/window.py
+++ b/src/whirltube/window.py
@@ -61,6 +61,9 @@
         self.settings.setdefault("mpv_cookies_container", "")

         self.settings.setdefault("max_concurrent_downloads", 3)
+        # Window size persistence
+        self.settings.setdefault("win_w", 1080)
+        self.settings.setdefault("win_h", 740)
         # Initialize provider with global proxy and optional Invidious
         proxy = (self.settings.get("http_proxy") or "").strip() or None
         if bool(self.settings.get("use_invidious")):
@@ -76,7 +79,12 @@
         super().__init__(application=app, title="WhirlTube")
-        self.set_default_size(1080, 740)
+        # Use persisted window size
+        try:
+            w = int(self.settings.get("win_w") or 1080)
+            h = int(self.settings.get("win_h") or 740)
+        except Exception:
+            w, h = 1080, 740
+        self.set_default_size(w, h)
         self.set_icon_name("whirltube")
@@ -301,6 +309,9 @@
         win.connect("close-request", persist)

     def _on_main_close(self, *_a) -> bool:
+        # Persist current window size
+        try:
+            self.settings["win_w"], self.settings["win_h"] = int(self.get_width()), int(self.get_height())
+        except Exception:
+            pass
         save_settings(self.settings)
         return False
@@ -439,6 +450,7 @@
                 on_download_opts=self._download_options,
                 on_open=self._open_item,
+                on_open_channel=self._open_channel_from_video,
                 on_related=self._on_related,
                 on_comments=self._on_comments,
                 thumb_loader_pool=self._thumb_loader_pool,
                 http_proxy=(self.settings.get("http_proxy") or None),
                 on_follow=self._follow_channel,
@@ -606,6 +618,23 @@
         threading.Thread(target=worker, daemon=True).start()

     def _on_comments(self, video: Video) -> None:
         self._show_loading(f"Comments for: {video.title}")
@@ -614,6 +643,27 @@
             GLib.idle_add(self._populate_results, vids)

         threading.Thread(target=worker, daemon=True).start()

+    def _open_channel_from_video(self, video: Video) -> None:
+        # Resolve channel URL from a video, then open channel view
+        self._show_loading(f"Opening channel for: {video.title}")
+        def worker():
+            try:
+                url = self.provider.channel_url_of(video.url)
+            except Exception:
+                url = None
+            if not url:
+                GLib.idle_add(self._show_error, "Unable to resolve channel for this video.")
+                return
+            # Reuse existing channel opener
+            def go():
+                self._open_channel(url)
+                return False
+            GLib.idle_add(go)
+        threading.Thread(target=worker, daemon=True).start()

     def _play_video(self, video: Video) -> None:
         # Save to watch history
         add_watch(video)
@@ -733,12 +781,20 @@
     def __init__(
         self,
         video: Video,
         on_play: Callable[[Video], None],
         on_download_opts: Callable[[Video], None],
         on_open: Callable[[Video], None],
+        on_open_channel: Callable[[Video], None],
         on_related: Callable[[Video], None],
         on_comments: Callable[[Video], None],
         thumb_loader_pool: ThreadPoolExecutor,
         http_proxy: str | None = None,
         on_follow: Callable[[Video], None] | None = None,
         on_unfollow: Callable[[Video], None] | None = None,
         followed: bool = False,
     ) -> None:
@@ -752,6 +808,7 @@
         self.on_download_opts = on_download_opts
         self.on_open = on_open
+        self.on_open_channel = on_open_channel
         self.on_related = on_related
         self.on_comments = on_comments
         self.thumb_loader_pool = thumb_loader_pool
         self.on_follow = on_follow
         self.on_unfollow = on_unfollow
@@ -785,6 +842,10 @@
             dl_btn.connect("clicked", lambda *_: self.on_download_opts(self.video))
             rel_btn = Gtk.Button(label="Related")
             rel_btn.connect("clicked", lambda *_: self.on_related(self.video))
             cmt_btn = Gtk.Button(label="Comments")
             cmt_btn.connect("clicked", lambda *_: self.on_comments(self.video))
+            ch_btn = Gtk.Button(label="Open channel")
+            ch_btn.set_tooltip_text("Open the uploader's channel")
+            ch_btn.connect("clicked", lambda *_: self.on_open_channel(self.video))
+            btn_box.append(ch_btn)
             btn_box.append(play_btn)
             btn_box.append(dl_btn)
             btn_box.append(rel_btn)
             btn_box.append(cmt_btn)
         else:
@@ -820,10 +881,14 @@
         open_web = Gtk.Button(label="Open in Browser")
         open_web.connect("clicked", lambda *_: self._open_in_browser())
         copy_url = Gtk.Button(label="Copy URL")
         copy_url.connect("clicked", lambda *_: self._copy_url())
+        copy_title = Gtk.Button(label="Copy Title")
+        copy_title.connect("clicked", lambda *_: self._copy_title())
         btn_box.append(open_web)
         btn_box.append(copy_url)
+        btn_box.append(copy_title)
         self.append(btn_box)

@@ -876,6 +941,13 @@
                 disp.get_clipboard().set_text(self.video.url)
         except Exception:
             pass

+    def _copy_title(self) -> None:
+        try:
+            disp = Gdk.Display.get_default()
+            if disp and self.video and self.video.title:
+                disp.get_clipboard().set_text(self.video.title)
+        except Exception:
+            pass

def _fmt_meta(v: Video) -> str:
    ch = v.channel or "Unknown channel"
    dur = v.duration_str
diff --git a/src/whirltube/download_manager.py b/src/whirltube/download_manager.py
index 58f5118..f1e1f0a 100644
--- a/src/whirltube/download_manager.py
+++ b/src/whirltube/download_manager.py
@@ -1,9 +1,10 @@
from __future__ import annotations

import logging
from pathlib import Path
from collections.abc import Callable
from typing import Any
+from functools import partial

import gi

@@ -21,17 +22,23 @@ from .download_history import add_download

log = logging.getLogger(__name__)

class DownloadRow(Gtk.Box):
-    def __init__(self, task: Any | None = None, title: str | None = None) -> None:
+    def __init__(self, task: Any | None = None, title: str | None = None, on_cancel: Callable[[], None] | None = None) -> None:
        super().__init__(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        self.task = task
        self._base_title = title or getattr(getattr(task, "video", None), "title", "Download")
+        self._on_cancel = on_cancel

        self.set_margin_top(6)
        self.set_margin_bottom(6)

        start_label = "Downloading" if task else "Queued"
        self.label = Gtk.Label(label=f"{start_label}: {self._base_title}", xalign=0.0, wrap=True)
        self.progress = Gtk.ProgressBar(show_text=True)
        self.status = Gtk.Label(label="", xalign=0.0)

        # Actions row (open folder/file)
        self.actions = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
+        self.btn_cancel = Gtk.Button(label="Cancel")
+        self.btn_cancel.connect("clicked", lambda *_: self._on_cancel_clicked())
        self.btn_open_folder = Gtk.Button(label="Open folder")
        self.btn_open_folder.set_sensitive(False)
        self.btn_open_folder.connect("clicked", self._open_folder)
        self.btn_open_file = Gtk.Button(label="Open file")
        self.btn_open_file.set_sensitive(False)
        self.btn_open_file.connect("clicked", self._open_file)

+        self.actions.append(self.btn_cancel)
        self.actions.append(self.btn_open_folder)
        self.actions.append(self.btn_open_file)

        self.append(self.label)
        self.append(self.progress)
        self.append(self.status)
        self.append(self.actions)

+    def _on_cancel_clicked(self) -> None:
+        try:
+            if self._on_cancel:
+                self._on_cancel()
+        finally:
+            # Disable cancel to avoid repeated presses
+            self.btn_cancel.set_sensitive(False)

    def set_queued(self) -> None:
        try:
            self.label.set_text(f"Queued: {self._base_title}")
            self.progress.set_fraction(0.0)
            self.progress.set_text("")
            self.status.set_text("")
        except Exception:
            pass

    def attach_task(self, task: Any) -> None:
        self.task = task
        try:
            self.label.set_text(f"Downloading: {self._base_title}")
        except Exception:
            pass

    def update_progress(self, p: DownloadProgress) -> None:
        # Switch label when we get the first real progress
        if p.status == "downloading":
            try:
                self.label.set_text(f"Downloading: {self._base_title}")
            except Exception:
                pass
        frac = 0.0
        if p.bytes_total and p.bytes_total > 0:
            frac = min(1.0, max(0.0, p.bytes_downloaded / p.bytes_total))
        self.progress.set_fraction(frac)
        self.progress.set_text(_fmt_dl_text(p))
        self.status.set_text(_fmt_dl_status(p))

        if p.status == "finished":
            # Enable actions
            self.btn_open_folder.set_sensitive(True)
            if p.filename:
                self.btn_open_file.set_sensitive(True)
+            # Disable cancel when done
+            self.btn_cancel.set_sensitive(False)
+        elif p.status == "error":
+            # Disable cancel after error
+            self.btn_cancel.set_sensitive(False)

    def _open_folder(self, *_a) -> None:
        try:
            dest = getattr(self.task, "dest_dir", None)
            if isinstance(dest, Path) and dest.exists():
                Gio.AppInfo.launch_default_for_uri(f"file://{dest}", None)
@@ -70,6 +77,18 @@
                if fp.exists():
                    Gio.AppInfo.launch_default_for_uri(f"file://{fp}", None)
        except Exception:
            pass

+    def mark_cancelled(self) -> None:
+        try:
+            self.label.set_text(f"Cancelled: {self._base_title}")
+            self.status.set_text("Cancelled")
+            self.progress.set_fraction(0.0)
+            self.progress.set_text("")
+            self.btn_cancel.set_sensitive(False)
+            # Keep folder/file buttons disabled
+        except Exception:
+            pass

def _fmt_dl_text(p: DownloadProgress) -> str:
   if p.status == "finished":
       return "100% (done)"
@@ -107,10 +126,12 @@
        self._max_concurrent: int = 3
        self._active: int = 0
        # queue of (video, opts, dest_dir, row)
        self._queue: list[tuple[Video, DownloadOptions, Path, DownloadRow]] = []

    def set_download_dir(self, path: Path) -> None:
        self.download_dir = path

    def set_max_concurrent(self, n: int) -> None:
        try:
            self._max_concurrent = max(1, int(n))
        except Exception:
            self._max_concurrent = 1
        self._maybe_start_next()
@@ -125,10 +146,13 @@
    def start_download(self, video: Video, opts: DownloadOptions) -> None:
        dest_dir = opts.target_dir or Path(self.get_setting("download_dir") or str(self.download_dir))
        if not self._ensure_download_dir(dest_dir):
            return
        # Create a queued row immediately
-        row = DownloadRow(None, title=video.title)
+        row = DownloadRow(None, title=video.title, on_cancel=partial(self._cancel_row, None))
+        # Store a weak binding to this specific row into the callback
+        row._on_cancel = partial(self._cancel_row, row)  # type: ignore[attr-defined]
        row.set_queued()
        self.downloads_box.append(row)
        self.show_downloads_view()
        # Enqueue and attempt to start
        self._queue.append((video, opts, dest_dir, row))
        self._maybe_start_next()
@@ -142,6 +166,31 @@
            video, opts, dest_dir, row = self._queue.pop(0)
            self._start_task(video, opts, dest_dir, row)

+    def _cancel_row(self, row: DownloadRow | None) -> None:
+        # If None passed (shouldn't happen), ignore
+        if row is None:
+            return
+        # If queued: remove from queue
+        for i, (_v, _o, _d, r) in enumerate(list(self._queue)):
+            if r is row:
+                try:
+                    self._queue.pop(i)
+                except Exception:
+                    pass
+                row.mark_cancelled()
+                return
+        # If running: try to stop the task
+        task = getattr(row, "task", None)
+        if task is None:
+            row.mark_cancelled()
+            return
+        try:
+            stop = getattr(task, "stop", None)
+            if callable(stop):
+                stop()
+        except Exception:
+            pass
+        row.mark_cancelled()

    def _start_task(self, video: Video, opts: DownloadOptions, dest_dir: Path, row: DownloadRow) -> None:
        self._active += 1
        advanced = (
            bool(opts.extra_flags.strip())
            or bool(opts.sort_string.strip())
@@ -162,6 +211,7 @@
        def _on_update(p: DownloadProgress) -> None:
            GLib.idle_add(row.update_progress, p)
            if p.status in ("finished", "error"):
                # Book-keeping on main loop
                def _done():
                    try:
                        if p.status == "finished":
                            try:
                                add_download(video, dest_dir, p.filename)
                            except Exception:
                                pass
                    finally:
                        self._active = max(0, self._active - 1)
                        self._maybe_start_next()
                    return False
                GLib.idle_add(_done)

        if advanced:
            cli = opts.raw_cli_list()
            # Inject global proxy if configured and not set explicitly
            proxy = self.get_setting("http_proxy")
            if isinstance(proxy, str) and proxy.strip() and "--proxy" not in cli:
                cli = ["--proxy", proxy.strip()] + cli
            # Optional custom yt-dlp binary path from settings
            ytdlp_path = self.get_setting("ytdlp_path")
            if not isinstance(ytdlp_path, str) or not ytdlp_path.strip():
                ytdlp_path = None
-            task = RunnerDownloadTask(video, dest_dir, cli, bin_path=ytdlp_path)
+            task = RunnerDownloadTask(video, dest_dir, cli, bin_path=ytdlp_path)
            row.attach_task(task)
+            # Update cancel binding to running task
+            row._on_cancel = lambda: self._cancel_row(row)  # type: ignore[attr-defined]
            task.start(_on_update)
            return

        ydl_override = opts.to_ydl_opts()
        proxy = self.get_setting("http_proxy")
        if isinstance(proxy, str) and proxy.strip():
            ydl_override["proxy"] = proxy.strip()

        dl_task = DownloadTask(video=video, dest_dir=dest_dir, ydl_opts_override=ydl_override)
        row.attach_task(dl_task)
+        row._on_cancel = lambda: self._cancel_row(row)  # type: ignore[attr-defined]
        dl_task.start(_on_update)
        return