=======================================================================
WhirlTube Important Code Snapshot
Generated: Thu Oct  2 04:27:54 PM +0330 2025
Git branch: master
Git commit: 60e2831a5eb81e7f607c34daf295cba17158a8ad
Git status: DIRTY
=======================================================================


--- FILE: ./src/whirltube/app.py ---
from __future__ import annotations

import logging
import os
import sys
from pathlib import Path

APP_ID = "org.whirltube.WhirlTube"
log = logging.getLogger(__name__)


def main(argv: list[str] | None = None) -> int:
    # Set locale for libmpv requirements (client.h)
    try:
        import locale
        locale.setlocale(locale.LC_NUMERIC, "C")
    except Exception:
        pass
    
    from .logging_config import setup_logging
    setup_logging(debug=bool(os.environ.get("WHIRLTUBE_DEBUG")))
    # Lazy import GTK libs so importing this module doesn't require GI
    import gi
    gi.require_version("Gtk", "4.0")
    gi.require_version("Adw", "1")
    gi.require_version("Gdk", "4.0")
    from gi.repository import Adw, Gdk, Gio, Gtk

    def _register_icon_theme_path() -> None:
        # Add bundled icons to the icon theme so "whirltube" resolves even from wheels.
        try:
            base = Path(__file__).resolve().parent  # src/whirltube
            icon_root = base / "assets" / "icons" / "hicolor"
            if icon_root.exists():
                display = Gdk.Display.get_default()
                if display is not None:
                    theme = Gtk.IconTheme.get_for_display(display)
                    theme.add_search_path(str(icon_root))
                    log.debug("Registered icon theme path: %s", icon_root)
        except Exception as e:
            log.debug("Icon theme path registration skipped: %s", e)

    class App(Adw.Application):
        def __init__(self) -> None:
            super().__init__(application_id=APP_ID, flags=Gio.ApplicationFlags.FLAGS_NONE)
            self._create_actions()

        def do_activate(self) -> None:  # type: ignore[override]
            _register_icon_theme_path()
            win = self.props.active_window
            if not win:
                # Import the heavy window module only when activating
                from .window import MainWindow
                win = MainWindow(app=self)
            win.present()

        def _create_actions(self) -> None:
            action_quit = Gio.SimpleAction.new("quit", None)
            action_quit.connect("activate", self._on_quit)
            self.add_action(action_quit)
            self.set_accels_for_action("app.quit", ["<Primary>q"])

        def _on_quit(self, *args) -> None:
            self.quit()

    Adw.init()
    app = App()
    return app.run(argv or sys.argv)


if __name__ == "__main__":
    raise SystemExit(main())


--- FILE: ./src/whirltube/player.py ---
from __future__ import annotations

import json
import os
import shlex
import shutil
import socket
import subprocess
from collections.abc import Sequence

_OPTION_CACHE: dict[str, bool] = {}

def mpv_supports_option(opt: str) -> bool:
    # Detect supported options once via --list-options (mpv â‰¥ 0.30)
    if opt in _OPTION_CACHE:
        return _OPTION_CACHE[opt]
    ok = False
    try:
        res = subprocess.run(
            ["mpv", "--no-config", "--list-options"],
            capture_output=True, text=True, timeout=2,
        )
        if res.returncode == 0:
            names = set()
            for line in res.stdout.splitlines():
                if not line:
                    continue
                head = line.split()[0]
                names.add(head.split("=")[0])
            opts = names
            ok = opt in opts
        else:
            ok = False
    except Exception:
        ok = False
    _OPTION_CACHE[opt] = ok
    return ok


def has_mpv() -> bool:
    return shutil.which("mpv") is not None


def start_mpv(
    url: str,
    extra_args: str | Sequence[str] | None = None,
    ipc_server_path: str | None = None,
    extra_env: dict[str, str] | None = None,
    log_file_path: str | None = None,
) -> subprocess.Popen:
    """
    Launch MPV externally to play a URL. Optionally create a JSON IPC server at ipc_server_path.
    Returns the Popen handle.
    """
    if not has_mpv():
        raise RuntimeError("MPV is not installed or not found in PATH.")
    args = ["mpv", "--force-window=yes"]
    if ipc_server_path:
        args += [f"--input-ipc-server={ipc_server_path}"]
    if log_file_path:
        args += ["--msg-level=all=v", f"--log-file={log_file_path}"]
    if isinstance(extra_args, str) and extra_args.strip():
        args.extend(shlex.split(extra_args))
    elif isinstance(extra_args, (list, tuple)):
        args.extend(extra_args)
    args.append(url)

    env = os.environ.copy()
    if extra_env:
        env.update(extra_env)

    return subprocess.Popen(args, env=env)


def play_in_mpv(url: str, extra_args: str | Sequence[str] | None = None) -> subprocess.Popen:
    """
    Backward-compatible helper without IPC. Prefer start_mpv() in new code.
    """
    return start_mpv(url, extra_args=extra_args, ipc_server_path=None)


def mpv_send_cmd(ipc_path: str, command: list) -> dict | None:
    """
    Send a JSON IPC command to MPV and return the parsed response, or None on failure.

    Example command lists:
      ["cycle", "pause"]
      ["seek", 10, "relative"]
      ["set_property", "speed", 1.25]
      ["quit"]
    """
    try:
        with socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) as s:
            s.settimeout(1.0)
            s.connect(ipc_path)
            payload = json.dumps({"command": command}) + "\n"
            s.sendall(payload.encode("utf-8", "ignore"))
            # Attempt to read a reply line (best effort)
            try:
                data = s.recv(4096)
                if data:
                    return json.loads(data.decode("utf-8", "ignore"))
            except Exception:
                return None
    except Exception:
        return None
    return None


--- FILE: ./src/whirltube/downloader.py ---
from __future__ import annotations

import subprocess
import threading
from threading import Event
from collections.abc import Callable
from dataclasses import dataclass, field
from pathlib import Path

from yt_dlp import YoutubeDL
from .ytdlp_runner import PROGRESS_TPL, parse_line, YtDlpRunner

from .models import Video


@dataclass(slots=True)
class DownloadProgress:
    bytes_total: int | None = None
    bytes_downloaded: int = 0
    speed_bps: float | None = None
    eta: int | None = None
    status: str = "queued"  # queued|downloading|finished|error
    filename: str | None = None
    error: str | None = None


@dataclass(slots=True)
class DownloadTask:
    video: Video
    dest_dir: Path
    progress: DownloadProgress = field(default_factory=DownloadProgress)
    _thread: threading.Thread | None = field(default=None, init=False)
    ydl_opts_override: dict | None = None  # allow per-download overrides
    _cancel: Event = field(default_factory=Event, init=False)
    _outtmpl_template: str | None = None

    def start(self, on_update: Callable[[DownloadProgress], None]) -> None:
        """Start the download in a background thread using yt-dlp Python API."""
        if self._thread and self._thread.is_alive():
            return

        def hook(d: dict) -> None:
            st = d.get("status")
            # Cancellation path: raising in hook aborts the download in yt-dlp
            if self._cancel.is_set():
                raise KeyboardInterrupt("Cancelled")
            if st == "downloading":
                self.progress.status = "downloading"
                self.progress.bytes_downloaded = int(d.get("downloaded_bytes") or 0)
                tb = d.get("total_bytes") or d.get("total_bytes_estimate") or 0
                self.progress.bytes_total = int(tb) or None
                sp = d.get("speed")
                self.progress.speed_bps = float(sp) if sp is not None else None
                et = d.get("eta")
                self.progress.eta = int(et) if et is not None else None
                on_update(self.progress)
            elif st == "finished":
                self.progress.status = "finished"
                self.progress.filename = d.get("filename")
                on_update(self.progress)

        def run() -> None:
            self.progress.status = "downloading"
            on_update(self.progress)
            template = self._outtmpl_template or "%(title)s.%(ext)s"
            outtmpl = str(self.dest_dir / template)
            ydl_opts = {
                "quiet": True,
                "outtmpl": outtmpl,
                "progress_hooks": [hook],
                "merge_output_format": "mp4",
                "format": "bv*+ba/b",
                "nocheckcertificate": True,
                "retries": 3,
                "fragment_retries": 2,
            }
            if self.ydl_opts_override:
                ydl_opts.update(self.ydl_opts_override)
            try:
                self.dest_dir.mkdir(parents=True, exist_ok=True)
                with YoutubeDL(ydl_opts) as ydl:
                    ydl.download([self.video.url])
            except Exception as e:
                self.progress.status = "error"
                self.progress.error = str(e)
                on_update(self.progress)

        self._thread = threading.Thread(target=run, daemon=True)
        self._thread.start()

    def stop(self) -> None:
        """
        Best-effort cancellation. For Python API we signal via hook and let yt-dlp abort soon.
        """
        try:
            self._cancel.set()
        except Exception:
            pass
        # Thread will exit after yt-dlp aborts; no force-termination here

    def set_outtmpl_template(self, tmpl: str | None) -> None:
        try:
            self._outtmpl_template = (tmpl or "").strip() or None
        except Exception:
            self._outtmpl_template = None


class SubprocessDownloadTask:
    """
    Legacy path: run yt-dlp as a subprocess. Kept for compatibility, not used by UI.
    Now emits structured JSON lines parsed by parse_line.
    """

    def __init__(self, video: Video, dest_dir: Path, cli_args: list[str]) -> None:
        self.video = video
        self.dest_dir = dest_dir
        self.cli_args = cli_args
        self.progress = DownloadProgress(status="queued")
        self._thread: threading.Thread | None = None

    def start(self, on_update: Callable[[DownloadProgress], None]) -> None:
        if self._thread and self._thread.is_alive():
            return

        def run() -> None:
            self.progress.status = "downloading"
            on_update(self.progress)
            self.dest_dir.mkdir(parents=True, exist_ok=True)
            outtmpl = str(self.dest_dir / "%(title)s.%(ext)s")
            # Use progress-template to emit structured JSON prefixed lines (parsed by parse_line)
            args = ["yt-dlp", "-o", outtmpl] + self.cli_args + PROGRESS_TPL + ["--no-quiet", self.video.url]
            try:
                with subprocess.Popen(
                    args,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    text=True,
                    bufsize=1,
                ) as proc:
                    for line in proc.stdout or []:
                        events = parse_line(line)
                        if isinstance(events, Exception):
                            self.progress.status = "error"
                            self.progress.error = str(events)
                            on_update(self.progress)
                            continue
                        if not events:
                            continue
                        for ev in events:
                            if ev.kind == "downloading":
                                payload = ev.payload
                                self.progress.status = "downloading"
                                self.progress.bytes_downloaded = int(float(payload.get("downloaded_bytes") or 0.0))
                                tb = payload.get("total_bytes") or payload.get("total_bytes_estimate") or 0
                                self.progress.bytes_total = int(tb) or None
                                sp = payload.get("speed")
                                self.progress.speed_bps = float(sp) if sp not in (None, "NA") else None
                                et = payload.get("eta")
                                self.progress.eta = int(float(et)) if et not in (None, "NA") else None
                                on_update(self.progress)
                            elif ev.kind in ("end_of_video", "end_of_playlist"):
                                pass
                    proc.wait()
                    if self.progress.status != "error":
                        self.progress.status = "finished"
                        on_update(self.progress)
            except Exception as e:
                self.progress.status = "error"
                self.progress.error = str(e)
                on_update(self.progress)

        self._thread = threading.Thread(target=run, daemon=True)
        self._thread.start()

    def _parse_progress(self, line: str, on_update: Callable[[DownloadProgress], None]) -> None:
        # Unused pather, left for compatibility
        on_update(self.progress)


class RunnerDownloadTask:
    """
    Advanced download using YtDlpRunner (shared JSON progress template).
    Unifies progress handling with Quick Download.
    """
    def __init__(self, video: Video, dest_dir: Path, cli_args: list[str], bin_path: str | None = None, outtmpl_template: str | None = None) -> None:
        self.video = video
        self.dest_dir = dest_dir
        self.cli_args = cli_args
        self.progress = DownloadProgress(status="queued")
        self._outtmpl_template = (outtmpl_template or "").strip() or None
        self._runner = YtDlpRunner(self._on_progress_line)
        self._watcher: threading.Thread | None = None
        self._bin_path = bin_path
        self._on_update: Callable[[DownloadProgress], None] | None = None

    def start(self, on_update: Callable[[DownloadProgress], None]) -> None:
        if self._watcher and self._watcher.is_alive():
            return
        self._on_update = on_update
        self.progress.status = "downloading"
        on_update(self.progress)
        try:
            self.dest_dir.mkdir(parents=True, exist_ok=True)
        except Exception as e:
            self.progress.status = "error"
            self.progress.error = str(e)
            on_update(self.progress)
            return

        template = self._outtmpl_template or "%(title)s.%(ext)s"
        outtmpl = str(self.dest_dir / template)
        args = ["-o", outtmpl] + self.cli_args + [self.video.url]
        self._runner.start(args, bin_path=self._bin_path)

        def watch() -> None:
            # Poll until process exits, then mark finished if no error
            while self._runner.is_running():
                threading.Event().wait(0.2)
            if self.progress.status != "error":
                self.progress.status = "finished"
                if self._on_update:
                    self._on_update(self.progress)

        self._watcher = threading.Thread(target=watch, daemon=True)
        self._watcher.start()

    def _on_progress_line(self, text: str) -> None:
        evs = parse_line(text)
        if isinstance(evs, Exception):
            self.progress.status = "error"
            self.progress.error = str(evs)
            if self._on_update:
                self._on_update(self.progress)
            return
        if not evs:
            return
        for ev in evs:
            if ev.kind == "downloading":
                payload = ev.payload
                self.progress.status = "downloading"
                try:
                    self.progress.bytes_downloaded = int(float(payload.get("downloaded_bytes") or 0.0))
                except Exception:
                    self.progress.bytes_downloaded = 0
                tb = payload.get("total_bytes") or payload.get("total_bytes_estimate") or 0
                try:
                    self.progress.bytes_total = int(float(tb)) or None
                except Exception:
                    self.progress.bytes_total = None
                sp = payload.get("speed")
                et = payload.get("eta")
                self.progress.speed_bps = float(sp) if sp not in (None, "NA") else None
                self.progress.eta = int(float(et)) if et not in (None, "NA") else None
                if self._on_update:
                    self._on_update(self.progress)
            elif ev.kind in ("end_of_video", "end_of_playlist"):
                # watch() will set finished upon process exit
                pass

    def stop(self) -> None:
        try:
            self._runner.stop()
        except Exception:
            pass

--- FILE: ./src/whirltube/download_manager.py ---
from __future__ import annotations

import logging
import os
import threading
import time
from pathlib import Path
from typing import Any, Callable
from copy import deepcopy
from functools import partial
from dataclasses import asdict
import json

import gi
gi.require_version("Gtk", "4.0")
gi.require_version("Gdk", "4.0")
gi.require_version("Adw", "1")
from gi.repository import GLib, Gdk, Gio, Gtk

from .downloader import DownloadProgress, DownloadTask, RunnerDownloadTask
from .models import Video
from .dialogs import DownloadOptions
from .download_history import add_download
from .util import xdg_data_dir, _download_archive_path

log = logging.getLogger(__name__)

_QUEUE_FILE = xdg_data_dir() / "download_queue.json"
MAX_CONCURRENT_DEFAULT = 3

def _notify(summary: str) -> None:
    # Best-effort desktop notification without requiring GI at import time.
    try:
        import gi
        gi.require_version("Notify", "0.7")
        from gi.repository import Notify
        Notify.init("whirltube")
        n = Notify.Notification.new(summary)
        n.show()
    except Exception:
        pass

class DownloadRow(Gtk.Box):
    def __init__(self, task: Any | None = None, title: str | None = None, on_cancel: Callable[[], None] | None = None, on_retry: Callable[[], None] | None = None, on_remove: Callable[[], None] | None = None) -> None:
        super().__init__(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        self.task = task
        self._base_title = title or getattr(getattr(task, "video", None), "title", "Download")
        self._on_cancel = on_cancel
        self._on_retry = on_retry
        self._on_remove = on_remove
        # Metadata for retry
        self._video: Video | None = None
        self._opts: DownloadOptions | None = None
        self._dest_dir: Path | None = None
        self._state: str = "queued" if task is None else "downloading"

        self.set_margin_top(6)
        self.set_margin_bottom(6)

        start_label = "Downloading" if task else "Queued"
        self.label = Gtk.Label(label=f"{start_label}: {self._base_title}", xalign=0.0, wrap=True)
        self.progress = Gtk.ProgressBar(show_text=True)
        self.status = Gtk.Label(label="", xalign=0.0)

        # Actions popover menu
        self.actions = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        self.menu_btn = Gtk.MenuButton(label="Actions")
        pop = Gtk.Popover()
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6, margin_top=6, margin_bottom=6, margin_start=6, margin_end=6)
        self._btn_m_cancel = Gtk.Button(label="Cancel")
        self._btn_m_cancel.connect("clicked", lambda *_: self._on_cancel_clicked())
        self._btn_m_retry = Gtk.Button(label="Retry")
        self._btn_m_retry.set_sensitive(False)
        self._btn_m_retry.connect("clicked", lambda *_: self._on_retry_clicked())
        self._btn_m_remove = Gtk.Button(label="Remove")
        self._btn_m_remove.set_sensitive(False)
        self._btn_m_remove.connect("clicked", lambda *_: self._on_remove_clicked())
        self._btn_m_open_folder = Gtk.Button(label="Open folder")
        self._btn_m_open_folder.connect("clicked", self._open_folder)
        self._btn_m_show_containing = Gtk.Button(label="Show in folder")
        self._btn_m_show_containing.connect("clicked", self._show_in_folder)
        self._btn_m_copy_path = Gtk.Button(label="Copy file path")
        self._btn_m_copy_path.connect("clicked", self._copy_path)
        self._btn_m_open_file = Gtk.Button(label="Open file")
        self._btn_m_open_file.connect("clicked", self._open_file)
        for b in (self._btn_m_cancel, self._btn_m_retry, self._btn_m_remove, self._btn_m_open_folder, self._btn_m_show_containing, self._btn_m_copy_path, self._btn_m_open_file):
            vbox.append(b)
        pop.set_child(vbox)
        self.menu_btn.set_popover(pop)
        self.actions.append(self.menu_btn)

        self.append(self.label)
        self.append(self.progress)
        self.append(self.status)
        self.append(self.actions)

    def _on_cancel_clicked(self) -> None:
        try:
            if self._on_cancel:
                self._on_cancel()
        finally:
            # Disable cancel to avoid repeated presses
            self._btn_m_cancel.set_sensitive(False)

    def _on_retry_clicked(self) -> None:
        try:
            if self._on_retry:
                self._on_retry()
        except Exception:
            pass

    def _on_remove_clicked(self) -> None:
        try:
            if self._on_remove:
                self._on_remove()
        except Exception:
            pass

    def set_queued(self) -> None:
        try:
            self.label.set_text(f"Queued: {self._base_title}")
            self.progress.set_fraction(0.0)
            self.progress.set_text("")
            self.status.set_text("")
            self._state = "queued"
        except Exception:
            pass

    def set_metadata(self, video: Video, opts: DownloadOptions, dest_dir: Path) -> None:
        # Deepcopy opts to decouple from future UI edits
        try:
            self._video = video
            self._opts = deepcopy(opts)
            self._dest_dir = dest_dir
        except Exception:
            self._video, self._opts, self._dest_dir = video, opts, dest_dir

    def attach_task(self, task: Any) -> None:
        self.task = task
        self.label.set_text(f"Downloading: {self._base_title}")
        self._state = "downloading"
        # While running, ensure retry/remove disabled
        try:
            self._btn_m_retry.set_sensitive(False)
            self._btn_m_remove.set_sensitive(False)
        except Exception:
            pass

    def update_progress(self, p: DownloadProgress) -> None:
        # Switch label when we get the first real progress
        if p.status == "downloading":
            try:
                self.label.set_text(f"Downloading: {self._base_title}")
            except Exception:
                pass
            self._state = "downloading"
        frac = 0.0
        if p.bytes_total and p.bytes_total > 0:
            frac = min(1.0, max(0.0, p.bytes_downloaded / p.bytes_total))
        self.progress.set_fraction(frac)
        self.progress.set_text(_fmt_dl_text(p))
        self.status.set_text(_fmt_dl_status(p))

        if p.status == "finished":
            # Adjust menu item sensitivity
            self._btn_m_cancel.set_sensitive(False)
            self._btn_m_retry.set_sensitive(False)
            self._btn_m_remove.set_sensitive(True)
            self._btn_m_open_folder.set_sensitive(True)
            self._btn_m_open_file.set_sensitive(True)
            self._btn_m_show_containing.set_sensitive(True)
            self._btn_m_copy_path.set_sensitive(True)
            self._state = "finished"
        elif p.status == "error":
            # Disable cancel after error
            self._btn_m_cancel.set_sensitive(False)
            self._btn_m_retry.set_sensitive(True)
            self._btn_m_remove.set_sensitive(True)
            self._btn_m_open_folder.set_sensitive(True)
            self._btn_m_show_containing.set_sensitive(True)
            # Copy path and open file may still not be resolvable; keep conservative
            self._btn_m_copy_path.set_sensitive(False)
            self._state = "error"

    def _open_folder(self, *_a) -> None:
        try:
            dest = getattr(self.task, "dest_dir", None)
            if isinstance(dest, Path) and dest.exists():
                Gio.AppInfo.launch_default_for_uri(f"file://{dest}", None)
        except Exception:
            pass

    def _open_file(self, *_a) -> None:
        try:
            p: DownloadProgress = getattr(self.task, "progress", None)
            dest: Path = getattr(self.task, "dest_dir", None)
            if p and p.filename:
                fp = Path(p.filename)
                # If filename isn't absolute, resolve against dest_dir
                if not fp.is_absolute() and isinstance(dest, Path):
                    fp = dest / fp
                if fp.exists():
                    Gio.AppInfo.launch_default_for_uri(f"file://{fp}", None)
        except Exception:
            pass

    def mark_cancelled(self) -> None:
        try:
            self.label.set_text(f"Cancelled: {self._base_title}")
            self.status.set_text("Cancelled")
            self.progress.set_fraction(0.0)
            self.progress.set_text("")
            self._btn_m_cancel.set_sensitive(False)
            self._btn_m_retry.set_sensitive(True)
            self._btn_m_remove.set_sensitive(True)
            self._btn_m_open_folder.set_sensitive(True)
            self._btn_m_show_containing.set_sensitive(True)
            self._btn_m_copy_path.set_sensitive(False)
            self._state = "cancelled"
        except Exception:
            pass

    def _show_in_folder(self, *_a) -> None:
        try:
            p: DownloadProgress = getattr(self.task, "progress", None)
            if p and p.filename:
                fp = Path(p.filename)
                # If not absolute, try resolve against dest_dir
                dest: Path = getattr(self.task, "dest_dir", None)
                if not fp.is_absolute() and isinstance(dest, Path):
                    fp = dest / fp
                parent = fp.parent
                if parent.exists():
                    Gio.AppInfo.launch_default_for_uri(f"file://{parent}", None)
        except Exception:
            pass

    def _copy_path(self, *_a) -> None:
        """
        Copy download path to clipboard with Wayland-safe async handling.
        Keeps a reference to the ContentProvider to avoid GC before paste.
        """
        try:
            p: DownloadProgress = getattr(self.task, "progress", None)
            dest: Path = getattr(self.task, "dest_dir", None)
            if p and p.filename:
                fp = Path(p.filename)
                if not fp.is_absolute() and isinstance(dest, Path):
                    fp = dest / fp
                
                disp = Gdk.Display.get_default()
                if not disp:
                    return
                clipboard = disp.get_clipboard()
                
                # Create a ContentProvider for text
                # Store it as an instance variable so it doesn't get GC'd (Wayland needs this)
                self._clipboard_provider = Gdk.ContentProvider.new_for_value(str(fp))
                clipboard.set_content(self._clipboard_provider)
                return
        except Exception:
            pass
        # Fallback: copy dest_dir
        try:
            disp = Gdk.Display.get_default()
            if not disp:
                return
            clipboard = disp.get_clipboard()
            
            dest: Path = getattr(self.task, "dest_dir", None)
            if isinstance(dest, Path):
                # Store provider to avoid GC on Wayland
                self._clipboard_provider = Gdk.ContentProvider.new_for_value(str(dest))
                clipboard.set_content(self._clipboard_provider)
        except Exception:
            pass

    def state(self) -> str:
        return self._state

def _fmt_dl_text(p: DownloadProgress) -> str:
    if p.status == "finished":
        return "100% (done)"
    if p.bytes_total:
        pct = int((p.bytes_downloaded / p.bytes_total) * 100)
        return f"{pct}%"
    if p.bytes_downloaded:
        kb = p.bytes_downloaded / 1024
        return f"{kb:.1f} KiB"
    return ""

def _fmt_dl_status(p: DownloadProgress) -> str:
    if p.status == "finished":
        return f"Saved: {p.filename or ''}"
    if p.status == "error":
        return f"Error: {p.error or 'unknown'}"
    parts = []
    if p.speed_bps:
        mbps = p.speed_bps / (1024 * 1024)
        parts.append(f"{mbps:.2f} MiB/s")
    if p.eta:
        parts.append(f"ETA {p.eta:d}s")
    return " â€¢ ".join(parts)


class DownloadManager:
    def __init__(self, downloads_box: Gtk.Box, show_downloads_view: Callable[[], None], get_setting: Callable[[str], str|bool|int|None], show_error: Callable[[str], None], show_toast: Callable[[str], None] | None = None) -> None:
        self.downloads_box = downloads_box
        self.show_downloads_view = show_downloads_view
        self.get_setting = get_setting
        self.show_error = show_error
        self.show_toast = show_toast or (lambda _s: None)
        self.download_dir: Path | None = None # This will be set by MainWindow
        self._max_concurrent: int = MAX_CONCURRENT_DEFAULT
        self._active: int = 0
        # queue of (video, opts, dest_dir, row)
        self._queue: list[tuple[Video, DownloadOptions, Path, DownloadRow]] = []
        self._rows: list[DownloadRow] = []
        # persistent queue path
        self._queue_path: Path = _QUEUE_FILE

    def set_download_dir(self, path: Path) -> None:
        self.download_dir = path

    def set_max_concurrent(self, n: int) -> None:
        try:
            self._max_concurrent = max(1, int(n))
        except Exception:
            self._max_concurrent = 1
        self._maybe_start_next()

    def _ensure_download_dir(self, path: Path) -> bool:
        try:
            path.mkdir(parents=True, exist_ok=True)
            return True
        except Exception as e:
            self.show_error(f"Could not create download directory: {e}")
            return False

    def start_download(self, video: Video, opts: DownloadOptions) -> None:
        dest_dir = opts.target_dir or Path(self.get_setting("download_dir") or str(self.download_dir))
        if not self._ensure_download_dir(dest_dir):
            return
        # Create a queued row immediately
        row = DownloadRow(None, title=video.title, on_cancel=partial(self._cancel_row, None), on_retry=partial(self._retry_row, None), on_remove=partial(self._remove_row, None))
        # Store a weak binding to this specific row into the callback
        row._on_cancel = partial(self._cancel_row, row)  # type: ignore[attr-defined]
        row._on_retry = partial(self._retry_row, row)  # type: ignore[attr-defined]
        row._on_remove = partial(self._remove_row, row)  # type: ignore[attr-defined]
        row.set_queued()
        row.set_metadata(video, opts, dest_dir)
        self.downloads_box.append(row)
        self._rows.append(row)
        self.show_downloads_view()
        # Enqueue and attempt to start
        self._queue.append((video, opts, dest_dir, row))
        self._persist_queue()
        self._maybe_start_next()

    def _maybe_start_next(self) -> None:
        # Start as many as allowed
        while self._active < self._max_concurrent and self._queue:
            video, opts, dest_dir, row = self._queue.pop(0)
            # Persist immediately after queue modification, before task start
            self._persist_queue()
            try:
                self._start_task(video, opts, dest_dir, row)
            except Exception as e:
                # If task fails to start, decrement active count
                self._active = max(0, self._active - 1)
                # Mark row as error
                try:
                    row.update_progress(DownloadProgress(status="error", error=f"Failed to start: {e}"))
                except Exception:
                    pass

    def _cancel_row(self, row: DownloadRow | None) -> None:
        # If None passed (shouldn't happen), ignore
        if row is None:
            return
        # If queued: remove from queue
        removed = False
        for i, (_v, _o, _d, r) in enumerate(list(self._queue)):
            if r is row:
                try:
                    self._queue.pop(i)
                    removed = True
                except Exception:
                    pass
                # Persist after successful removal
                if removed:
                    self._persist_queue()
                row.mark_cancelled()
                return
        # If running: try to stop the task
        task = getattr(row, "task", None)
        if task is None:
            row.mark_cancelled()
            return
        try:
            stop = getattr(task, "stop", None)
            if callable(stop):
                stop()
        except Exception:
            pass
        row.mark_cancelled()

    def _retry_row(self, row: DownloadRow | None) -> None:
        if row is None:
            return
        # If running or queued, ignore
        if row.state() in ("downloading", "queued"):
            return
        v, o, d = row._video, row._opts, row._dest_dir  # type: ignore[attr-defined]
        if not v or not o or not d:
            return
        # Re-enqueue fresh
        row.set_queued()
        self._queue.append((v, o, d, row))
        self._maybe_start_next()

    def _remove_row(self, row: DownloadRow | None) -> None:
        if row is None:
            return
        # If queued, remove from queue first
        for i, (_v, _o, _d, r) in enumerate(list(self._queue)):
            if r is row:
                try:
                    self._queue.pop(i)
                except Exception:
                    pass
                break
        # If running, attempt cancel
        if row.state() == "downloading":
            self._cancel_row(row)
        # Remove from UI and internal list
        try:
            self.downloads_box.remove(row)
        except Exception:
            pass
        try:
            self._rows.remove(row)
        except Exception:
            pass

    def cancel_all(self) -> None:
        # Cancel running and drop queued
        for video, opts, dest_dir, row in list(self._queue):
            try:
                row.mark_cancelled()
            except Exception:
                pass
        self._queue.clear()
        # Running: cancel
        for row in list(self._rows):
            if row.state() == "downloading":
                self._cancel_row(row)

    @staticmethod
    def _open_folder(path: Path) -> None:
        try:
            if isinstance(path, Path) and path.exists():
                Gio.AppInfo.launch_default_for_uri(f"file://{path}", None)
        except Exception:
            pass

    def clear_finished(self) -> None:
        # Remove rows that are done (finished, cancelled, error)
        for row in list(self._rows):
            if row.state() in ("finished", "cancelled", "error"):
                try:
                    self.downloads_box.remove(row)
                except Exception:
                    pass
                try:
                    self._rows.remove(row)
                except Exception:
                    pass

    def _validate_template(self, template: str) -> str:
        """Validate and sanitize output template"""
        if not template or not template.strip():
            return "%(title)s.%(ext)s"
        
        template = template.strip()
        
        # Check for path traversal attempts
        if ".." in template:
            log.warning(f"Template contains '..', using default: {template}")
            return "%(title)s.%(ext)s"
        
        # Check for absolute paths (Unix / and Windows C:\ style)
        if template.startswith("/") or (len(template) > 1 and template[1:3] == ":\\"):
            log.warning(f"Template contains absolute path, using default: {template}")
            return "%(title)s.%(ext)s"
        
        # Basic check: should contain %(ext)s for proper extension
        if "%(ext)s" not in template:
            log.warning(f"Template missing %(ext)s, appending it: {template}")
            template = f"{template}.%(ext)s"
        
        return template

    def _start_task(self, video: Video, opts: DownloadOptions, dest_dir: Path, row: DownloadRow) -> None:
        self._active += 1
        advanced = (
            bool(opts.extra_flags.strip())
            or bool(opts.sort_string.strip())
            or bool(opts.sb_mark.strip())
            or bool(opts.sb_remove.strip())
            or opts.embed_metadata
            or opts.embed_thumbnail
            or opts.write_thumbnail
            or bool(opts.limit_rate.strip())
            or (opts.concurrent_fragments > 0)
            or bool(opts.impersonate.strip())
            or (opts.use_cookies and bool(opts.cookies_browser.strip()))
        )

        def _on_update(p: DownloadProgress) -> None:
            GLib.idle_add(row.update_progress, p)
            if p.status in ("finished", "error"):
                # Book-keeping on main loop
                def _done():
                    try:
                        if p.status == "finished":
                            try:
                                add_download(video, dest_dir, p.filename)
                            except Exception:
                                pass
                            self.show_toast(f"Downloaded: {video.title}")
                            _notify(f"Downloaded: {video.title}")
                            # Auto-open download folder if enabled
                            try:
                                if bool(self.get_setting("download_auto_open_folder")):
                                    self._open_folder(dest_dir)
                            except Exception:
                                pass
                        elif p.status == "error":
                            self.show_toast(f"Download failed: {video.title}")
                            _notify(f"Download failed: {video.title}")
                    finally:
                        self._active = max(0, self._active - 1)
                        self._maybe_start_next()
                    return False
                GLib.idle_add(_done)

        if advanced:
            cli = opts.raw_cli_list()
            # Add collision handling: let yt-dlp auto-rename if file exists
            cli.append("--no-overwrites")
            
            # Add archive to prevent re-downloads
            archive_path = _download_archive_path()
            cli.extend(["--download-archive", str(archive_path)])
            
            # Inject global proxy if configured and not set explicitly
            proxy = self.get_setting("http_proxy")
            if isinstance(proxy, str) and proxy.strip() and "--proxy" not in cli:
                cli = ["--proxy", proxy.strip()] + cli
            # Optional custom yt-dlp binary path from settings
            ytdlp_path = self.get_setting("ytdlp_path")
            if not isinstance(ytdlp_path, str) or not ytdlp_path.strip():
                ytdlp_path = None
            template = self._validate_template(str(self.get_setting("download_template") or "%(title)s.%(ext)s"))
            task = RunnerDownloadTask(video, dest_dir, cli, bin_path=ytdlp_path, outtmpl_template=template)
            row.attach_task(task)
            # Update cancel binding to running task
            row._on_cancel = lambda: self._cancel_row(row)  # type: ignore[attr-defined]
            task.start(_on_update)
            return

        ydl_override = opts.to_ydl_opts()
        proxy = self.get_setting("http_proxy")
        if isinstance(proxy, str) and proxy.strip():
            ydl_override["proxy"] = proxy.strip()

        # Add archive support
        archive_path = _download_archive_path()
        ydl_override["download_archive"] = str(archive_path)
        
        template = self._validate_template(str(self.get_setting("download_template") or "%(title)s.%(ext)s"))
        dl_task = DownloadTask(video=video, dest_dir=dest_dir, ydl_opts_override=ydl_override)
        dl_task.set_outtmpl_template(template)
        row.attach_task(dl_task)
        row._on_cancel = lambda: self._cancel_row(row)  # type: ignore[attr-defined]
        dl_task.start(_on_update)
        return

    def persist_queue(self) -> None:
        """Public: persist current queued items to disk."""
        self._persist_queue()

    def _persist_queue(self) -> None:
        """Write only queued items (not running) to a JSON file."""
        try:
            items = []
            for v, o, d, r in self._queue:
                # Serialize dataclasses; avoid Path in opts to keep JSON simple
                vd = asdict(v)
                od = asdict(o)
                od.pop("target_dir", None)
                items.append(
                    {
                        "video": vd,
                        "opts": od,
                        "dest_dir": str(d),
                        "title": v.title,
                    }
                )
            self._queue_path.parent.mkdir(parents=True, exist_ok=True)
            tmp = self._queue_path.with_suffix(".tmp")
            tmp.write_text(json.dumps(items, ensure_ascii=False, indent=2), encoding="utf-8")
            tmp.replace(self._queue_path)
        except Exception:
            pass

    def restore_queued(self) -> None:
        """Restore queued items from disk and enqueue them."""
        p = self._queue_path
        if not p.exists():
            return
        try:
            data = json.loads(p.read_text(encoding="utf-8"))
            if not isinstance(data, list):
                return
        except Exception:
            return
        for it in data:
            try:
                if not isinstance(it, dict):
                    continue
                vraw = it.get("video") or {}
                oraw = it.get("opts") or {}
                dstr = it.get("dest_dir") or ""
                if not isinstance(vraw, dict) or not isinstance(oraw, dict) or not isinstance(dstr, str):
                    continue
                video = Video(
                    id=str(vraw.get("id") or ""),
                    title=vraw.get("title") or "",
                    url=vraw.get("url") or "",
                    channel=vraw.get("channel"),
                    duration=vraw.get("duration"),
                    thumb_url=vraw.get("thumb_url"),
                    kind=vraw.get("kind") or "video",
                )
                opts = DownloadOptions(**oraw)
                dest_dir = Path(dstr)
                # Create row in UI as queued and put into _queue
                row = DownloadRow(None, title=video.title, on_cancel=partial(self._cancel_row, None), on_retry=partial(self._retry_row, None), on_remove=partial(self._remove_row, None))
                row._on_cancel = partial(self._cancel_row, row)  # type: ignore[attr-defined]
                row._on_retry = partial(self._retry_row, row)  # type: ignore[attr-defined]
                row._on_remove = partial(self._remove_row, row)  # type: ignore[attr-defined]
                row.set_metadata(video, opts, dest_dir)
                row.set_queued()
                self.downloads_box.append(row)
                self._rows.append(row)
                self._queue.append((video, opts, dest_dir, row))
            except Exception:
                continue
        # Kick off any that fit concurrency
        self._maybe_start_next()

--- FILE: ./src/whirltube/ytdlp_runner.py ---
from __future__ import annotations

import json
import subprocess
import threading
from collections.abc import Callable
from dataclasses import dataclass
from queue import Empty, Queue

PREFIX = "WTJSON:"  # marker for JSON lines we emit

PRINT_HOOKS = [
    "--print",
    f'{PREFIX}{{"type": "pre_download"}}',
    "--print",
    f'{PREFIX}{{"type": "end_of_playlist"}}',
    "--print",
    f'{PREFIX}{{"type": "end_of_video"}}',
]

PROGRESS_TPL = [
    "--progress-template",
    f'{PREFIX}{{"type":"downloading","eta":%(progress.eta)s,'
    f'"downloaded_bytes":%(progress.downloaded_bytes)s,'
    f'"total_bytes":%(progress.total_bytes)s,'
    f'"total_bytes_estimate":%(progress.total_bytes_estimate)s,'
    f'"elapsed":%(progress.elapsed)s,"speed":%(progress.speed)s,'
    f'"playlist_count":%(info.playlist_count)s,'
    f'"playlist_index":%(info.playlist_index)s}}',
]


@dataclass
class ProgressEvent:
    kind: str
    payload: dict

def parse_line(line: str) -> list[ProgressEvent] | Exception | None:
    if line.startswith("stderr:ERROR: "):
        return RuntimeError(line[len("stderr:ERROR: ") :].strip())
    if line.startswith("ERROR: "):
        return RuntimeError(line[len("ERROR: ") :].strip())
    if line.startswith("stderr:") and PREFIX not in line:
        return RuntimeError(f"yt-dlp error: {line[len('stderr:'):].strip()}")
    idx = line.find(PREFIX)
    if idx < 0:
        return None
    part = line[idx + len(PREFIX) :].strip()
    try:
        obj = json.loads(part.replace("NA", "null"))
        if isinstance(obj, dict) and "type" in obj:
            return [ProgressEvent(obj["type"], obj)]
    except Exception:
        return None
    return None

class YtDlpRunner:
    def __init__(self, on_progress: Callable[[str], None]):
        self._on_progress = on_progress
        self._proc: subprocess.Popen | None = None
        self._q: Queue[str] = Queue()

    def is_running(self) -> bool:
        return self._proc is not None and self._proc.poll() is None

    def start(self, args: list[str], bin_path: str | None = None) -> bool:
        self.stop()
        cmd = [bin_path or "yt-dlp"] + args + PRINT_HOOKS + PROGRESS_TPL + ["--no-quiet"]
        self._proc = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            bufsize=0,
        )
        threading.Thread(target=self._pump, daemon=True).start()
        return True

    def stop(self) -> None:
        if self._proc:
            try:
                self._proc.terminate()
            except Exception:
                pass
            try:
                self._proc.wait(timeout=2)
            except Exception:
                try:
                    self._proc.kill()
                except Exception:
                    pass
            self._proc = None

    def _pump(self) -> None:
        assert self._proc and self._proc.stdout and self._proc.stderr

        def reader(stream, prefix: str):
            while True:
                chunk = stream.readline()
                if not chunk:
                    break
                try:
                    text = chunk.decode(errors="ignore")
                except Exception:
                    continue
                self._q.put(prefix + text)

        t1 = threading.Thread(target=reader, args=(self._proc.stdout, ""), daemon=True)
        t2 = threading.Thread(target=reader, args=(self._proc.stderr, "stderr:"), daemon=True)
        t1.start()
        t2.start()

        while self._proc:
            try:
                line = self._q.get(timeout=0.2)
            except Empty:
                continue
            self._on_progress(line)

        while not self._q.empty():
            try:
                line = self._q.get_nowait()
            except Empty:
                break
            self._on_progress(line)


--- FILE: ./src/whirltube/models.py ---
from __future__ import annotations

from dataclasses import dataclass


@dataclass(slots=True)
class Format:
    format_id: str
    label: str
    url: str | None = None
    filesize: int | None = None


@dataclass(slots=True)
class Video:
    id: str
    title: str
    url: str
    channel: str | None
    duration: int | None  # seconds
    thumb_url: str | None
    kind: str = "video"  # video|playlist|channel|comment
    view_count: int | None = None  # NEW: Number of views
    upload_date: str | None = None  # NEW: Upload date in YYYYMMDD format

    @property
    def duration_str(self) -> str:
        if not self.duration or self.duration <= 0:
            return ""
        s = self.duration
        h = s // 3600
        m = (s % 3600) // 60
        sec = s % 60
        if h:
            return f"{h:d}:{m:02d}:{sec:02d}"
        return f"{m:d}:{sec:02d}"

    @property
    def view_count_str(self) -> str:
        """Format view count as human-readable"""
        if not self.view_count:
            return ""
        v = self.view_count
        if v >= 1_000_000:
            return f"{v / 1_000_000:.1f}M views"
        elif v >= 1_000:
            return f"{v / 1_000:.1f}K views"
        return f"{v} views"
    
    @property
    def upload_date_str(self) -> str:
        """Format upload date as human-readable"""
        if not self.upload_date or len(self.upload_date) != 8:
            return ""
        try:
            from datetime import datetime
            dt = datetime.strptime(self.upload_date, "%Y%m%d")
            # Relative time
            now = datetime.now()
            delta = now - dt
            if delta.days == 0:
                return "Today"
            elif delta.days == 1:
                return "Yesterday"
            elif delta.days < 7:
                return f"{delta.days} days ago"
            elif delta.days < 30:
                return f"{delta.days // 7} weeks ago"
            elif delta.days < 365:
                return f"{delta.days // 30} months ago"
            else:
                return f"{delta.days // 365} years ago"
        except Exception:
            return ""

    @property
    def is_playable(self) -> bool:
        return self.kind == "video"


--- FILE: ./src/whirltube/window.py ---
from __future__ import annotations

import logging
import os
import threading
from concurrent.futures import ThreadPoolExecutor
from urllib.parse import urlparse, parse_qs
from pathlib import Path
import re

import gi
gi.require_version("Gtk", "4.0")
gi.require_version("Adw", "1")
gi.require_version("Gdk", "4.0")
gi.require_version("GdkPixbuf", "2.0")
from gi.repository import Adw, Gio, GLib, Gtk, Gdk

from . import __version__
from .dialogs import DownloadOptions, DownloadOptionsWindow, PreferencesWindow
from .history import add_search_term, add_watch, list_watch, search_history_suggestions, clear_search_history, get_search_history_count
from .subscription_feed import is_watched
from .models import Video
from .mpv_embed import MpvWidget
from .providers.ytdlp import YTDLPProvider
from .providers.invidious import InvidiousProvider
from .download_manager import DownloadManager
from .navigation_controller import NavigationController
from .download_history import list_downloads
from .subscriptions import is_followed, add_subscription, remove_subscription, list_subscriptions, export_subscriptions, import_subscriptions
from .watch_later import list_watch_later, clear_watch_later, get_watch_later_count
from .thumbnail_cache import clear_cache as clear_thumbnail_cache, get_cache_stats, cleanup_old_cache, enforce_cache_size_limit
from .quickdownload import QuickDownloadWindow
from .ui.widgets.result_row import ResultRow
from .ui.widgets.mpv_controls import MpvControls
from .services.playback import PlaybackService
from .ui.controllers import search
from .metrics import timed
from .util import load_settings, save_settings, xdg_data_dir, safe_httpx_proxy

# Use GL-based widget for Wayland compatibility if available
# Prefer GL widget on Wayland, fallback to X11 widget on X11
try:
    from .mpv_gl import MpvGLWidget
    HAS_GL_WIDGET = True
except ImportError:
    HAS_GL_WIDGET = False
    MpvGLWidget = None  # type: ignore

# Detect session type for better widget selection
SESSION_TYPE = (os.environ.get("XDG_SESSION_TYPE") or "").lower()
IS_WAYLAND = SESSION_TYPE == "wayland" or bool(os.environ.get("WAYLAND_DISPLAY"))

HEADERS = {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0"}

THUMB_SIZE = (160, 90)
DEFAULT_SEARCH_LIMIT = 30
DEFAULT_WATCH_HISTORY = 200
DEFAULT_DOWNLOAD_HISTORY = 300
MAX_THUMB_WORKERS = 4
FEED_VIDEOS_PER_CHANNEL = 5

log = logging.getLogger(__name__)


class MainWindow(Adw.ApplicationWindow):
    def __init__(self, app: Adw.Application) -> None:
        super().__init__(application=app, title="WhirlTube")
        # Load settings first, then apply persisted window size
        self.settings = load_settings()
        try:
            w = int(self.settings.get("win_w") or 1080)
            h = int(self.settings.get("win_h") or 740)
        except Exception:
            w, h = 1080, 740
        self.set_default_size(w, h)
        self.set_icon_name("whirltube")

        self.download_dir = Path(self.settings.get("download_dir") or str(xdg_data_dir() / "downloads"))
        self.settings.setdefault("playback_mode", "external")  # external | embedded
        self.settings.setdefault("mpv_args", "")
        self.settings.setdefault("mpv_quality", "auto")
        self.settings.setdefault("native_playback", False)

        # Optional playback cookies for MPV
        self.settings.setdefault("mpv_cookies_enable", False)
        self.settings.setdefault("mpv_cookies_browser", "")
        self.settings.setdefault("mpv_cookies_keyring", "")
        self.settings.setdefault("mpv_cookies_profile", "")
        self.settings.setdefault("mpv_cookies_container", "")

        self.settings.setdefault("max_concurrent_downloads", 3)
        self.settings.setdefault("mpv_autohide_controls", False)
        self.settings.setdefault("download_template", "%(title)s.%(ext)s")
        self.settings.setdefault("download_auto_open_folder", False)
        self.settings.setdefault("quick_quality_presets", "1080p,720p,audio")  # NEW
        # SponsorBlock settings
        self.settings.setdefault("sb_playback_enable", False)
        self.settings.setdefault("sb_playback_mode", "mark")  # mark | skip
        self.settings.setdefault("sb_playback_categories", "default")
        # Window size persistence
        self.settings.setdefault("win_w", 1080)
        self.settings.setdefault("win_h", 740)
        self.settings.setdefault("yt_hl", "en")
        self.settings.setdefault("yt_gl", "US")
        
        # Initialize provider with global proxy and optional Invidious
        proxy_raw = (self.settings.get("http_proxy") or "").strip()
        proxy = safe_httpx_proxy(proxy_raw) if proxy_raw else None

        if bool(self.settings.get("use_invidious")):
            base = (self.settings.get("invidious_instance") or "https://yewtu.be").strip()
            self.provider = InvidiousProvider(base, proxy=proxy, fallback=YTDLPProvider(proxy))
        else:
            fb = YTDLPProvider(proxy)
            from .providers.innertube_web import InnerTubeWeb
            from .providers.hybrid import HybridProvider
            hl = (self.settings.get("yt_hl") or "en").strip() or "en"
            gl = (self.settings.get("yt_gl") or "US").strip() or "US"
            self.provider = HybridProvider(InnerTubeWeb(hl=hl, gl=gl), fb)
        
        self._search_generation = 0
        self._search_lock = threading.Lock()
        self._thumb_loader_pool = ThreadPoolExecutor(max_workers=MAX_THUMB_WORKERS)
        
        # ToolbarView
        self.toolbar_view = Adw.ToolbarView()
        
        # Header
        header = Adw.HeaderBar()
        self.toolbar_view.add_top_bar(header)
        
        # Initialize MPV controls widget and service
        # Use GL-based widget for Wayland compatibility if available
        # On Wayland, prefer GL widget; on X11, prefer X11 widget
        if IS_WAYLAND and HAS_GL_WIDGET:
            self.mpv_widget = MpvGLWidget()
        elif HAS_GL_WIDGET:
            # Use GL widget as fallback if available (better compatibility)
            self.mpv_widget = MpvGLWidget()
        else:
            # Fallback to X11 widget
            self.mpv_widget = MpvWidget()
        self.playback_service = PlaybackService(self.mpv_widget, self.settings.get)
        self.playback_service.native_playback_enabled = bool(self.settings.get("native_playback"))
        self.mpv_controls = MpvControls(self.playback_service)
        
        # Pass cookies to provider as well (helps trending/region walls)
        try:
            spec = self.playback_service.get_cookie_spec()
            if spec:
                if isinstance(self.provider, YTDLPProvider):
                    self.provider.set_cookies_from_browser(spec)
                elif isinstance(self.provider, InvidiousProvider):
                    # Set cookies on the fallback YTDLPProvider for InvidiousProvider
                    self.provider._fallback.set_cookies_from_browser(spec)
        except Exception:
            pass
        
        # Add the MPV control bar as a top bar
        self.toolbar_view.add_top_bar(self.mpv_controls.get_ctrl_bar())
        self.mpv_controls.get_ctrl_bar().set_visible(False)
        
        # Toast overlay wraps the whole UI
        self.toast_overlay = Adw.ToastOverlay()
        self.set_content(self.toast_overlay)
        
        # Back button (NavigationController will connect it)
        self.btn_back = Gtk.Button(icon_name="go-previous-symbolic")
        self.btn_back.set_tooltip_text("Back")
        header.pack_start(self.btn_back)
        
        # Menu
        menu = Gio.Menu()
        menu.append("Preferences", "win.preferences")
        menu.append("About", "win.about")
        menu.append("Manage Subscriptions", "win.subscriptions")
        menu.append("Import Subscriptionsâ€¦", "win.subs_import")
        menu.append("Export Subscriptionsâ€¦", "win.subs_export")
        menu.append("Keyboard Shortcuts", "win.shortcuts")
        menu.append("Watch Later", "win.watch_later")
        menu.append("Clear Watch Later", "win.clear_watch_later")
        menu.append("Clear Search History", "win.clear_search_history")
        menu.append("Clear Thumbnail Cache", "win.clear_thumb_cache")
        menu.append("Download History", "win.download_history")
        menu.append("Cancel All Downloads", "win.cancel_all_downloads")
        menu.append("Clear Finished Downloads", "win.clear_finished_downloads")
        menu.append("Copy URL @ time", "win.mpv_copy_ts")
        menu.append("System Health Check", "win.health_check")
        menu.append("Stop MPV", "win.stop_mpv")
        menu.append("Quit", "app.quit")
        menu_btn = Gtk.MenuButton(icon_name="open-menu-symbolic")
        menu_btn.set_menu_model(menu)
        header.pack_start(menu_btn)
        
        # Create primary actions menu (left side)
        primary_menu = Gio.Menu()
        primary_menu.append("Open URLâ€¦", "win.open_url")
        primary_menu.append("Quick Download", "win.quick_download")
        primary_menu.append("Watch Later", "win.watch_later")

        # Sections submenu
        sections_menu = Gio.Menu()
        sections_menu.append("History", "win.history")
        sections_menu.append("Feed", "win.feed")
        sections_menu.append("Trending", "win.trending")
        print("Menu item added for trending with action 'win.trending'")
        primary_menu.append_section("Browse", sections_menu)

        primary_btn = Gtk.MenuButton(icon_name="folder-open-symbolic")
        primary_btn.set_menu_model(primary_menu)
        primary_btn.set_tooltip_text("Browse")
        header.pack_start(primary_btn)

        # NEW: Watch Later button with count badge (keep this minimal one to show importance)
        self.btn_watch_later = Gtk.Button(icon_name="bookmark-new-symbolic")  # Use icon instead
        self._update_watch_later_button()
        self.btn_watch_later.set_can_focus(True)
        self.btn_watch_later.set_tooltip_text("Videos saved for later")
        self.btn_watch_later.connect("clicked", self._on_watch_later)
        header.pack_start(self.btn_watch_later)

        # Search with autocomplete
        self.search = Gtk.SearchEntry(hexpand=True)
        self.search.set_can_focus(True)
        self.search.set_placeholder_text("Search YouTubeâ€¦")
        header.set_title_widget(self.search)
        self.search.connect("activate", self._on_search_activate)
        print("Connected 'activate' for search entry:", self.search)
        self.search.connect("search-changed", self._on_search_changed)
        print("Connected 'search-changed' for search entry:", self.search)

        # Clear text when the user presses Escape or the clear icon
        def _stop_search(_entry, *_a):
            try:
                self.search.set_text("")
                self._set_welcome()
                # Hide suggestions when clearing
                if hasattr(self, '_search_suggestions_popover'):
                    self._search_suggestions_popover.popdown()
            except Exception:
                import logging
                logging.getLogger("search.debug").exception("Error in _stop_search")
                pass
        self.search.connect("stop-search", _stop_search)

        # Create suggestions popover
        self._create_search_suggestions()

        # Filters popover
        self.btn_filters = Gtk.MenuButton(icon_name="view-list-symbolic")
        self.btn_filters.set_can_focus(True)
        self.btn_filters.set_tooltip_text("Search filters")
        header.pack_end(self.btn_filters)
        self._filters_pop = Gtk.Popover()
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8, margin_top=12, margin_bottom=12, margin_start=12, margin_end=12)
        # Duration
        box.append(Gtk.Label(label="Duration", xalign=0.0))
        self.dd_dur = Gtk.DropDown.new_from_strings(["Any", "Short (<4m)", "Medium (4â€“20m)", "Long (>20m)"])
        box.append(self.dd_dur)
        # Upload date
        box.append(Gtk.Label(label="Upload date", xalign=0.0))
        self.dd_period = Gtk.DropDown.new_from_strings(["Any", "Today", "This week", "This month"]) 
        box.append(self.dd_period)
        # Order
        box.append(Gtk.Label(label="Order", xalign=0.0))
        self.dd_order = Gtk.DropDown.new_from_strings(["Relevance", "Date", "Views"]) 
        box.append(self.dd_order)
        # Buttons row
        row = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        btn_clear = Gtk.Button(label="Clear")
        btn_apply = Gtk.Button(label="Apply", css_classes=["suggested-action"]) 
        row.append(btn_clear)
        row.append(btn_apply)
        box.append(row)
        self._filters_pop.set_child(box)
        self.btn_filters.set_popover(self._filters_pop)
        # Load current settings into UI
        self._filters_load_from_settings()
        btn_clear.connect("clicked", self._filters_clear)
        btn_apply.connect("clicked", self._filters_apply)
        
        # Downloads toggle
        self.downloads_button = Gtk.Button(label="Downloads")
        self.downloads_button.set_can_focus(True)
        self.downloads_button.connect("clicked", self._show_downloads)
        header.pack_end(self.downloads_button)

        # Stack
        self.stack = Gtk.Stack(
            vexpand=True,
            hexpand=True,
            transition_type=Gtk.StackTransitionType.CROSSFADE,
        )
        
        # Results
        self.results_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        self._set_margins(self.results_box, 8)
        results_scroll = Gtk.ScrolledWindow(vexpand=True)
        results_scroll.set_child(self.results_box)
        self.stack.add_titled(results_scroll, "results", "Results")

        # Downloads
        downloads_page = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        self._set_margins(downloads_page, 8)
        # Header row with "Open download directory"
        dl_hdr = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        self.btn_open_dl_dir = Gtk.Button(label="Open download directory")
        self.btn_open_dl_dir.set_tooltip_text("Open current download directory")
        self.btn_open_dl_dir.connect("clicked", self._open_download_dir)
        dl_hdr.append(self.btn_open_dl_dir)
        dl_hdr.append(Gtk.Label(label="", hexpand=True))  # spacer
        downloads_page.append(dl_hdr)
        # Scroll with list
        self.downloads_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        downloads_scroll = Gtk.ScrolledWindow(vexpand=True)
        downloads_scroll.set_child(self.downloads_box)
        downloads_page.append(downloads_scroll)
        # Add as stack page
        self.stack.add_titled(downloads_page, "downloads", "Downloads")

        # Player (embedded mpv)
        self.player_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self._set_margins(self.player_box, 0)
        self.player_box.append(self.mpv_widget)
        self.stack.add_titled(self.player_box, "player", "Player")

        # Place ToolbarView inside the ToastOverlay
        self.toast_overlay.set_child(self.toolbar_view)
        self.toolbar_view.set_content(self.stack)
        
        # Track stack page changes once (for MPV controls visibility)
        try:
            self.stack.connect("notify::visible-child", self._on_stack_changed)
        except Exception:
            pass

        # Navigation controller (handles back button)
        self.navigation_controller = NavigationController(self.stack, self.btn_back)

        # Download manager (after downloads_box and nav exist)
        self.download_manager = DownloadManager(
            downloads_box=self.downloads_box,
            show_downloads_view=lambda: self.navigation_controller.show_view("downloads"),
            get_setting=self.settings.get,
            show_error=self._show_error,
            show_toast=self._show_toast,
        )
        self.download_manager.set_download_dir(self.download_dir)
        self.download_manager.set_max_concurrent(int(self.settings.get("max_concurrent_downloads") or 3))
        self.download_manager.restore_queued()

        self._create_actions()
        
        # Debug: Print all window and app actions
        print("Window actions:", list(self.list_actions()))
        app_obj = self.get_application()
        if app_obj:
            print("App actions:", list(app_obj.list_actions()))
        
        self._set_welcome()
        self._install_shortcuts()

        # MPV actions (menu + hotkeys) - now using controls widget
        self.mpv_controls.add_actions_to_window(self)
        self._install_key_controller()
        self.playback_service.set_callbacks(
            on_started=self._on_mpv_started,
            on_stopped=self._on_mpv_stopped
        )

        # MPV actions (menu + hotkeys) - set up accelerators
        app_obj = self.get_application()
        if app_obj:
            self.mpv_controls.install_accelerators(app_obj)

        # Track current URL for timestamp copying
        self._mpv_current_url: str | None = None
        self._last_filters: dict[str, str] | None = None

    def _update_watch_later_button(self) -> None:
        """Update Watch Later button label with count badge"""
        count = get_watch_later_count()
        if count > 0:
            self.btn_watch_later.set_label(f"Watch Later ({count})")
        else:
            self.btn_watch_later.set_label("Watch Later")

    def _create_search_suggestions(self) -> None:
        """Create search suggestions popover"""
        self._search_suggestions_popover = Gtk.Popover()
        self._search_suggestions_popover.set_parent(self.search)
        self._search_suggestions_popover.set_autohide(True)
        
        # Scrolled window for suggestions
        scroll = Gtk.ScrolledWindow()
        scroll.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        scroll.set_max_content_height(300)
        
        # List box for suggestions
        self._suggestions_list = Gtk.ListBox()
        self._suggestions_list.set_selection_mode(Gtk.SelectionMode.NONE)
        self._suggestions_list.add_css_class("navigation-sidebar")
        scroll.set_child(self._suggestions_list)
        
        self._search_suggestions_popover.set_child(scroll)
        
        # Connect row activation
        self._suggestions_list.connect("row-activated", self._on_suggestion_selected)

    def _on_search_changed(self, entry: Gtk.SearchEntry) -> None:
        """Handle search text changes for autocomplete"""
        text = entry.get_text().strip()
        
        # Only show suggestions if text is not empty and not just activated
        if not text:
            self._search_suggestions_popover.popdown()
            return

        # Local suggestions (existing)
        local = search_history_suggestions(text, limit=5)

        # Remote suggestions (YouTube suggestqueries), merge/dedupe
        def worker():
            remote = []
            try:
                from .providers.innertube_web import InnerTubeWeb
                web = InnerTubeWeb(hl=(self.settings.get("yt_hl") or "en"),
                                   gl=(self.settings.get("yt_gl") or "US"))
                remote = web.suggestions(text, max_items=10)
            except Exception:
                remote = []
            # merge + dedupe
            merged, seen = [], set()
            for s in local + remote:
                if s and s.lower() not in seen:
                    seen.add(s.lower())
                    merged.append(s)
            GLib.idle_add(self._populate_suggestions_list, merged[:10])

        import threading
        threading.Thread(target=worker, daemon=True).start()

    def _populate_suggestions_list(self, items: list[str]) -> bool:
        # clear list and repopulate
        if not items:
            self._search_suggestions_popover.popdown()
            return False
        # Remove old rows
        while True:
            row = self._suggestions_list.get_row_at_index(0)
            if not row:
                break
            self._suggestions_list.remove(row)
        # Add rows
        for s in items:
            row = Gtk.ListBoxRow()
            label = Gtk.Label(label=s, xalign=0)
            label.set_margin_top(8)
            label.set_margin_bottom(8)
            label.set_margin_start(12)
            label.set_margin_end(12)
            row.set_child(label)
            row._suggestion_text = s  # keep for handler
            self._suggestions_list.append(row)
        
        if items:
            self._search_suggestions_popover.popup()
        else:
            self._search_suggestions_popover.popdown()
        return False

    def _on_suggestion_selected(self, listbox: Gtk.ListBox, row: Gtk.ListBoxRow) -> None:
        """Handle suggestion selection"""
        if not hasattr(row, '_suggestion_text'):
            return
        
        suggestion = row._suggestion_text
        self.search.set_text(suggestion)
        self._search_suggestions_popover.popdown()
        
        # Trigger search
        add_search_term(suggestion)
        self._run_search(suggestion)

        # Save settings on window close
        self.connect("close-request", self._on_main_close)

        # Clean up old thumbnails on startup (runs in background)
        def _cleanup_cache():
            import threading
            def worker():
                try:
                    cleanup_old_cache()
                    enforce_cache_size_limit()
                except Exception as e:
                    log.debug(f"Cache cleanup failed: {e}")
            threading.Thread(target=worker, daemon=True).start()

        GLib.idle_add(_cleanup_cache)
        

        
        # Add Ctrl+F to focus search
        focus_search = Gio.SimpleAction.new("focus_search", None)
        focus_search.connect("activate", lambda *_: self.search.grab_focus())
        self.add_action(focus_search)
        app = self.get_application()
        if app:
            app.set_accels_for_action("win.focus_search", ["<Primary>f", "<Primary>F"])

        # NEW: Add spacebar toggle play action
        toggle_play = Gio.SimpleAction.new("toggle_play", None)
        toggle_play.connect("activate", lambda *_: self.playback_service.cycle_pause() if self.playback_service.is_running() else None)
        self.add_action(toggle_play)
        if app:
            app.set_accels_for_action("win.toggle_play", ["space"])

    def _on_mpv_started(self, mode: str):
        """Called when MPV playback starts"""
        self.mpv_controls.get_ctrl_bar().set_visible(self._is_mpv_controls_visible())
        try:
            self._mpv_stop_action.set_enabled(True)
        except AttributeError:
            pass  # _mpv_stop_action may not be set in all contexts

    def _on_mpv_stopped(self):
        """Called when MPV playback stops"""
        self.mpv_controls.get_ctrl_bar().set_visible(False)
        try:
            self._mpv_stop_action.set_enabled(False)
        except AttributeError:
            pass

    def _show_toast(self, text: str) -> None:
        try:
            self.toast_overlay.add_toast(Adw.Toast.new(text))
        except Exception:
            pass

    def _install_shortcuts(self) -> None:
        # Add a "go-back" action with common shortcuts.
        go_back = Gio.SimpleAction.new("go-back", None)
        go_back.connect("activate", lambda *_: self.navigation_controller.go_back())
        self.add_action(go_back)
        app = self.get_application()
        if app:
            app.set_accels_for_action(
                "win.go-back",
                ["Escape", "BackSpace", "<Alt>Left", "<Primary>BackSpace"],
            )

    def _set_margins(self, w: Gtk.Widget, px: int) -> None:
        w.set_margin_top(px)
        w.set_margin_bottom(px)
        w.set_margin_start(px)
        w.set_margin_end(px)

    def _install_key_controller(self) -> None:
        ctrl = Gtk.EventControllerKey()
        def on_key(_c, keyval, keycode, state):
            # Handle search suggestions navigation
            if self.search.has_focus() and hasattr(self, '_search_suggestions_popover'):
                if self._search_suggestions_popover.get_visible():
                    from gi.repository import Gdk
                    k = Gdk.keyval_name(keyval)
                    
                    if k == "Down":
                        # Focus first suggestion
                        first_row = self._suggestions_list.get_row_at_index(0)
                        if first_row:
                            self._suggestions_list.select_row(first_row)
                        return True
                    elif k == "Escape":
                        self._search_suggestions_popover.popdown()
                        return True
            
            # Existing MPV controls
            return self.mpv_controls.handle_key_press(keyval, keycode, state)
        
        ctrl.connect("key-pressed", on_key)
        self.add_controller(ctrl)

    def _create_actions(self) -> None:
        about = Gio.SimpleAction.new("about", None)
        about.connect("activate", self._on_about)
        self.add_action(about)
        print("Added action: about")

        prefs = Gio.SimpleAction.new("preferences", None)
        prefs.connect("activate", self._on_preferences)
        self.add_action(prefs)
        print("Added action: preferences")

        # Add the open URL action for Ctrl+L
        open_url = Gio.SimpleAction.new("open_url", None)
        open_url.connect("activate", self._on_open_url)
        self.add_action(open_url)
        print("Added action: open_url")
        app = self.get_application()
        if app:
            app.set_accels_for_action("win.open_url", ["<Primary>L"])
            print("Set accelerator for win.open_url: Ctrl+L")

        shortcuts = Gio.SimpleAction.new("shortcuts", None)
        shortcuts.connect("activate", self._on_shortcuts)
        self.add_action(shortcuts)
        print("Added action: shortcuts")

        # Browse actions
        history_action = Gio.SimpleAction.new("history", None)
        history_action.connect("activate", self._on_history)
        self.add_action(history_action)
        print("Added action: history")

        feed_action = Gio.SimpleAction.new("feed", None)
        feed_action.connect("activate", self._on_feed)
        self.add_action(feed_action)
        print("Added action: feed")

        trending_action = Gio.SimpleAction.new("trending", None)
        trending_action.connect("activate", self._on_trending)
        self.add_action(trending_action)
        print("Added action: trending")

        # Quick Download action
        quick_download_action = Gio.SimpleAction.new("quick_download", None)
        quick_download_action.connect("activate", self._on_quick_download)
        self.add_action(quick_download_action)

        # Watch Later actions
        watch_later_action = Gio.SimpleAction.new("watch_later", None)
        watch_later_action.connect("activate", self._on_watch_later)
        self.add_action(watch_later_action)

        clear_wl_action = Gio.SimpleAction.new("clear_watch_later", None)
        clear_wl_action.connect("activate", self._on_clear_watch_later)
        self.add_action(clear_wl_action)

        # Search history action
        clear_search_action = Gio.SimpleAction.new("clear_search_history", None)
        clear_search_action.connect("activate", self._on_clear_search_history)
        self.add_action(clear_search_action)

        # Thumbnail cache action
        clear_cache_action = Gio.SimpleAction.new("clear_thumb_cache", None)
        clear_cache_action.connect("activate", self._on_clear_thumbnail_cache)
        self.add_action(clear_cache_action)

        dlh = Gio.SimpleAction.new("download_history", None)
        dlh.connect("activate", self._on_download_history)
        self.add_action(dlh)

        cancel_all = Gio.SimpleAction.new("cancel_all_downloads", None)
        cancel_all.connect("activate", lambda *_: self.download_manager.cancel_all())
        self.add_action(cancel_all)

        clear_fin = Gio.SimpleAction.new("clear_finished_downloads", None)
        clear_fin.connect("activate", lambda *_: self.download_manager.clear_finished())
        self.add_action(clear_fin)

        health = Gio.SimpleAction.new("health_check", None)
        health.connect("activate", self._on_health_check)
        self.add_action(health)

        # Subscriptions actions (menu entries exist, actions were missing)
        subs = Gio.SimpleAction.new("subscriptions", None)
        subs.connect("activate", self._on_subscriptions)
        self.add_action(subs)

        subs_import = Gio.SimpleAction.new("subs_import", None)
        subs_import.connect("activate", self._on_subs_import)
        self.add_action(subs_import)

        subs_export = Gio.SimpleAction.new("subs_export", None)
        subs_export.connect("activate", self._on_subs_export)
        self.add_action(subs_export)

    def _show_loading(self, message: str, cancellable: bool = False) -> None:
        # Clear results and show a centered spinner + message
        self._clear_results()
        row = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)
        row.set_halign(Gtk.Align.CENTER)
        row.set_valign(Gtk.Align.CENTER)
        spinner = Gtk.Spinner()
        spinner.start()
        row.append(spinner)
        row.append(Gtk.Label(label=message))
        
        if cancellable:
            btn_cancel = Gtk.Button(label="Cancel")
            btn_cancel.connect("clicked", lambda *_: self._cancel_loading())
            row.append(btn_cancel)
            
        self.results_box.append(row)
        self.navigation_controller.show_view("results")

    def _cancel_loading(self):
        self._search_generation += 1  # Invalidate current search
        self._set_welcome()

    def _on_shortcuts(self, *_a) -> None:
        # Create a ShortcutsWindow describing common keybindings
        win = Gtk.ShortcutsWindow(transient_for=self, modal=True)
        sec = Gtk.ShortcutsSection()
        # Navigation group
        grp_nav = Gtk.ShortcutsGroup(title="Navigation")
        grp_nav.append(Gtk.ShortcutsShortcut(title="Back", accelerator="Escape"))
        grp_nav.append(Gtk.ShortcutsShortcut(title="Back", accelerator="BackSpace"))
        grp_nav.append(Gtk.ShortcutsShortcut(title="Back", accelerator="<Alt>Left"))
        grp_nav.append(Gtk.ShortcutsShortcut(title="Back", accelerator="<Primary>BackSpace"))
        # App group
        grp_app = Gtk.ShortcutsGroup(title="Application")
        grp_app.append(Gtk.ShortcutsShortcut(title="Open URL", accelerator="<Primary>L"))
        grp_app.append(Gtk.ShortcutsShortcut(title="Quit", accelerator="<Primary>q"))
        # Search group
        grp_search = Gtk.ShortcutsGroup(title="Search")
        grp_search.append(Gtk.ShortcutsShortcut(title="Run search", accelerator="Return"))
        # Player/MPV controls
        grp_play = Gtk.ShortcutsGroup(title="MPV Controls")
        grp_play.append(Gtk.ShortcutsShortcut(title="Play/Pause", accelerator="K"))
        grp_play.append(Gtk.ShortcutsShortcut(title="Seek backward 10s", accelerator="J"))
        grp_play.append(Gtk.ShortcutsShortcut(title="Seek forward 10s", accelerator="L"))
        grp_play.append(Gtk.ShortcutsShortcut(title="Speed down", accelerator="-"))
        grp_play.append(Gtk.ShortcutsShortcut(title="Speed up", accelerator="="))
        grp_play.append(Gtk.ShortcutsShortcut(title="Stop", accelerator="X"))
        # Assemble: Add groups to section using add_group
        sec.add_group(grp_nav)
        sec.add_group(grp_app)
        sec.add_group(grp_search)
        sec.add_group(grp_play)
        win.add_section(sec)
        win.present()

    def _on_about(self, *_args) -> None:
        dlg = Adw.AboutDialog(
            application_name="WhirlTube",
            application_icon="whirltube",
            developer_name="WhirlTube contributors",
            version=__version__,
            license_type=Gtk.License.GPL_3_0,
            website="https://github.com/whirltube/whirltube",
            issue_url="https://github.com/whirltube/whirltube/issues",
            comments="Lightweight GTK4 frontend for YouTube using MPV + yt-dlp.",
        )
        dlg.present(self)

    def _on_download_history(self, *_a) -> None:
        vids = list_downloads(limit=DEFAULT_DOWNLOAD_HISTORY)
        self._populate_results(vids)
        self.navigation_controller.show_view("results")

    def _on_health_check(self, *_a):
        dlg = Adw.MessageDialog(
            transient_for=self,
            heading="System Health Check",
            body=self._run_health_checks()
        )
        dlg.add_response("ok", "OK")
        dlg.present()

    def _run_health_checks(self) -> str:
        checks = []
        
        # MPV
        from .player import has_mpv
        checks.append(f"âœ“ MPV: {has_mpv()}")
        
        # Proxy
        proxy = self.settings.get("http_proxy")
        if proxy:
            # Need to import safe_httpx_proxy from util
            from .util import safe_httpx_proxy
            valid = safe_httpx_proxy(proxy, test=True)
            checks.append(f"{'âœ“' if valid else 'âœ—'} Proxy: {proxy}")
        else:
            checks.append("âœ“ Proxy: (none configured)")
        
        # Provider
        checks.append(f"âœ“ Provider: {type(self.provider).__name__}")
        
        # Download dir
        checks.append(f"âœ“ Download dir: {self.download_dir.exists()}")
        
        return "\n".join(checks)

    def _on_subscriptions(self, *_a) -> None:
        # Show followed channels as rows (channel-kind Video entries)
        subs = list_subscriptions()
        vids = []
        for sub in subs:
            title = sub.title or "(channel)"
            vids.append(Video(id=sub.url, title=title, url=sub.url, channel=title, duration=None, thumb_url=None, kind="channel"))
        self._populate_results(vids)
        self.navigation_controller.show_view("results")

    def _on_subs_import(self, *_a) -> None:
        dlg = Gtk.FileDialog(title="Import subscriptions.json")
        def on_done(d, res, *_):
            try:
                f = d.open_finish(res)
            except Exception:
                return
            path = f.get_path()
            if not path:
                return
            try:
                added = import_subscriptions(Path(path))
                if added:
                    # Refresh subscriptions view if currently visible
                    self._on_subscriptions()
            except Exception:
                pass
        dlg.open(self, None, on_done, None)

    def _on_subs_export(self, *_a) -> None:
        dlg = Gtk.FileDialog(title="Export subscriptions")
        dlg.set_initial_name("subscriptions.json")
        def on_done(d, res, *_):
            try:
                f = d.save_finish(res)
            except Exception:
                return
            path = f.get_path()
            if not path:
                return
            dest = Path(path)
            try:
                export_subscriptions(dest)
                self._show_toast(f"Exported {len(list_subscriptions())} subscriptions to {dest}")
            except Exception as e:
                self._show_error(f"Export failed: {e}")
        dlg.save(self, None, on_done, None)

    def _on_clear_watch_later(self, *_a) -> None:
        """Clear all videos from watch later after confirmation"""
        count = get_watch_later_count()
        if count == 0:
            self._show_toast("Watch Later is already empty")
            return
        
        dialog = Adw.MessageDialog(
            transient_for=self,
            heading="Clear Watch Later?",
            body=f"Remove all {count} video(s) from Watch Later?",
        )
        dialog.add_response("cancel", "Cancel")
        dialog.add_response("clear", "Clear")
        dialog.set_response_appearance("clear", Adw.ResponseAppearance.DESTRUCTIVE)
        dialog.set_default_response("cancel")
        dialog.set_close_response("cancel")
        
        def on_response(d, response):
            if response == "clear":
                cleared = clear_watch_later()
                self._show_toast(f"Cleared {cleared} video(s) from Watch Later")
                self._update_watch_later_button()
                # Refresh view if currently showing watch later
                if self.stack.get_visible_child_name() == "results":
                    current_results = len([c for c in self.results_box])
                    # Simple heuristic: if results match cleared count, we're probably showing watch later
                    if current_results > 0:
                        self._on_watch_later()
        
        dialog.connect("response", on_response)
        dialog.present()

    def _on_clear_search_history(self, *_a) -> None:
        """Clear search history after confirmation"""
        count = get_search_history_count()
        
        if count == 0:
            self._show_toast("Search history is already empty")
            return
        
        dialog = Adw.MessageDialog(
            transient_for=self,
            heading="Clear Search History?",
            body=f"Remove all {count} search history entries?",
        )
        dialog.add_response("cancel", "Cancel")
        dialog.add_response("clear", "Clear")
        dialog.set_response_appearance("clear", Adw.ResponseAppearance.DESTRUCTIVE)
        dialog.set_default_response("cancel")
        dialog.set_close_response("cancel")
        
        def on_response(d, response):
            if response == "clear":
                cleared = clear_search_history()
                self._show_toast(f"Cleared {cleared} search history entries")
        
        dialog.connect("response", on_response)
        dialog.present()

    def _on_clear_thumbnail_cache(self, *_a) -> None:
        """Clear thumbnail cache after showing stats"""
        stats = get_cache_stats()
        
        if stats['file_count'] == 0:
            self._show_toast("Thumbnail cache is already empty")
            return
        
        dialog = Adw.MessageDialog(
            transient_for=self,
            heading="Clear Thumbnail Cache?",
            body=f"Remove {stats['file_count']} cached thumbnails ({stats['total_size_mb']} MB)?",
        )
        dialog.add_response("cancel", "Cancel")
        dialog.add_response("clear", "Clear")
        dialog.set_response_appearance("clear", Adw.ResponseAppearance.DESTRUCTIVE)
        dialog.set_default_response("cancel")
        dialog.set_close_response("cancel")
        
        def on_response(d, response):
            if response == "clear":
                count = clear_thumbnail_cache()
                self._show_toast(f"Cleared {count} cached thumbnails")
        
        dialog.connect("response", on_response)
        dialog.present()

    def _on_preferences(self, *_a) -> None:
        win = PreferencesWindow(self, self.settings)
        win.present()

        def persist(_w, *_a):
            save_settings(self.settings)
            new_dir = self.settings.get("download_dir")
            if new_dir:
                self.download_dir = Path(new_dir)
                self.download_manager.set_download_dir(self.download_dir)
            # Reconfigure provider: Invidious vs yt-dlp
            proxy_raw = (self.settings.get("http_proxy") or "").strip()
            proxy = safe_httpx_proxy(proxy_raw) if proxy_raw else None
            use_invid = bool(self.settings.get("use_invidious"))
            invid_base = (self.settings.get("invidious_instance") or "https://yewtu.be").strip()
            try:
                if use_invid:
                    self.provider = InvidiousProvider(invid_base, proxy=proxy, fallback=YTDLPProvider(proxy))
                else:
                    self.provider = YTDLPProvider(proxy)
                # Reapply cookies to provider on reconfigure
                spec = self.playback_service.get_cookie_spec()
                if spec:
                    if isinstance(self.provider, YTDLPProvider):
                        self.provider.set_cookies_from_browser(spec)
                    elif isinstance(self.provider, InvidiousProvider):
                        # Set cookies on the fallback YTDLPProvider for InvidiousProvider
                        self.provider._fallback.set_cookies_from_browser(spec)
            except Exception:
                # fallback to yt-dlp
                self.provider = YTDLPProvider(proxy)
            # Update concurrency at runtime
            self.download_manager.set_max_concurrent(int(self.settings.get("max_concurrent_downloads") or 3))
            # Update MPV controls visibility preference immediately
            self.mpv_controls.get_ctrl_bar().set_visible(self._is_mpv_controls_visible())

        win.connect("close-request", persist)

    def _on_main_close(self, *_a) -> bool:
        # Persist current window size
        try:
            self.settings["win_w"], self.settings["win_h"] = int(self.get_width()), int(self.get_height())
        except Exception:
            pass
        # Stop MPV if running
        try:
            self.playback_service.stop()
        except Exception:
            pass
        # Shut down thumbnail loader pool
        try:
            self._thumb_loader_pool.shutdown(wait=True, cancel_futures=True)
        except TypeError:
            # Python < 3.9 doesn't have cancel_futures
            self._thumb_loader_pool.shutdown(wait=False)
        except Exception:
            pass

        # Persist queue (best effort)
        try:
            self.download_manager.persist_queue()
        except Exception:
            pass
        save_settings(self.settings)
        return False

    def _set_welcome(self) -> None:
        self.navigation_controller.clear_history()
        self._clear_results()
        self.results_box.append(_spacer(16))
        label = Gtk.Label(
            label="Type a search and press Enter.\nOr click Open URL / Quick Download.",
            justify=Gtk.Justification.CENTER,
        )
        # Center in both axes using GTK4 halign/valign
        label.set_halign(Gtk.Align.CENTER)
        label.set_valign(Gtk.Align.CENTER)
        self.results_box.append(label)
        self.navigation_controller.show_view("results")

    def _clear_results(self) -> None:
        child = self.results_box.get_first_child()
        while child is not None:
            nxt = child.get_next_sibling()
            # Call cleanup if it's a ResultRow to cancel thumbnail loading
            if hasattr(child, 'cancel_thumbnail_loading'):
                child.cancel_thumbnail_loading()
            self.results_box.remove(child)
            child = nxt

    # ---------- Header actions ----------

    def _on_open_url(self, *_a) -> None:
        from .ui.controllers.browse import open_url_dialog
        open_url_dialog(
            self, self.provider, self.navigation_controller,
            self._extract_ytid_from_url, self._show_error, self._populate_results, self._play_video, self._show_loading
        )

    def _extract_ytid_from_url(self, url: str) -> str | None:
        """
        Extract a YouTube video ID from common URL forms:
        - https://www.youtube.com/watch?v=ID
        - https://youtu.be/ID
        - https://www.youtube.com/shorts/ID
        - https://www.youtube.com/embed/ID
        """
        try:
            u = urlparse(url)
            host = (u.hostname or "").lower()
            path = u.path or ""
            if host == "youtu.be":
                m = re.match(r"^/([0-9A-Za-z_-]{11})", path)
                if m:
                    return m.group(1)
            if host.endswith("youtube.com"):
                if path.startswith("/watch"):
                    qs = parse_qs(u.query or "")
                    v = qs.get("v", [None])[0]
                    if v and re.fullmatch(r"[0-9A-Za-z_-]{11}", v):
                        return v
                m = re.match(r"^/(?:shorts|embed)/([0-9A-Za-z_-]{11})", path)
                if m:
                    return m.group(1)
        except Exception:
            pass
        return None

    def _on_history(self, *_a) -> None:
        vids = list_watch(limit=DEFAULT_WATCH_HISTORY)
        self._populate_results(vids)
        self.navigation_controller.show_view("results")

    def _on_quick_download(self, *_a) -> None:
        QuickDownloadWindow(self).present()

    def _on_watch_later(self, *_a) -> None:
        """Show watch later queue, filtering out watched videos"""
        from .subscription_feed import is_watched
        
        vids = list_watch_later()
        
        if not vids:
            self._clear_results()
            self.results_box.append(Gtk.Label(label="No videos in Watch Later.\n\nClick 'Watch Later' on any video to add it here."))
            self.navigation_controller.show_view("results")
            return
        
        # Filter out watched videos
        unwatched = [v for v in vids if not is_watched(v.id)]
        
        if not unwatched:
            self._clear_results()
            self.results_box.append(Gtk.Label(label="All videos in Watch Later have been watched!\n\nGreat job!"))
            self.navigation_controller.show_view("results")
            return
        
        self._populate_results(unwatched)
        self.navigation_controller.show_view("results")

    def _on_feed(self, *_a) -> None:
        """Show subscription feed - use fast authenticated feed if available"""
        # Check if we have an authenticated Invidious token
        # Try secure storage first
        try:
            from .invidious_auth import InvidiousAuth
            auth_helper = InvidiousAuth("")
            token = auth_helper._get_secure_token()
            
            if not token:
                # Fall back to plain text settings
                token = self.settings.get("invidious_token", "")
        except Exception:
            # Fall back to plain text settings
            token = self.settings.get("invidious_token", "")
        
        instance_url = self.settings.get("invidious_instance", "https://yewtu.be").strip()
        
        if token and instance_url:
            # Try to use fast authenticated feed
            try:
                from .invidious_auth import InvidiousAuth
                
                # Create auth instance and set token
                auth = InvidiousAuth(instance_url)
                auth.token = token
                
                # Use fast authenticated feed
                self._show_loading("Loading feed (authenticated)...", cancellable=True)
                
                def worker():
                    try:
                        # Get feed from authenticated endpoint
                        feed_data = auth.get_feed(max_results=60)
                        
                        # Convert dicts to Video objects
                        from .providers.ytdlp import _entry_to_video
                        vids = [_entry_to_video(item) for item in feed_data if isinstance(item, dict)]
                        
                        GLib.idle_add(self._populate_results, vids)
                    except Exception as e:
                        import logging
                        logging.exception("Authenticated feed failed: %s", e)
                        # Fall back to slow method
                        GLib.idle_add(self._on_feed_slow_fallback)
                
                threading.Thread(target=worker, daemon=True).start()
                return
            except Exception as e:
                import logging
                logging.exception("Failed to initialize authenticated feed: %s", e)
                # Fall back to slow method
                self._on_feed_slow_fallback()
        else:
            # Use slow fallback method
            self._on_feed_slow_fallback()
    
    def _on_feed_slow_fallback(self, *_a) -> None:
        """Slow fallback method: fetch recent uploads from each followed channel"""
        self._show_loading("Loading feed (slow)...", cancellable=True)

        def worker():
            vids_all = []
            try:
                from .subscriptions import list_subscriptions
                subs = list_subscriptions()
                for sub in subs:
                    try:
                        vids = self.provider.channel_tab(sub.url, "videos")
                        if vids:
                            vids_all.extend(vids[:FEED_VIDEOS_PER_CHANNEL])
                    except Exception:
                        continue
            except Exception:
                vids_all = []
            GLib.idle_add(self._populate_results, vids_all)
        threading.Thread(target=worker, daemon=True).start()

    def _on_trending(self, *_a) -> None:
        import logging
        log = logging.getLogger("trending.debug")
        log.debug("_on_trending called")
        print("_on_trending called")
        self._show_loading("Loading trendingâ€¦", cancellable=True)
        def worker():
            try:
                vids = self.provider.trending()
            except Exception:
                import logging
                logging.getLogger("trending.debug").exception("Error in trending worker")
                vids = []
            def show():
                self._populate_results(vids)
                if not vids:
                    self._show_toast("Trending is unavailable on your network/region right now.")
                return False
            GLib.idle_add(show)
        threading.Thread(target=worker, daemon=True).start()

    # ---------- Search ----------

    # ---------- Search ----------

    def _on_search_activate(self, entry: Gtk.SearchEntry) -> None:
        import logging
        log = logging.getLogger("search.debug")
        log.debug("Search activate called")
        print("Search activate called")
        search.on_search_activate(entry, self._run_search)

    def _run_search(self, query: str) -> None:
        search.run_search(
            query=query,
            provider=self.provider,
            settings=self.settings,
            search_generation=self._search_generation,
            show_loading_func=self._show_loading,
            show_error_func=self._show_error,
            populate_results_func=self._populate_results,
            set_search_generation_func=self._set_search_generation,
            limit=DEFAULT_SEARCH_LIMIT,
            last_filters=self._last_filters,
            timed_func=timed,
            search_lock=self._search_lock,  # Pass the lock for thread safety
        )

    def _set_search_generation(self, gen: int) -> int:
        """Helper to update and return the new search generation counter."""
        self._search_generation = gen
        # Also store in settings for the controller to check
        self.settings["_search_generation"] = gen
        return gen

    def _show_error(self, msg: str) -> None:
        self._clear_results()
        lbl = Gtk.Label(label=msg)
        lbl.add_css_class("error")
        self.results_box.append(lbl)
        self.navigation_controller.show_view("results")

    def _populate_results(self, videos: list[Video]) -> None:
        self._clear_results()
        if not videos:
            self.results_box.append(Gtk.Label(label="No results."))
            return
        for v in videos:
            import logging
            log = logging.getLogger("whirltube.window")
            log.debug("row kind=%s title=%s", v.kind, v.title)
            row = ResultRow(
                video=v,
                on_play=self._play_video,
                on_download_opts=self._download_options,
                on_open=lambda video: self._open_item(video),
                on_related=lambda video: self._on_related(video),
                on_comments=lambda video: self._on_comments(video),
                thumb_loader_pool=self._thumb_loader_pool,
                http_proxy=(self.settings.get("http_proxy") or None),
                on_follow=self._follow_channel,
                on_unfollow=self._unfollow_channel,
                followed=is_followed(v.url) if v.kind == "channel" else False,
                on_open_channel=lambda video: self._open_channel_from_video(video),
                on_toast=self._show_toast,
                get_setting=self.settings.get,  # NEW - pass settings getter
                on_quick_download=self._quick_download_video,  # NEW - pass handler
            )
            self.results_box.append(row)

    def _quick_download_video(self, video: Video, opts: DownloadOptions) -> None:
        """Handle quick quality download"""
        self.download_manager.start_download(video, opts)

    def _follow_channel(self, video: Video) -> None:
        try:
            add_subscription(video.url, video.title)
        except Exception:
            pass

    def _unfollow_channel(self, video: Video) -> None:
        try:
            remove_subscription(video.url)
        except Exception:
            pass

    # ---------- Item actions ----------

    def _open_item(self, video: Video) -> None:
        from .ui.controllers.browse import open_item
        open_item(
            video, self.provider, self.navigation_controller, self._show_error, 
            self._populate_results, self._play_video, 
            lambda url: self._open_playlist(url), 
            lambda url: self._open_channel(url), self._show_loading
        )

    def _open_playlist(self, url: str) -> None:
        from .ui.controllers.browse import open_playlist
        open_playlist(url, self.provider, self.navigation_controller, self._show_error, self._populate_results, self._show_loading)

    def _open_channel(self, url: str) -> None:
        from .ui.controllers.browse import open_channel
        open_channel(url, self.provider, self.navigation_controller, self._show_error, self._populate_results, self._show_loading)

    def _on_related(self, video: Video) -> None:
        from .ui.controllers.browse import on_related
        on_related(video, self.provider, self.navigation_controller, self._show_error, self._populate_results, self._show_loading)

    def _on_comments(self, video: Video) -> None:
        from .ui.controllers.browse import on_comments
        on_comments(video, self.provider, self.navigation_controller, self._show_error, self._populate_results, self._show_loading)

    def _open_channel_from_video(self, video: Video) -> None:
        from .ui.controllers.browse import open_channel_from_video
        open_channel_from_video(
            video, self.provider, self.navigation_controller, self._show_error, 
            self._populate_results, lambda url: self._open_channel(url), self._show_loading
        )

    def _play_video(self, video: Video) -> None:
        # Log that the function was called to help with debugging
        log.debug("_play_video called: url=%s", video.url)
        # Save to watch history
        add_watch(video)

        # Play using the playback service
        success = self.playback_service.play(video=video)
        
        mode = self.settings.get("playback_mode", "external")
        if success and mode == "embedded":
            # If embedded playback was successful, show the player view
            self.navigation_controller.show_view("player")
        
        if success:
            self._show_toast(f"Playing: {video.title}")

    def _is_mpv_controls_visible(self) -> bool:
        if not hasattr(self, 'playback_service'):
            return False
        # Only show controls if MPV running
        if not self.playback_service.is_running():
            return False
        # honor autohide preference: show only on player view when enabled
        if bool(self.settings.get("mpv_autohide_controls")):
            return (self.stack.get_visible_child_name() == "player")
        return True

    def _on_stack_changed(self, *_a) -> None:
        try:
            self.mpv_controls.get_ctrl_bar().set_visible(self._is_mpv_controls_visible())
        except Exception:
            pass

    def _cookies_spec_for_ytdlp(self) -> str | None:
        if not self.settings.get("mpv_cookies_enable"):
            return None
        browser = (self.settings.get("mpv_cookies_browser") or "").strip()
        if not browser:
            return None
        keyring = (self.settings.get("mpv_cookies_keyring") or "").strip()
        profile = (self.settings.get("mpv_cookies_profile") or "").strip()
        container = (self.settings.get("mpv_cookies_container") or "").strip()
        
        # Construct: browser[+keyring][:profile][::container]
        val = browser
        if keyring:
            val += f"+{keyring}"
        
        # Handle profile and container correctly
        if profile and container:
            # Both present: browser:profile::container
            val += f":{profile}::{container}"
        elif profile:
            # Only profile: browser:profile
            val += f":{profile}"
        elif container:
            # Only container: browser::container
            val += f"::{container}"
        # If neither, val stays as browser or browser+keyring
        
        return val

    # ---------- Downloads ----------

    def _download_options(self, video: Video) -> None:
        dlg = DownloadOptionsWindow(self, video.title)

        def fetch_formats(_btn):
            dlg.begin_format_fetch()
            def worker() -> None:
                try:
                    fmts = self.provider.fetch_formats(video.url)
                except Exception:
                    fmts = []
                GLib.idle_add(dlg.set_formats, fmts)

        dlg.btn_fetch.connect("clicked", fetch_formats)
        dlg.present()

        def after_close(_w, *_a):
            accepted, opts = dlg.get_options()
            if accepted:
                self._download_video_with_options(video, opts)

        dlg.connect("close-request", after_close)

    def _download_video_with_options(self, video: Video, opts: DownloadOptions) -> None:
        self.download_manager.start_download(video, opts)

    def _show_downloads(self, *_args) -> None:
        self.navigation_controller.show_view("downloads")

    def _open_download_dir(self, *_a) -> None:
        try:
            p = self.download_dir
            if isinstance(p, Path):
                Gio.AppInfo.launch_default_for_uri(p.as_uri(), None)
        except Exception:
            pass

    def _filters_load_from_settings(self) -> None:
        search.filters_load_from_settings(
            settings=self.settings,
            dd_dur=self.dd_dur,
            dd_period=self.dd_period,
            dd_order=self.dd_order,
        )

    def _filters_apply(self, *_a) -> None:
        def set_last_filters(filters: dict[str, str]) -> None:
            self._last_filters = filters
        
        search.filters_apply(
            settings=self.settings,
            dd_dur=self.dd_dur,
            dd_period=self.dd_period,
            dd_order=self.dd_order,
            filters_pop=self._filters_pop,
            search_entry=self.search,
            run_search_func=self._run_search,
            set_last_filters_func=set_last_filters,
        )

    def _filters_clear(self, *_a) -> None:
        search.filters_clear(
            settings=self.settings,
            load_filters_func=self._filters_load_from_settings,
            search_entry=self.search,
            run_search_func=self._run_search,
        )


def _spacer(px: int) -> Gtk.Box:
    b = Gtk.Box()
    b.set_size_request(-1, px)
    return b

--- FILE: ./src/whirltube/mpv_embed.py ---
from __future__ import annotations

import logging
from typing import Optional, Mapping, Any

import gi
gi.require_version("Gtk", "4.0")
gi.require_version("Gdk", "4.0")
from gi.repository import Gtk

log = logging.getLogger(__name__)

try:
    gi.require_version("GdkX11", "4.0")
    from gi.repository import GdkX11  # type: ignore
except Exception:
    GdkX11 = None  # type: ignore

try:
    import mpv  # type: ignore
except Exception:
    mpv = None  # type: ignore


class MpvWidget(Gtk.Box):
    """
    Attempt to embed mpv into a GTK widget on X11.
    On Wayland (or missing python-mpv), shows a fallback label.
    """
    # Note: Works on X11. Wayland falls back to label (external mpv is used).

    def __init__(self) -> None:
        super().__init__(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.set_hexpand(True)
        self.set_vexpand(True)

        self._area = Gtk.DrawingArea()
        self._area.set_hexpand(True)
        self._area.set_vexpand(True)
        self.append(self._area)

        self._mpv: mpv.MPV | None = None
        self._ready = False

        self._fallback = Gtk.Label(
            label="Embedded playback not available on this backend.\nUsing external MPV instead.",
            wrap=True,
            justify=Gtk.Justification.CENTER,
        )
        self._fallback.set_visible(False)
        self.append(self._fallback)

        self._area.connect("realize", self._on_realize)
        self._area.connect("unrealize", self._on_unrealize)

    # --- GTK lifecycle ---
    def _on_realize(self, *_args) -> None:
        if mpv is None or GdkX11 is None:
            self._fallback.set_visible(True)
            log.info("mpv embedding not available (python-mpv or X11 missing)")
            return
        native = self._area.get_native()
        if native is None:
            self._fallback.set_visible(True)
            return
        surface = native.get_surface()
        if surface is None or not isinstance(surface, GdkX11.X11Surface):
            self._fallback.set_visible(True)
            log.info("Not an X11 surface; cannot embed mpv.")
            return
        xid = GdkX11.X11Surface.get_xid(surface)
        try:
            # Set locale for libmpv (client.h requirement)
            try:
                import locale
                locale.setlocale(locale.LC_NUMERIC, "C")
            except Exception:
                pass
            
            # Basic, usable defaults. More can be set later via setters below.
            self._mpv = mpv.MPV(
                wid=str(xid),
                ytdl=True, osc=True, input_default_bindings=True, config=True, keep_open=True,
            )
            
            # Use property observers instead of polling for better performance
            @self._mpv.property_observer('time-pos')
            def _time_observer(_name, val):
                # This will be called whenever time-pos changes
                # Hook into controls/overlay as needed
                pass

            @self._mpv.property_observer('pause')
            def _pause_observer(_name, paused):
                # This will be called whenever pause state changes
                pass
            
            self._ready = True
            self._fallback.set_visible(False)
        except Exception as e:
            log.exception("Failed to create mpv instance: %s", e)
            self._fallback.set_visible(True)

    def _on_unrealize(self, *_args) -> None:
        if self._mpv:
            try:
                self._mpv.terminate()
            except Exception:
                pass
        self._mpv = None
        self._ready = False

    # --- Capability ---
    @property
    def is_ready(self) -> bool:
        return self._ready and self._mpv is not None

    # --- Option setters (call before play() ideally) ---
    def set_ytdl_format(self, fmt: Optional[str]) -> None:
        if not self.is_ready or fmt is None:
            return
        try:
            self._mpv["ytdl-format"] = fmt  # type: ignore[index]
        except Exception:
            pass

    def set_ytdl_raw_options(self, opts: Optional[Mapping[str, Any]]) -> None:
        """
        opts example: {"cookies-from-browser": "firefox+gnomekeyring:default::Work", "proxy": "http://..."}
        """
        if not self.is_ready or not opts:
            return
        try:
            # python-mpv accepts dict for ytdl-raw-options
            self._mpv["ytdl-raw-options"] = dict(opts)  # type: ignore[index]
        except Exception:
            pass

    # --- Playback controls ---
    def play(self, url: str) -> bool:
        if self._ready and self._mpv is not None:
            try:
                self._mpv.play(url)  # type: ignore[attr-defined]
                return True
            except Exception:
                log.exception("mpv.play failed")
                return False
        return False

    def pause_toggle(self) -> None:
        if not self.is_ready:
            return
        try:
            self._mpv.command("cycle", "pause")  # type: ignore[attr-defined]
        except Exception:
            pass

    def seek(self, secs: float) -> None:
        if not self.is_ready:
            return
        try:
            self._mpv.command("seek", secs, "relative")  # type: ignore[attr-defined]
        except Exception:
            pass

    def set_speed(self, speed: float) -> None:
        if not self.is_ready:
            return
        try:
            self._mpv["speed"] = max(0.1, min(4.0, float(speed)))  # type: ignore[index]
        except Exception:
            pass

    def current_time(self) -> int:
        if not self.is_ready:
            return 0
        try:
            # python-mpv maps properties to attributes
            pos = getattr(self._mpv, "time_pos", None)
            return int(pos or 0)
        except Exception:
            return 0

    def stop(self) -> None:
        if not self.is_ready:
            return
        try:
            self._mpv.command("stop")  # type: ignore[attr-defined]
        except Exception:
            pass


--- FILE: ./src/whirltube/navigation_controller.py ---
from __future__ import annotations

import logging

import gi
gi.require_version("Gtk", "4.0")
gi.require_version("Adw", "1")
from gi.repository import Gtk

log = logging.getLogger(__name__)

class NavigationController:
    def __init__(self, stack: Gtk.Stack, btn_back: Gtk.Button) -> None:
        self.stack = stack
        self.btn_back = btn_back
        self._nav_stack: list[str] = []  # back stack of stack view names

        self.btn_back.connect("clicked", self.go_back)
        self._update_back_button_visibility()

    def _update_back_button_visibility(self) -> None:
        self.btn_back.set_visible(bool(self._nav_stack))

    def show_view(self, name: str) -> None:
        cur = self.stack.get_visible_child_name() or "results"
        if cur != name:
            self._nav_stack.append(cur)
        self.stack.set_visible_child_name(name)
        self._update_back_button_visibility()

    def go_back(self, *_a) -> None:
        if self._nav_stack:
            prev = self._nav_stack.pop()
            self.stack.set_visible_child_name(prev)
        else:
            self.stack.set_visible_child_name("results")
        self._update_back_button_visibility()

    def clear_history(self) -> None:
        self._nav_stack.clear()
        self._update_back_button_visibility()


--- FILE: ./src/whirltube/quickdownload.py ---
from __future__ import annotations

import os
from pathlib import Path

import gi

gi.require_version("Gtk", "4.0")
gi.require_version("Adw", "1")
from gi.repository import Adw, Gio, GLib, Gtk  # noqa: E402

from .util import load_settings, save_settings  # noqa: E402
from .ytdlp_runner import YtDlpRunner, parse_line  # noqa: E402


def _notify(summary: str) -> None:
    try:
        gi.require_version("Notify", "0.7")
        from gi.repository import Notify

        Notify.init("whirltube")
        n = Notify.Notification.new(summary)
        n.show()
    except Exception:
        pass

def _eta_fmt(eta: float | None) -> str:
    e = int(eta or 0)
    return f"{e//60:02}:{e%60:02}"

def _mb(b: float) -> str:
    mb = b / (1024**2)
    if mb > 1024:
        return f"{mb/1024:.2f}GB"
    return f"{mb:.2f}MB"

class QuickDownloadWindow(Gtk.Window):
    def __init__(self, parent: Gtk.Window) -> None:
        super().__init__(transient_for=parent, modal=True, title="Quick Download")
        self.set_default_size(820, 560)
        self.settings = load_settings()

        root = Adw.ToolbarView()
        self.set_child(root)
        header = Adw.HeaderBar()
        root.add_top_bar(header)

        self.tabview = Adw.TabView()

        # Top controls (URLs + progress)
        top = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8, margin_top=12, margin_bottom=12, margin_start=12, margin_end=12)
        top.append(Gtk.Label(label="Paste URLs (one per line)", xalign=0.0))
        self.url_view = Gtk.TextView()
        self.url_view.set_wrap_mode(Gtk.WrapMode.WORD)
        self.url_view.set_size_request(-1, 120)
        sw = Gtk.ScrolledWindow()
        sw.set_child(self.url_view)
        sw.set_vexpand(False)
        top.append(sw)

        self.msg = Gtk.Label(xalign=0)
        self.progress = Gtk.ProgressBar()
        prow = Gtk.Box(spacing=8)
        prow.append(self.msg)
        prow.append(Gtk.Label(label="", hexpand=True))
        prow.append(self.progress)
        top.append(prow)

        # Video tab
        vbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10, margin_top=12, margin_bottom=12, margin_start=12, margin_end=12)
        vgrid = Gtk.Grid(column_spacing=8, row_spacing=8)
        vgrid.attach(Gtk.Label(label="Resolution (-S res)", xalign=0), 0, 0, 1, 1)
        self.dd_res = Gtk.DropDown.new_from_strings(["2160 (4K)", "1440 (2K)", "1080", "720", "480", "360", "240", "144"])
        self.dd_res.set_selected(2)
        vgrid.attach(self.dd_res, 1, 0, 1, 1)
        vgrid.attach(Gtk.Label(label="Remux to", xalign=0), 0, 1, 1, 1)
        self.dd_vidfmt = Gtk.DropDown.new_from_strings(["mp4", "mkv", "webm"])
        self.dd_vidfmt.set_selected(0)
        vgrid.attach(self.dd_vidfmt, 1, 1, 1, 1)
        vbox.append(vgrid)
        self.entry_path_video = Gtk.Entry(
            text=self.settings.get("quick_video_dir", str(Path.home() / "Videos"))
        )
        vbox.append(self._common_path_controls(self.entry_path_video))
        vbox.append(self._controls_row())
        page_video = self.tabview.append(vbox)
        page_video.set_title("Video")

        # Audio tab
        abox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10, margin_top=12, margin_bottom=12, margin_start=12, margin_end=12)
        agrid = Gtk.Grid(column_spacing=8, row_spacing=8)
        agrid.attach(Gtk.Label(label="Audio format", xalign=0), 0, 0, 1, 1)
        self.dd_audfmt = Gtk.DropDown.new_from_strings(["mp3", "m4a", "opus", "vorbis", "wav"])
        self.dd_audfmt.set_selected(0)
        agrid.attach(self.dd_audfmt, 1, 0, 1, 1)
        agrid.attach(Gtk.Label(label="Audio quality (0 best .. 10 worst)", xalign=0), 0, 1, 1, 1)
        self.dd_audq = Gtk.DropDown.new_from_strings(["0 (Best)", "2 (Good)", "4 (Medium)", "6 (Low)"])
        self.dd_audq.set_selected(1)
        agrid.attach(self.dd_audq, 1, 1, 1, 1)
        abox.append(agrid)
        self.entry_path_audio = Gtk.Entry(
            text=self.settings.get("quick_audio_dir", str(Path.home() / "Music"))
        )
        abox.append(self._common_path_controls(self.entry_path_audio))
        abox.append(self._controls_row())
        page_audio = self.tabview.append(abox)
        page_audio.set_title("Audio")

        # Settings tab
        sbox = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=10, margin_top=12, margin_bottom=12, margin_start=12, margin_end=12)

        srow = Gtk.Box(spacing=6)
        srow.append(Gtk.Label(label="SponsorBlock:", xalign=0))
        self.dd_sb = Gtk.DropDown.new_from_strings(["Disabled", "Mark (default)", "Remove (default)"])
        self.dd_sb.set_selected(0)
        srow.append(self.dd_sb)
        self.chk_playlist = Gtk.CheckButton(label="Playlist mode")
        srow.append(self.chk_playlist)
        sbox.append(srow)

        crow = Gtk.Box(spacing=6)
        crow.append(Gtk.Label(label="Cookies file:", xalign=0))
        self.entry_cookies = Gtk.Entry()
        self.entry_cookies.set_text(self.settings.get("quick_cookies_path", "") or "")
        crow.append(self.entry_cookies)
        btn_cook = Gtk.Button(label="Browse")
        btn_cook.connect("clicked", self._on_browse_cookies)
        crow.append(btn_cook)
        sbox.append(crow)

        yrow = Gtk.Box(spacing=6)
        yrow.append(Gtk.Label(label="yt-dlp path:", xalign=0))
        self.entry_ytdlp = Gtk.Entry()
        self.entry_ytdlp.set_text(self.settings.get("ytdlp_path", "") or "")
        yrow.append(self.entry_ytdlp)
        btn_y = Gtk.Button(label="Browse")
        btn_y.connect("clicked", self._on_browse_ytdlp)
        yrow.append(btn_y)
        sbox.append(yrow)

        page_settings = self.tabview.append(sbox)
        page_settings.set_title("Settings")

        vcontainer = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        vcontainer.append(top)
        vcontainer.append(self.tabview)
        root.set_content(vcontainer)

        self.runner = YtDlpRunner(self._on_progress_line)

    def _common_path_controls(self, entry: Gtk.Entry) -> Gtk.Widget:
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=8)
        row = Gtk.Box(spacing=6)
        btn = Gtk.Button(label="Browse")
        btn.connect("clicked", lambda *_: self._on_browse_folder(entry))
        row.append(entry)
        row.append(btn)
        box.append(row)
        return box

    def _controls_row(self) -> Gtk.Widget:
        row = Gtk.Box(spacing=6)
        btn_dl = Gtk.Button(label="Download")
        btn_dl.connect("clicked", self._on_download)
        btn_stop = Gtk.Button(label="Stop")
        btn_stop.connect("clicked", self._on_stop)
        row.append(btn_dl)
        row.append(btn_stop)
        return row

    def _on_browse_folder(self, entry: Gtk.Entry, *_):
        dlg = Gtk.FileDialog(title="Choose folder")
        dlg.select_folder(self, None, self._on_folder_selected, entry)

    def _on_folder_selected(self, dlg: Gtk.FileDialog, res: Gio.AsyncResult, entry: Gtk.Entry):
        try:
            f = dlg.select_folder_finish(res)
            if f:
                entry.set_text(f.get_path() or "")
        except Exception:
            pass

    def _on_browse_cookies(self, *_):
        dlg = Gtk.FileDialog(title="Choose cookies file")
        dlg.open(self, None, self._on_cookies_selected, None)

    def _on_cookies_selected(self, dlg: Gtk.FileDialog, res: Gio.AsyncResult, _data):
        try:
            f = dlg.open_finish(res)
            if f:
                self.entry_cookies.set_text(f.get_path() or "")
        except Exception:
            pass

    def _on_browse_ytdlp(self, *_):
        dlg = Gtk.FileDialog(title="Choose yt-dlp binary")
        dlg.open(self, None, self._on_ytdlp_selected, None)

    def _on_ytdlp_selected(self, dlg: Gtk.FileDialog, res: Gio.AsyncResult, _data):
        try:
            f = dlg.open_finish(res)
            if f:
                self.entry_ytdlp.set_text(f.get_path() or "")
        except Exception:
            pass

    def _on_download(self, *_):
        buf = self.url_view.get_buffer()
        start = buf.get_start_iter()
        end = buf.get_end_iter()
        urls = [u.strip() for u in buf.get_text(start, end, False).splitlines() if u.strip()]
        if not urls:
            self._set_msg("No URLs")
            return

        page = self.tabview.get_selected_page()
        title = page.get_title()
        source_entry = self.entry_path_video if title == "Video" else self.entry_path_audio

        out_dir = os.path.expanduser(source_entry.get_text() or "")
        if not out_dir or not Path(out_dir).exists():
            self._set_msg("Invalid download folder")
            return

        # persist per-tab path and ytdlp_path (do not clobber global download_dir)
        if title == "Video":
            self.settings["quick_video_dir"] = out_dir
        else:
            self.settings["quick_audio_dir"] = out_dir

        self.settings["ytdlp_path"] = self.entry_ytdlp.get_text().strip()
        # also persist cookies path for convenience
        self.settings["quick_cookies_path"] = self.entry_cookies.get_text().strip()
        save_settings(self.settings)

        args: list[str] = []
        args += ["-P", out_dir]
        # Global proxy
        proxy = (self.settings.get("http_proxy") or "").strip()
        if proxy:
            args += ["--proxy", proxy]

        if title == "Video":
            sel = self.dd_res.get_selected()
            reslist = ["res:2160","res:1440","res:1080","res:720","res:480","res:360","res:240","res:144"]
            res = reslist[sel if sel >= 0 else 2]
            args += ["-S", res]
            fmt = ["mp4", "mkv", "webm"][self.dd_vidfmt.get_selected() or 0]
            args += ["--remux-video", fmt]
        else:
            fmt = ["mp3", "m4a", "opus", "vorbis", "wav"][self.dd_audfmt.get_selected() or 0]
            qual_map = ["0", "2", "4", "6"]
            aq = qual_map[self.dd_audq.get_selected() or 1]
            args += ["-x", "--audio-format", fmt, "--audio-quality", aq]

        # cookies file
        ck = self.entry_cookies.get_text().strip()
        if ck:
            args += ["--cookies", ck]

        # sponsorblock
        sb_idx = self.dd_sb.get_selected()
        if sb_idx == 1:
            args += ["--sponsorblock-mark", "default"]
        elif sb_idx == 2:
            args += ["--sponsorblock-remove", "default"]

        # playlist mode
        if self.chk_playlist.get_active():
            args += ["--yes-playlist", "-o", "%(playlist)s/%(title)s.%(ext)s"]
        else:
            args += [
                "--break-on-reject",
                "--match-filter",
                "!playlist",
                "--no-playlist",
                "-o",
                "%(title)s.%(ext)s",
            ]

        args += urls

        self.progress.set_fraction(0.0)
        self._set_msg("Initializingâ€¦")
        path = self.settings.get("ytdlp_path", "") or None
        self.runner.start(args, bin_path=path)
        # Watch for process exit, then mark end if not already stopped
        import threading
        def _watch():
            import time
            while self.runner.is_running():
                time.sleep(0.2)
            GLib.idle_add(self._end, ok="Done")
        threading.Thread(target=_watch, daemon=True).start()

    def _on_stop(self, *_):
        self.runner.stop()
        self.progress.set_fraction(0.0)
        self._set_msg("Stopped")

    def _on_progress_line(self, text: str) -> None:
        GLib.idle_add(self._handle_line, text)

    def _handle_line(self, text: str) -> bool:
        parsed = parse_line(text)
        if isinstance(parsed, Exception):
            self._end(error=str(parsed))
            return False
        if not parsed:
            return False
        for ev in parsed:
            if ev.kind == "downloading":
                d = float(ev.payload.get("downloaded_bytes") or 0.0)
                t = ev.payload.get("total_bytes") or ev.payload.get("total_bytes_estimate")
                total = float(t or 0.0)
                frac = (d / total) if total > 0 else 0.0
                self.progress.set_fraction(min(1.0, max(0.0, frac)))
                speed = float(ev.payload.get("speed") or 0.0)
                eta = float(ev.payload.get("eta") or 0.0)
                pc = ev.payload.get("playlist_count")
                pi = ev.payload.get("playlist_index")
                msg = f"{_mb(d)} | {speed/(1024**2):.2f}MB/s | ETA {_eta_fmt(eta)}"
                if pc and pi:
                    msg += f" {pi}/{pc}"
                self._set_msg(msg)
            elif ev.kind == "end_of_playlist":
                # Do not end early; wait for process exit
                pass
            elif ev.kind == "end_of_video":
                pass
        return False

    def _end(self, ok: str | None = None, error: str | None = None) -> None:
        self.runner.stop()
        if ok:
            self._set_msg(ok)
            _notify(ok)
        elif error:
            self._set_msg(error)
            _notify(error)

    def _set_msg(self, s: str) -> None:
        self.msg.set_label(s)


--- FILE: ./src/whirltube/search_filters.py ---
from __future__ import annotations

from typing import Any


def normalize_search_filters(settings: dict[str, Any]) -> tuple[str | None, str | None, str | None]:
    """
    Convert persisted settings to provider-friendly values:
      - order: 'relevance' -> None else 'date'|'views'
      - duration: 'any' -> None else 'short'|'medium'|'long'
      - period: 'any' -> None else 'today'|'week'|'month'
    Returns (order, duration, period)
    """
    ordv = str(settings.get("search_order", "relevance") or "relevance").strip().lower()
    durv = str(settings.get("search_duration", "any") or "any").strip().lower()
    perv = str(settings.get("search_period", "any") or "any").strip().lower()

    order = None if ordv == "relevance" else ordv
    duration = None if durv == "any" else durv
    period = None if perv == "any" else perv
    return order, duration, period

--- FILE: ./src/whirltube/subscriptions.py ---
from __future__ import annotations

import json
from dataclasses import dataclass
from pathlib import Path
from typing import Any

from .util import xdg_data_dir

import logging
log = logging.getLogger(__name__)

_SUBS_PATH = xdg_data_dir() / "subscriptions.json"

@dataclass(slots=True)
class Subscription:
    url: str
    title: str | None = None

def _load_raw() -> list[dict[str, Any]]:
    if not _SUBS_PATH.exists():
        return []
    try:
        data = json.loads(_SUBS_PATH.read_text(encoding="utf-8"))
        if isinstance(data, list):
            return [x for x in data if isinstance(x, dict)]
    except Exception:
        pass
    return []

def _save_raw(items: list[dict[str, Any]]) -> None:
    _SUBS_PATH.parent.mkdir(parents=True, exist_ok=True)
    tmp = _SUBS_PATH.with_suffix(".tmp")
    tmp.write_text(json.dumps(items, indent=2), encoding="utf-8")
    tmp.replace(_SUBS_PATH)

def list_subscriptions() -> list[Subscription]:
    out: list[Subscription] = []
    for it in _load_raw():
        url = (it.get("url") or "").strip()
        if not url:
            continue
        # normalize trailing /videos to channel root (keep as-is if not a channel)
        if "/channel/" in url and url.endswith("/videos"):
            url = url[:-7]
        title = (it.get("title") or None)
        out.append(Subscription(url=url, title=title))
    return out

def _norm(u: str) -> str:
    """Normalize URL by stripping trailing /videos from channel URLs."""
    if "/channel/" in u and u.endswith("/videos"):
        u = u[:-7]
    return u.strip()

def is_followed(url: str) -> bool:
    u = _norm(url or "")
    if not u:
        return False
    for it in _load_raw():
        if _norm(it.get("url") or "") == u:
            return True
    return False

def add_subscription(url: str, title: str | None = None) -> bool:
    u = (url or "").strip()
    if not u:
        return False
    data = _load_raw()
    for it in data:
        if (it.get("url") or "").strip() == u:
            return False  # already present
    data.append({"url": u, "title": title or None})
    _save_raw(data)
    return True

def remove_subscription(url: str) -> bool:
    u = _norm(url or "")
    if not u:
        return False
    data = _load_raw()
    new = [it for it in data if _norm(it.get("url") or "") != u]
    if len(new) == len(data):
        return False
    _save_raw(new)
    return True
def export_subscriptions(dest: Path) -> bool:
    """
    Write current subscriptions to dest as pretty JSON.
    Returns True on success.
    """
    try:
        items = _load_raw()
        dest.parent.mkdir(parents=True, exist_ok=True)
        tmp = dest.with_suffix(".tmp")
        tmp.write_text(json.dumps(items, indent=2), encoding="utf-8")
        tmp.replace(dest)
        return True
    except Exception:
        return False

def import_subscriptions(src: Path) -> int:
    """
    Merge subscriptions from src (list of {url, title}) with existing ones.
    Returns number of new entries added.
    """
    try:
        data = json.loads(src.read_text(encoding="utf-8"))
        if not isinstance(data, list):
            return 0
        existing = _load_raw()
        have = { (it.get("url") or "").strip() for it in existing if isinstance(it, dict) }
        added = 0
        for it in data:
            if not isinstance(it, dict):
                continue
            u = (it.get("url") or "").strip()
            if not u or u in have:
                continue
            existing.append({"url": u, "title": (it.get("title") or None)})
            have.add(u)
            added += 1
        if added:
            _save_raw(existing)
        return added
    except Exception:
        return 0


--- FILE: ./src/whirltube/history.py ---
from __future__ import annotations

import json
import time
from typing import Any

from .models import Video
from .util import xdg_cache_dir

_CACHE = xdg_cache_dir()
SEARCH = _CACHE / "search_history.txt"
WATCH = _CACHE / "watch_history.jsonl"


def add_search_term(query: str) -> None:
    q = query.strip()
    if not q:
        return
    SEARCH.parent.mkdir(parents=True, exist_ok=True)
    ts = time.strftime("%Y-%m-%d %H:%M:%S %z", time.localtime())
    with SEARCH.open("a", encoding="utf-8") as f:
        f.write(f"{ts}\t{q}\n")


def add_watch(video: Video) -> None:
    WATCH.parent.mkdir(parents=True, exist_ok=True)
    data = {
        "id": video.id,
        "title": video.title,
        "url": video.url,
        "channel": video.channel,
        "duration": video.duration,
        "thumb_url": video.thumb_url,
        "kind": video.kind,
        "ts": int(time.time()),
    }
    with WATCH.open("a", encoding="utf-8") as f:
        f.write(json.dumps(data, ensure_ascii=False) + "\n")


def list_watch(limit: int = 200) -> list[Video]:
    if not WATCH.exists():
        return []
    out: list[Video] = []
    lines = WATCH.read_text(encoding="utf-8").splitlines()
    for line in reversed(lines):
        if not line.strip():
            continue
        try:
            it: dict[str, Any] = json.loads(line)
            out.append(
                Video(
                    id=str(it.get("id") or ""),
                    title=it.get("title") or "",
                    url=it.get("url") or "",
                    channel=it.get("channel"),
                    duration=it.get("duration"),
                    thumb_url=it.get("thumb_url"),
                    kind=it.get("kind") or "video",
                )
            )
            if len(out) >= limit:
                break
        except Exception:
            continue
    return out


def list_search_history(limit: int = 20) -> list[str]:
    """
    Get recent unique search terms for autocomplete.
    
    Args:
        limit: Maximum number of terms to return
        
    Returns:
        List of search terms, most recent first
    """
    if not SEARCH.exists():
        return []
    
    try:
        lines = SEARCH.read_text(encoding="utf-8").splitlines()
        
        # Extract search terms (skip timestamp)
        terms = []
        seen = set()
        
        # Process in reverse (most recent first)
        for line in reversed(lines):
            if not line.strip():
                continue
            
            # Format: "TIMESTAMP\tQUERY"
            parts = line.split('\t', 1)
            if len(parts) == 2:
                term = parts[1].strip()
                # Only add if we haven't seen it (dedup)
                if term and term not in seen:
                    terms.append(term)
                    seen.add(term)
                    
                    if len(terms) >= limit:
                        break
        
        return terms
        
    except Exception as e:
        from .util import log
        log.debug(f"Failed to list search history: {e}")
        return []


def search_history_suggestions(prefix: str, limit: int = 10) -> list[str]:
    """
    Get search suggestions based on prefix matching.
    
    Args:
        prefix: Search prefix to match
        limit: Maximum suggestions to return
        
    Returns:
        List of matching search terms
    """
    if not prefix or not prefix.strip():
        # Return recent searches if no prefix
        return list_search_history(limit)
    
    prefix_lower = prefix.strip().lower()
    all_terms = list_search_history(limit * 3)  # Get more to filter
    
    # Filter by prefix match
    matches = [term for term in all_terms if term.lower().startswith(prefix_lower)]
    
    return matches[:limit]


def clear_search_history() -> int:
    """
    Clear all search history.
    
    Returns:
        Number of entries cleared
    """
    if not SEARCH.exists():
        return 0
    
    try:
        count = len(SEARCH.read_text(encoding="utf-8").splitlines())
        SEARCH.unlink()
        from .util import log
        log.info(f"Cleared {count} search history entries")
        return count
    except Exception as e:
        from .util import log
        log.exception(f"Failed to clear search history: {e}")
        return 0


def get_search_history_count() -> int:
    """
    Get count of search history entries.
    
    Returns:
        Number of searches
    """
    if not SEARCH.exists():
        return 0
    
    try:
        return len([line for line in SEARCH.read_text(encoding="utf-8").splitlines() if line.strip()])
    except Exception:
        return 0


--- FILE: ./src/whirltube/download_history.py ---
from __future__ import annotations

import json
import time
from dataclasses import asdict, dataclass
from pathlib import Path
from typing import Any

from .models import Video
from .util import xdg_data_dir

_DL = xdg_data_dir() / "download_history.jsonl"

@dataclass(slots=True)
class DownloadEntry:
    id: str
    title: str
    url: str
    channel: str | None
    duration: int | None
    thumb_url: str | None
    kind: str
    dest_dir: str
    filename: str | None
    ts: int

def add_download(video: Video, dest_dir: Path, filename: str | None) -> None:
    _DL.parent.mkdir(parents=True, exist_ok=True)
    e = DownloadEntry(
        id=video.id,
        title=video.title,
        url=video.url,
        channel=video.channel,
        duration=video.duration,
        thumb_url=video.thumb_url,
        kind=video.kind,
        dest_dir=str(dest_dir),
        filename=filename,
        ts=int(time.time()),
    )
    with _DL.open("a", encoding="utf-8") as f:
        f.write(json.dumps(asdict(e), ensure_ascii=False) + "\n")

def list_downloads(limit: int = 300) -> list[Video]:
    if not _DL.exists():
        return []
    out: list[Video] = []
    lines = _DL.read_text(encoding="utf-8").splitlines()
    for line in reversed(lines):
        if not line.strip():
            continue
        try:
            it: dict[str, Any] = json.loads(line)
            out.append(
                Video(
                    id=str(it.get("id") or ""),
                    title=it.get("title") or "",
                    url=it.get("url") or "",
                    channel=it.get("channel"),
                    duration=it.get("duration"),
                    thumb_url=it.get("thumb_url"),
                    kind=str(it.get("kind") or "video"),
                )
            )
            if len(out) >= limit:
                break
        except Exception:
            continue
    return out


--- FILE: ./src/whirltube/dialogs.py ---
from __future__ import annotations

import logging
from dataclasses import dataclass
from pathlib import Path
import shlex
from typing import Any, Callable

import gi
gi.require_version("Gtk", "4.0")
gi.require_version("Adw", "1")
from gi.repository import Adw, Gio, Gtk

from .util import load_settings, save_settings, xdg_data_dir, safe_httpx_proxy

log = logging.getLogger(__name__)


@dataclass(slots=True)
class DownloadOptions:
    # quality
    quality_mode: str = "highest"  # highest | lowest | custom
    custom_format: str | None = None
    sort_string: str = ""  # yt-dlp -S format-sort string

    # subtitles
    write_subs: bool = False
    subs_langs: str = ""  # e.g. "en,es"
    write_auto_subs: bool = False
    subs_format: str = "vtt"  # vtt/srt/best

    # sponsorblock
    sb_mark: str = ""  # e.g. "sponsor,intro"
    sb_remove: str = ""  # e.g. "selfpromo"

    # embedding/thumbnail
    embed_metadata: bool = False
    embed_thumbnail: bool = False
    write_thumbnail: bool = False

    # cookies
    use_cookies: bool = False
    cookies_browser: str = ""  # firefox/chromium/brave/edge/...
    cookies_keyring: str = ""  # gnomekeyring/kwallet...
    cookies_profile: str = ""  # profile name/path
    cookies_container: str = ""  # firefox container name

    # network
    limit_rate: str = ""  # e.g. "4M"
    concurrent_fragments: int = 0  # yt-dlp -N
    impersonate: str = ""  # e.g. "chrome-110"

    # misc
    extra_flags: str = ""  # raw yt-dlp flags (forces subprocess)
    target_dir: Path | None = None

    def to_ydl_opts(self) -> dict:
        """Options mapping for Python API path (limited set)."""
        opts: dict = {
            "quiet": True,
            "nocheckcertificate": True,
            "merge_output_format": "mp4",
        }

        # quality
        if self.quality_mode == "highest":
            opts["format"] = "bv*+ba/b"
        elif self.quality_mode == "lowest":
            opts["format"] = "worst"
        elif self.quality_mode == "custom" and self.custom_format:
            opts["format"] = self.custom_format

        # format sort
        if self.sort_string.strip():
            opts["format_sort"] = self.sort_string.strip()

        # subtitles
        if self.write_subs:
            opts["writesubtitles"] = True
            if self.subs_langs.strip():
                langs = [s.strip() for s in self.subs_langs.split(",") if s.strip()]
                if langs:
                    opts["subtitleslangs"] = langs
            if self.write_auto_subs:
                opts["writeautomaticsub"] = True
            if self.subs_format:
                opts["subtitlesformat"] = self.subs_format

        # Note: many advanced flags are easier via CLI; see raw_cli_list().
        return opts

    def raw_cli_list(self) -> list[str]:
        """Build yt-dlp CLI args equivalent to all selected options."""
        parts: list[str] = []

        # quality
        if self.quality_mode == "highest":
            parts += ["-f", "bv*+ba/b"]
        elif self.quality_mode == "lowest":
            parts += ["-f", "worst"]
        elif self.quality_mode == "custom" and self.custom_format:
            parts += ["-f", self.custom_format]

        # format sort
        if self.sort_string.strip():
            parts += ["-S", self.sort_string.strip()]

        # subtitles
        if self.write_subs:
            parts += ["--write-subs"]
        if self.write_auto_subs:
            parts += ["--write-auto-subs"]
        if self.subs_langs.strip():
            parts += ["--sub-langs", self.subs_langs.strip()]
        if self.subs_format.strip():
            parts += ["--sub-format", self.subs_format.strip()]

        # sponsorblock
        if self.sb_mark.strip():
            parts += ["--sponsorblock-mark", self.sb_mark.strip()]
        if self.sb_remove.strip():
            parts += ["--sponsorblock-remove", self.sb_remove.strip()]

        # embedding / thumbnail
        if self.embed_metadata:
            parts += ["--embed-metadata"]
        if self.embed_thumbnail:
            parts += ["--embed-thumbnail"]
        if self.write_thumbnail:
            parts += ["--write-thumbnail"]

        # cookies
        if self.use_cookies and self.cookies_browser.strip():
            c = self.cookies_browser.strip()
            if self.cookies_keyring.strip():
                c += f"+{self.cookies_keyring.strip()}"
            prof = self.cookies_profile.strip()
            cont = self.cookies_container.strip()
            
            # Handle profile and container correctly
            if prof and cont:
                c += f":{prof}::{cont}"
            elif prof:
                c += f":{prof}"
            elif cont:
                c += f"::{cont}"
            
            parts += ["--cookies-from-browser", c]

        # network
        if self.limit_rate.strip():
            parts += ["--limit-rate", self.limit_rate.strip()]
        if self.concurrent_fragments > 0:
            parts += ["-N", str(self.concurrent_fragments)]
        if self.impersonate.strip():
            parts += ["--impersonate", self.impersonate.strip()]

        # extra
        if self.extra_flags.strip():
            parts += shlex.split(self.extra_flags.strip())
        return parts


class DownloadOptionsWindow(Adw.Window):
    def __init__(self, parent: Gtk.Window, title: str) -> None:
        super().__init__(transient_for=parent, modal=True, title=f"Download: {title}")
        self.set_default_size(600, 700)

        root = Adw.ToolbarView()
        self.set_content(root)
        header = Adw.HeaderBar()
        root.add_top_bar(header)

        # Main box (scrollable content)
        main_box = Gtk.Box(
            orientation=Gtk.Orientation.VERTICAL,
            spacing=12,
            margin_top=12,
            margin_bottom=12,
            margin_start=12,
            margin_end=12,
        )
        
        # Quality tab
        quality_group = Adw.PreferencesGroup(title="Quality")
        main_box.append(quality_group)
        
        # Quality mode
        self.quality_mode = Adw.ComboRow(
            title="Quality",
            model=Gtk.StringList.new(["Highest", "Lowest", "Custom"]),
        )
        self.quality_mode.set_selected(0)
        quality_group.add(self.quality_mode)
        
        # Custom format (when quality=custom)
        self.custom_format_row = Adw.EntryRow(title="Custom format")
        self.custom_format_row.set_visible(False)
        quality_group.add(self.custom_format_row)
        
        # Sort string
        self.sort_string_row = Adw.EntryRow(title="Format sort string (e.g. res:1080,res)")
        quality_group.add(self.sort_string_row)
        
        # Subtitles group
        subs_group = Adw.PreferencesGroup(title="Subtitles")
        main_box.append(subs_group)
        
        self.write_subs = Adw.SwitchRow(title="Download subtitles")
        subs_group.add(self.write_subs)
        
        self.subs_langs = Adw.EntryRow(title="Subtitle languages (comma-separated)")
        self.subs_langs.set_text("en")
        subs_group.add(self.subs_langs)
        
        self.write_auto_subs = Adw.SwitchRow(title="Download auto-generated subtitles")
        subs_group.add(self.write_auto_subs)
        
        self.subs_format_row = Adw.ComboRow(
            title="Subtitle format",
            model=Gtk.StringList.new(["vtt", "srt", "best"]),
        )
        self.subs_format_row.set_selected(0)
        subs_group.add(self.subs_format_row)
        
        # Sponsorblock group
        sb_group = Adw.PreferencesGroup(title="SponsorBlock")
        main_box.append(sb_group)
        
        self.sb_mark_row = Adw.EntryRow(title="Categories to mark (comma-separated)")
        sb_group.add(self.sb_mark_row)
        
        self.sb_remove_row = Adw.EntryRow(title="Categories to remove (comma-separated)")
        sb_group.add(self.sb_remove_row)
        
        # Embedding group
        embed_group = Adw.PreferencesGroup(title="Embedding")
        main_box.append(embed_group)
        
        self.embed_metadata = Adw.SwitchRow(title="Embed metadata")
        embed_group.add(self.embed_metadata)
        
        self.embed_thumbnail = Adw.SwitchRow(title="Embed thumbnail")
        embed_group.add(self.embed_thumbnail)
        
        self.write_thumbnail = Adw.SwitchRow(title="Save thumbnail as separate file")
        embed_group.add(self.write_thumbnail)
        
        # Cookies group
        cookies_group = Adw.PreferencesGroup(title="Cookies")
        main_box.append(cookies_group)
        
        self.use_cookies = Adw.SwitchRow(title="Use cookies")
        cookies_group.add(self.use_cookies)
        
        self.cookies_browser = Adw.ComboRow(
            title="Browser",
            model=Gtk.StringList.new(["firefox", "chromium", "brave", "edge"]),
        )
        self.cookies_browser.set_selected(0)
        cookies_group.add(self.cookies_browser)
        
        self.cookies_keyring = Adw.EntryRow(title="Keyring (optional)")
        cookies_group.add(self.cookies_keyring)
        
        self.cookies_profile = Adw.EntryRow(title="Profile (optional)")
        cookies_group.add(self.cookies_profile)
        
        self.cookies_container = Adw.EntryRow(title="Container (Firefox; optional)")
        cookies_group.add(self.cookies_container)
        
        # Network group
        net_group = Adw.PreferencesGroup(title="Network")
        main_box.append(net_group)
        
        self.limit_rate = Adw.EntryRow(title="Rate limit (e.g. 1M, 100K)")
        net_group.add(self.limit_rate)
        
        self.concurrent_fragments = Adw.SpinRow.new_with_range(0, 16, 1)
        self.concurrent_fragments.set_title("Concurrent fragments")
        self.concurrent_fragments.set_value(0)
        net_group.add(self.concurrent_fragments)
        
        self.impersonate = Adw.EntryRow(title="Impersonate browser (e.g. chrome-110)")
        net_group.add(self.impersonate)
        
        # Advanced flags
        flag_group = Adw.PreferencesGroup(title="Advanced")
        main_box.append(flag_group)
        
        self.extra_flags = Adw.EntryRow(title="Extra yt-dlp flags")
        flag_group.add(self.extra_flags)
        
        # Format selection (with fetch button)
        format_group = Adw.PreferencesGroup(title="Formats")
        main_box.append(format_group)
        
        format_row = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        self.format_combo = Gtk.DropDown.new_from_strings(["Select a format..."])
        # Disabled until formats are fetched
        self.format_combo.set_sensitive(False)
        format_row.append(self.format_combo)
        self.btn_fetch = Gtk.Button(label="Fetch formats")
        format_row.append(self.btn_fetch)
        # Inline spinner + status for fetch
        self._fmt_spinner = Gtk.Spinner()
        self._fmt_spinner.set_visible(False)
        format_row.append(self._fmt_spinner)
        self._fmt_status = Gtk.Label(label="", xalign=0.0)
        self._fmt_status.add_css_class("dim-label")
        format_row.append(self._fmt_status)
        format_action = Adw.ActionRow()
        format_action.set_title("Available formats")
        format_action.set_child(format_row)
        format_group.add(format_action)
        
        # When user selects a specific format, force Quality to "Custom" for clarity
        self.format_combo.connect("notify::selected", self._on_format_selected)
        
        # Target directory
        dir_group = Adw.PreferencesGroup(title="Destination")
        main_box.append(dir_group)
        
        self.target_dir = Adw.EntryRow(title="Download directory")
        self.target_dir.set_text(str(Path.home() / "Downloads"))
        dir_group.add(self.target_dir)
        
        # Connect quality mode change to show/hide custom format
        self.quality_mode.connect("notify::selected", self._on_quality_mode_changed)
        
        # Scrollable content
        scroller = Gtk.ScrolledWindow()
        scroller.set_policy(Gtk.PolicyType.NEVER, Gtk.PolicyType.AUTOMATIC)
        scroller.set_vexpand(True)
        scroller.set_child(main_box)
        root.set_content(scroller)

        # Bottom bar with actions (always visible)
        btn_cancel = Gtk.Button(label="Cancel")
        btn_cancel.connect("clicked", lambda *_: self.destroy())
        btn_download = Gtk.Button(label="Download", css_classes=["suggested-action"])
        btn_download.connect("clicked", self._on_download)
        # Make Download the default action (Enter)
        try:
            btn_download.set_can_default(True)
            # GTK4: set default widget on the window
            self.set_default_widget(btn_download)  # type: ignore[attr-defined]
        except Exception:
            try:
                btn_download.grab_default()
            except Exception:
                pass

        footer = Adw.HeaderBar()
        footer.pack_start(btn_cancel)
        footer.pack_end(btn_download)
        root.add_bottom_bar(footer)
        
        # Internal state
        self._accepted = False
        self._selected_format_id = None
        self._format_map: dict[str, str] = {}
        # Wire cookies sensitivity
        self._wire_cookies_sensitive()

        # End of constructor

    def _on_quality_mode_changed(self, combo: Adw.ComboRow, _pspec) -> None:
        is_custom = combo.get_selected() == 2  # "Custom" option
        self.custom_format_row.set_visible(is_custom)

    def _on_format_selected(self, drop: Gtk.DropDown, _pspec) -> None:
        if drop.get_selected() > 0:
            # Switch UI to "Custom" and reveal the custom format row for transparency
            self.quality_mode.set_selected(2)
            self.custom_format_row.set_visible(True)

    def _on_download(self, _btn) -> None:
        self._accepted = True
        self.destroy()

    # --- Formats fetch UX helpers ---
    def begin_format_fetch(self) -> None:
        try:
            self.btn_fetch.set_sensitive(False)
        except Exception:
            pass
        self._fmt_status.set_text("Fetching formatsâ€¦")
        self._fmt_spinner.set_visible(True)
        try:
            self._fmt_spinner.start()
        except Exception:
            pass

    def _end_format_fetch(self) -> None:
        try:
            self._fmt_spinner.stop()
        except Exception:
            pass
        self._fmt_spinner.set_visible(False)
        self._fmt_status.set_text("")
        try:
            self.btn_fetch.set_sensitive(True)
        except Exception:
            pass

    # --- Cookies enable/disable wiring ---
    def _wire_cookies_sensitive(self) -> None:
        def _apply_sensitive() -> None:
            on = self.use_cookies.get_active()
            self.cookies_browser.set_sensitive(on)
            self.cookies_keyring.set_sensitive(on)
            self.cookies_profile.set_sensitive(on)
            self.cookies_container.set_sensitive(on)

        # Initialize and connect
        _apply_sensitive()
        try:
            self.use_cookies.connect("notify::active", lambda *_: _apply_sensitive())
        except Exception:
            pass

    def get_options(self) -> tuple[bool, DownloadOptions]:
        """Returns (accepted, options)"""
        if not self._accepted:
            return False, DownloadOptions()
        
        # Get the selected format if available
        format_idx = self.format_combo.get_selected()
        format_id: str | None = None
        if format_idx > 0:  # Skip the "Select a format..." option
            model = self.format_combo.get_model()
            selected_str: str | None = None
            try:
                if isinstance(model, Gtk.StringList):
                    selected_str = model.get_string(format_idx)
            except Exception:
                selected_str = None
            
            if selected_str and selected_str in self._format_map:
                format_id = self._format_map[selected_str]
            elif selected_str and selected_str != "Select a format...":
                # Format was selected but not in map - log warning
                log.warning(f"Selected format '{selected_str}' not found in format map")
        
        # Get custom format or selected format
        custom_format = None
        if self.custom_format_row.get_visible():
            custom_format = self.custom_format_row.get_text().strip()
        
        # Priority: custom_format from visible row > format_id from dropdown > None
        if not custom_format and format_id:
            custom_format = str(format_id)
        # If a specific format was chosen from the list, treat it as "Custom" quality
        quality_idx = int(self.quality_mode.get_selected())
        if format_id and quality_idx != 2:
            quality_idx = 2
        
        # Target dir
        td = self.target_dir.get_text().strip()
        target_dir = Path(td) if td else None

        opts = DownloadOptions(
            quality_mode=["highest", "lowest", "custom"][quality_idx],
            custom_format=custom_format,
            sort_string=self.sort_string_row.get_text().strip(),
            write_subs=self.write_subs.get_active(),
            subs_langs=self.subs_langs.get_text().strip(),
            write_auto_subs=self.write_auto_subs.get_active(),
            subs_format=["vtt", "srt", "best"][int(self.subs_format_row.get_selected())],
            sb_mark=self.sb_mark_row.get_text().strip(),
            sb_remove=self.sb_remove_row.get_text().strip(),
            embed_metadata=self.embed_metadata.get_active(),
            embed_thumbnail=self.embed_thumbnail.get_active(),
            write_thumbnail=self.write_thumbnail.get_active(),
            use_cookies=self.use_cookies.get_active(),
            cookies_browser=["firefox", "chromium", "brave", "edge"][int(self.cookies_browser.get_selected())],
            cookies_keyring=self.cookies_keyring.get_text().strip(),
            cookies_profile=self.cookies_profile.get_text().strip(),
            cookies_container=self.cookies_container.get_text().strip(),
            limit_rate=self.limit_rate.get_text().strip(),
            concurrent_fragments=int(self.concurrent_fragments.get_value()),
            impersonate=self.impersonate.get_text().strip(),
            extra_flags=self.extra_flags.get_text().strip(),
            target_dir=target_dir,
        )
        return True, opts

    def set_formats(self, formats: list[tuple[str, str]]) -> None:
        """Update the format dropdown with available formats."""
        # Always end fetch UI state on return to main loop
        self._end_format_fetch()
        if not formats:
            # Keep dropdown disabled if nothing available
            self.format_combo.set_sensitive(False)
            # Reset model just in case
            self.format_combo.set_model(Gtk.StringList.new(["Select a format..."]))
            return

        # Create new model with "Select a format..." as first option
        strings = ["Select a format..."] + [f"{fmt_id}: {fmt_label}" for fmt_id, fmt_label in formats]
        model = Gtk.StringList.new(strings)
        self.format_combo.set_model(model)
        # Enable dropdown now that we have content
        self.format_combo.set_sensitive(True)

        # Store the mapping
        self._format_map = {f"{fmt_id}: {fmt_label}": fmt_id for fmt_id, fmt_label in formats}

class PreferencesWindow(Adw.PreferencesWindow):
    def __init__(self, parent: Gtk.Window, settings: dict) -> None:
        super().__init__(transient_for=parent, modal=True, title="Preferences")
        self.settings = settings
        self.set_search_enabled(False)

        # Playback page
        page_play = Adw.PreferencesPage(title="Playback")
        group_play = Adw.PreferencesGroup(title="Player")
        page_play.add(group_play)

        # Provider page
        page_provider = Adw.PreferencesPage(title="Provider")

        # Auto-hide MPV controls
        self.autohide_controls = Adw.SwitchRow(
            title="Auto-hide MPV controls outside Player view"
        )
        self.autohide_controls.set_active(bool(settings.get("mpv_autohide_controls", False)))
        group_play.add(self.autohide_controls)

        # Playback mode
        self.playback_mode = Adw.ComboRow(
            title="Default playback mode",
            model=Gtk.StringList.new([
                "External MPV (separate window)",
                "In-window (X11) / Integrated (Wayland)"
            ]),
        )
        mode_val = settings.get("playback_mode", "external")
        self.playback_mode.set_selected(0 if mode_val == "external" else 1)
        group_play.add(self.playback_mode)

        # Playback quality
        self.playback_quality = Adw.ComboRow(
            title="Preferred playback quality",
            model=Gtk.StringList.new(["Auto (best)", "2160p", "1440p", "1080p", "720p", "480p", "360p", "240p", "144p"]),
        )
        quality_val = settings.get("mpv_quality", "auto")
        quality_idx = {"auto": 0, "2160": 1, "1440": 2, "1080": 3, "720": 4, "480": 5, "360": 6, "240": 7, "144": 8}.get(
            quality_val, 0
        )
        self.playback_quality.set_selected(quality_idx)
        group_play.add(self.playback_quality)

        # Extra MPV args
        self.mpv_args = Adw.EntryRow(title="MPV extra args")
        self.mpv_args.set_text(settings.get("mpv_args", ""))
        group_play.add(self.mpv_args)

        # Cookies group for MPV
        cookies_group = Adw.PreferencesGroup(title="MPV cookies (optional)")
        page_play.add(cookies_group)

        self.cookies_enable = Adw.SwitchRow(title="Pass browser cookies to MPV")
        self.cookies_enable.set_active(bool(settings.get("mpv_cookies_enable", False)))
        cookies_group.add(self.cookies_enable)

        self.cmb_browser = Adw.ComboRow(
            title="Browser",
            model=Gtk.StringList.new(["", "firefox", "chromium", "brave", "edge"]),
        )
        browser = (settings.get("mpv_cookies_browser") or "").strip()
        try:
            self.cmb_browser.set_selected(["", "firefox", "chromium", "brave", "edge"].index(browser))
        except ValueError:
            self.cmb_browser.set_selected(0)
        cookies_group.add(self.cmb_browser)

        self.entry_keyring = Adw.EntryRow(title="Keyring (optional)")
        self.entry_keyring.set_text(settings.get("mpv_cookies_keyring", ""))
        cookies_group.add(self.entry_keyring)

        self.entry_profile = Adw.EntryRow(title="Profile (optional)")
        self.entry_profile.set_text(settings.get("mpv_cookies_profile", ""))
        cookies_group.add(self.entry_profile)

        self.entry_container = Adw.EntryRow(title="Container (Firefox; optional)")
        self.entry_container.set_text(settings.get("mpv_cookies_container", ""))
        cookies_group.add(self.entry_container)

        # SponsorBlock (Playback)
        sb_group = Adw.PreferencesGroup(title="SponsorBlock (Playback)")
        page_play.add(sb_group)

        self.sb_enable = Adw.SwitchRow(title="Enable SponsorBlock during playback")
        self.sb_enable.set_active(bool(settings.get("sb_playback_enable", False)))
        sb_group.add(self.sb_enable)

        self.sb_mode = Adw.ComboRow(
            title="Action",
            model=Gtk.StringList.new([
                "Mark chapters",
                "Auto-skip (if script present)",
            ]),
        )
        mode_val = (settings.get("sb_playback_mode") or "mark").strip().lower()
        self.sb_mode.set_selected(1 if mode_val in ("skip", "autoskip") else 0)
        sb_group.add(self.sb_mode)

        self.sb_categories = Adw.EntryRow(title="Categories (yt-dlp syntax)")
        self.sb_categories.set_text(settings.get("sb_playback_categories", "default"))
        self.sb_categories.set_tooltip_text(
            "e.g. default, or sponsor,intro,outro. See yt-dlp --sponsorblock-mark help."
        )
        sb_group.add(self.sb_categories)

        # Provider group (Invidious)
        group_provider = Adw.PreferencesGroup(title="Invidious")
        page_provider.add(group_provider)
        self.use_invidious = Adw.SwitchRow(title="Use Invidious backend for search/channel")
        self.use_invidious.set_active(bool(settings.get("use_invidious", False)))
        group_provider.add(self.use_invidious)

        self.entry_invidious = Adw.EntryRow(title="Invidious instance")
        self.entry_invidious.set_text(settings.get("invidious_instance", "https://yewtu.be"))
        group_provider.add(self.entry_invidious)

        # Invidious Account (authentication)
        group_account = Adw.PreferencesGroup(title="Invidious Account (Optional)")
        page_provider.add(group_account)
        
        self.btn_inv_connect = Adw.ActionRow(title="Connect Account")
        connect_btn = Gtk.Button(label="Authorize")
        connect_btn.connect("clicked", self._on_inv_authorize)
        self.btn_inv_connect.add_suffix(connect_btn)
        group_account.add(self.btn_inv_connect)
        
        # Status label
        self.lbl_inv_status = Gtk.Label(label="Not connected")
        self.lbl_inv_status.set_halign(Gtk.Align.END)
        self.btn_inv_connect.add_suffix(self.lbl_inv_status)
        
        # Test token on load
        self._test_inv_token()

        # Downloads page
        page_dl = Adw.PreferencesPage(title="Downloads")
        group_dl = Adw.PreferencesGroup(title="Location")
        page_dl.add(group_dl)

        self.download_button = Adw.ActionRow(title="Download directory")
        self._download_dir_label = Gtk.Label(label=settings.get("download_dir", ""), xalign=1.0)
        self.download_button.add_suffix(self._download_dir_label)
        self.download_button.set_activatable(True)
        self.download_button.connect("activated", self._choose_dir)
        group_dl.add(self.download_button)

        # After completion
        group_after = Adw.PreferencesGroup(title="After completion")
        page_dl.add(group_after)
        self.sw_auto_open = Adw.SwitchRow(title="Open download folder when a download finishes")
        self.sw_auto_open.set_active(bool(settings.get("download_auto_open_folder", False)))
        group_after.add(self.sw_auto_open)

        # Filename template
        self.entry_template = Adw.EntryRow(title="Filename template")
        self.entry_template.set_text(settings.get("download_template", "%(title)s.%(ext)s"))
        self.entry_template.set_tooltip_text("yt-dlp template, e.g. %(title)s.%(ext)s or %(uploader)s/%(title)s.%(ext)s")
        group_dl.add(self.entry_template)

        # NEW: Quick quality presets
        self.entry_quick_presets = Adw.EntryRow(title="Quick download buttons")
        self.entry_quick_presets.set_text(settings.get("quick_quality_presets", "1080p,720p,audio"))
        self.entry_quick_presets.set_tooltip_text("Comma-separated: 2160p,1440p,1080p,720p,480p,audio")
        group_dl.add(self.entry_quick_presets)

        # NEW: SponsorBlock page
        page_sb = Adw.PreferencesPage(title="SponsorBlock")
        group_sb_cats = Adw.PreferencesGroup(title="Skipped categories")
        page_sb.add(group_sb_cats)

        # SponsorBlock category toggles
        self.sb_cat_checks: dict[str, Gtk.CheckButton] = {}
        current_cats = (settings.get("sb_skip_categories") or "sponsor").split(",")
        # from https://wiki.sponsor.ajay.app/w/Categories
        for cat_id, cat_name in [
            ("sponsor", "Sponsor"),
            ("selfpromo", "Self-promotion"),
            ("interaction", "Interaction reminder"),
            ("intro", "Intro"),
            ("outro", "Outro"),
            ("preview", "Preview/Recap"),
            ("music_offtopic", "Music/Off-topic"),
            ("poi_highlight", "Highlight"),
        ]:
            row = Adw.SwitchRow(title=cat_name)
            row.set_active(cat_id in current_cats)
            group_sb_cats.add(row)
            self.sb_cat_checks[cat_id] = row
        
        # Add page
        self.add(page_sb)

        # Network (global)
        group_net = Adw.PreferencesGroup(title="Network")
        page_dl.add(group_net)
        self.entry_proxy = Adw.EntryRow(title="HTTP(S) proxy (optional)")
        self.entry_proxy.set_text(settings.get("http_proxy", ""))
        group_net.add(self.entry_proxy)

        # Queue / concurrency
        group_queue = Adw.PreferencesGroup(title="Queue")
        page_dl.add(group_queue)
        self.spin_concurrent = Adw.SpinRow.new_with_range(1, 8, 1)
        self.spin_concurrent.set_title("Max concurrent downloads")
        try:
            self.spin_concurrent.set_value(float(int(settings.get("max_concurrent_downloads", 3) or 3)))
        except Exception:
            self.spin_concurrent.set_value(3.0)
        group_queue.add(self.spin_concurrent)

        self.add(page_play)
        self.add(page_provider)
        self.add(page_dl)

        self.connect("close-request", self._on_close)

    def _choose_dir(self, *_a) -> None:
        dlg = Gtk.FileDialog(title="Choose download folder")
        dlg.set_modal(True)
        dlg.select_folder(self, None, self._on_folder_chosen, None)

    def _on_folder_chosen(self, dialog: Gtk.FileDialog, res: Gio.AsyncResult, _data) -> None:
        try:
            f = dialog.select_folder_finish(res)
        except Exception:
            return
        path = f.get_path() or ""
        self._download_dir_label.set_text(path)

    def _on_close(self, *_a) -> bool:
        sel = self.playback_mode.get_selected()
        self.settings["playback_mode"] = "external" if sel == 0 else "embedded"
        self.settings["mpv_args"] = self.mpv_args.get_text()
        self.settings["download_dir"] = self._download_dir_label.get_text()

        qsel = self.playback_quality.get_selected()
        qmap = {0: "auto", 1: "2160", 2: "1440", 3: "1080", 4: "720", 5: "480"}
        self.settings["mpv_quality"] = qmap.get(qsel, "auto")

        self.settings["mpv_cookies_enable"] = self.cookies_enable.get_active()
        browsers = ["", "firefox", "chromium", "brave", "edge"]
        bsel = self.cmb_browser.get_selected()
        self.settings["mpv_cookies_browser"] = browsers[bsel] if 0 <= bsel < len(browsers) else ""
        self.settings["mpv_cookies_keyring"] = self.entry_keyring.get_text()
        self.settings["mpv_cookies_profile"] = self.entry_profile.get_text()
        self.settings["mpv_cookies_container"] = self.entry_container.get_text()
        # SponsorBlock (Playback)
        self.settings["sb_playback_enable"] = bool(self.sb_enable.get_active())
        self.settings["sb_playback_mode"] = (
            "skip" if int(self.sb_mode.get_selected() or 0) == 1 else "mark"
        )
        self.settings["sb_playback_categories"] = self.sb_categories.get_text().strip() or "default"
        # Global proxy
        self.settings["http_proxy"] = self.entry_proxy.get_text()
        # Concurrency
        self.settings["max_concurrent_downloads"] = int(self.spin_concurrent.get_value())
        # Provider settings
        self.settings["use_invidious"] = bool(self.use_invidious.get_active())
        self.settings["invidious_instance"] = self.entry_invidious.get_text().strip() or "https://yewtu.be"
        # Auto-hide MPV controls
        self.settings["mpv_autohide_controls"] = bool(self.autohide_controls.get_active())
        # After completion + template
        self.settings["download_auto_open_folder"] = bool(self.sw_auto_open.get_active())
        self.settings["download_template"] = self.entry_template.get_text().strip() or "%(title)s.%(ext)s"
        self.settings["quick_quality_presets"] = self.entry_quick_presets.get_text().strip() or "1080p,720p,audio"
        
        # NEW: Invidious Auth Token
        # Save to secure storage if available
        token = getattr(self, "_invidious_token", "")
        if token:
            try:
                from .invidious_auth import InvidiousAuth
                # Try to use secure storage
                auth = InvidiousAuth("")
                if auth._set_secure_token(token):
                    # Successfully saved to secure storage, clear from plain text settings
                    self.settings["invidious_token"] = ""
                else:
                    # Fall back to plain text storage
                    self.settings["invidious_token"] = token
            except Exception:
                # Fall back to plain text storage
                self.settings["invidious_token"] = token
        else:
            # Clear token
            try:
                from .invidious_auth import InvidiousAuth
                auth = InvidiousAuth("")
                auth._delete_secure_token()
            except Exception:
                pass
            self.settings["invidious_token"] = ""
        
        # NEW: SponsorBlock settings
        
        # Save selected categories
        selected_cats = []
        for cat_id, check in self.sb_cat_checks.items():
            if check.get_active():
                selected_cats.append(cat_id)
        self.settings["sb_skip_categories"] = ",".join(selected_cats)
        
        return False

    def _test_inv_token(self) -> None:
        """Test if there's a valid token and update UI status"""
        # Try to get token from secure storage first
        try:
            from .invidious_auth import InvidiousAuth
            auth = InvidiousAuth("")
            token = auth._get_secure_token()
            
            if not token:
                # Fall back to plain text settings
                token = self.settings.get("invidious_token", "")
            
            if token:
                self.lbl_inv_status.set_text("âœ“ Connected")
                self._invidious_token = token
            else:
                self.lbl_inv_status.set_text("Not connected")
        except Exception:
            # Fall back to plain text settings
            token = self.settings.get("invidious_token", "")
            if token:
                self.lbl_inv_status.set_text("âœ“ Connected")
                self._invidious_token = token
            else:
                self.lbl_inv_status.set_text("Not connected")

    def _on_inv_authorize(self, _btn) -> None:
        """Handle Invidious authorization button click"""
        try:
            from .invidious_auth import InvidiousAuth, is_valid_invidious_instance
            
            instance_url = self.entry_invidious.get_text().strip()
            if not instance_url:
                self.lbl_inv_status.set_text("âœ— Please enter an instance URL")
                return
            
            if not is_valid_invidious_instance(instance_url):
                self.lbl_inv_status.set_text("âœ— Invalid Invidious instance")
                return
            
            # Create auth instance and request token
            auth = InvidiousAuth(instance_url)
            scopes = [":feed", "GET:subscriptions", "POST:subscriptions*", "DELETE:subscriptions*"]
            
            token = auth.request_token(scopes)
            if token:
                self._invidious_token = token
                self.lbl_inv_status.set_text("âœ“ Connected")
                # Will save in _on_close when settings are saved
            else:
                self.lbl_inv_status.set_text("âœ— Authorization failed")
        except Exception as e:
            import logging
            logging.exception("Invidious auth failed")
            self.lbl_inv_status.set_text(f"âœ— Error: {str(e)[:30]}")

--- FILE: ./src/whirltube/util.py ---
from __future__ import annotations

import json
import os
from pathlib import Path
from typing import Any, Iterable
from urllib.parse import urlparse
import logging
import httpx

log = logging.getLogger(__name__)

APP_NAME = "whirltube"

def xdg_config_dir() -> Path:
    base = os.environ.get("XDG_CONFIG_HOME", str(Path.home() / ".config"))
    p = Path(base) / APP_NAME
    p.mkdir(parents=True, exist_ok=True)
    return p

def xdg_cache_dir() -> Path:
    base = os.environ.get("XDG_CACHE_HOME", str(Path.home() / ".cache"))
    p = Path(base) / APP_NAME
    p.mkdir(parents=True, exist_ok=True)
    return p

def xdg_data_dir() -> Path:
    base = os.environ.get("XDG_DATA_HOME", str(Path.home() / ".local" / "share"))
    p = Path(base) / APP_NAME
    p.mkdir(parents=True, exist_ok=True)
    return p

def settings_path() -> Path:
    return xdg_config_dir() / "settings.json"

def _download_archive_path() -> Path:
    """Return the path to the yt-dlp download archive file."""
    return xdg_data_dir() / "download_archive.txt"

def load_settings() -> dict[str, Any]:
    p = settings_path()
    if p.exists():
        try:
            return json.loads(p.read_text(encoding="utf-8"))
        except Exception:
            return {}
    return {}

def save_settings(data: dict[str, Any]) -> None:
    p = settings_path()
    tmp = p.with_suffix(".tmp")
    tmp.write_text(json.dumps(data, indent=2), encoding="utf-8")
    tmp.replace(p)

def safe_httpx_proxy(val: str | None, test: bool = False) -> str | None:
    """
    Validate a proxy string for httpx. Returns a usable proxy string or None.
    Accepts schemes: http, https, socks4, socks5, socks5h.
    """
    if not val:
        return None
    s = val.strip()
    try:
        u = urlparse(s)
    except Exception:
        return None
    
    scheme = (u.scheme or "").lower()
    if scheme not in {"http", "https", "socks4", "socks5", "socks5h"}:
        return None
    
    # Validate netloc exists and has a port (optional for some schemes, but safer to check)
    if not (u.netloc or u.hostname):
        return None
    
    # Validate port (if present)
    if u.port is not None and (u.port <= 0 or u.port > 65535):
        return None
    
    # Optional: test connectivity
    if test:
        try:
            log.debug("Testing proxy connectivity to google.com via %s", s)
            with httpx.Client(proxies={"all://": s}, timeout=5) as client:
                # Use a known-good, non-redirecting endpoint
                client.get("https://www.google.com/generate_204")
        except Exception as e:
            log.debug("Proxy test failed for %s: %s", s, e)
            return None
    
    return s

def is_valid_youtube_url(url: str, allowed_hosts: Iterable[str] | None = None) -> bool:
    """
    Return True if the URL is http(s) and points to YouTube/YouTu.be or an explicitly
    allowed host (e.g., an Invidious instance). This is a light validation to help
    users avoid pasting arbitrary or unsupported URLs into "Open URLâ€¦".
    """
    if not url or not isinstance(url, str):
        return False
    try:
        u = urlparse(url.strip())
    except Exception:
        return False
    if (u.scheme or "").lower() not in {"http", "https"}:
        return False
    host = (u.hostname or "").lower().strip()
    if not host:
        return False
    # Core YouTube hosts
    if host.endswith("youtube.com") or host == "youtu.be" or host.endswith("youtube-nocookie.com"):
        return True
    # Extra allowed hosts (e.g., Invidious)
    if allowed_hosts:
        suffixes = [h.lower().strip() for h in allowed_hosts if isinstance(h, str) and h.strip()]
        for suf in suffixes:
            # accept exact or subdomain match
            if host == suf or host.endswith("." + suf):
                return True
    return False


--- FILE: ./src/whirltube/invidious_auth.py ---
"""Invidious Authentication API wrapper for subscription sync, live feed, and account features."""
from __future__ import annotations
import httpx
import webbrowser
import logging
from http.server import HTTPServer, BaseHTTPRequestHandler
from urllib.parse import parse_qs, urlparse

# Try to import keyring for secure token storage
try:
    import keyring
    HAS_KEYRING = True
except ImportError:
    HAS_KEYRING = False
    keyring = None

log = logging.getLogger(__name__)

class InvidiousAuth:
    def __init__(self, instance_url: str):
        self.base = instance_url.rstrip("/")
        self.token: str | None = None
        self._callback_port = 8899  # Local server port for auth callback
        self._service_name = "whirltube"
        self._username = "invidious_token"
    
    def _get_secure_token(self) -> str | None:
        """Get token from secure storage if available."""
        if HAS_KEYRING and keyring:
            try:
                return keyring.get_password(self._service_name, self._username)
            except Exception as e:
                log.warning(f"Failed to get token from keyring: {e}")
        return None
    
    def _set_secure_token(self, token: str) -> bool:
        """Store token in secure storage if available."""
        if HAS_KEYRING and keyring and token:
            try:
                keyring.set_password(self._service_name, self._username, token)
                return True
            except Exception as e:
                log.warning(f"Failed to store token in keyring: {e}")
        return False
    
    def _delete_secure_token(self) -> bool:
        """Delete token from secure storage if available."""
        if HAS_KEYRING and keyring:
            try:
                keyring.delete_password(self._service_name, self._username)
                return True
            except Exception as e:
                log.warning(f"Failed to delete token from keyring: {e}")
        return False
    
    def request_token(self, scopes: list[str], expire: int = 31536000) -> str:
        """
        Open browser for user to authorize token.
        Starts local server to receive callback.
        
        scopes examples:
            [":feed"]  # Access to feed
            ["GET:subscriptions", "POST:subscriptions*"]  # Manage subs
            [":*"]  # Full access (not recommended)
        """
        callback_url = f"http://localhost:{self._callback_port}/callback"
        
        # Build authorization URL
        params = {
            "scopes": ",".join(scopes),
            "callback_url": callback_url,
            "expire": expire
        }
        auth_url = f"{self.base}/authorize_token"
        
        # Build full URL
        import urllib.parse
        query_string = "&".join(f"{k}={urllib.parse.quote(str(v))}" for k, v in params.items())
        full_url = f"{auth_url}?{query_string}"
        
        log.info(f"Opening authorization URL: {full_url}")
        
        # Open browser
        webbrowser.open(full_url)
        
        # Start local server to receive callback
        token_received = []
        
        class CallbackHandler(BaseHTTPRequestHandler):
            def do_GET(self):
                try:
                    query = parse_qs(urlparse(self.path).query)
                    if "token" in query:
                        received_token = query["token"][0]
                        token_received.append(received_token)
                        
                        # Send success response to browser
                        self.send_response(200)
                        self.send_header("Content-type", "text/html")
                        self.end_headers()
                        self.wfile.write(b"""
                        <html>
                          <head><title>Authorization Success</title></head>
                          <body>
                            <h1>Success!</h1>
                            <p>You can now close this window.</p>
                          </body>
                        </html>
                        """)
                    else:
                        self.send_response(400)
                        self.send_header("Content-type", "text/plain")
                        self.end_headers()
                        self.wfile.write(b"Bad request: no token")
                except Exception as e:
                    log.error(f"Error in auth callback: {e}")
                    self.send_response(500)
                    self.end_headers()
                    self.wfile.write(b"Internal error")
            
            def log_message(self, format, *args):
                # Suppress server logs
                pass
        
        server = HTTPServer(("localhost", self._callback_port), CallbackHandler)
        
        # Wait for callback (timeout after 5 minutes)
        import time
        timeout = time.time() + 300  # 5 minutes
        while not token_received and time.time() < timeout:
            # Handle requests with 1-second timeout to allow checking timeout
            server.handle_request()
        
        if token_received:
            self.token = token_received[0]
            log.info("Authorization successful, token received")
            return self.token
        else:
            raise TimeoutError("Authorization timeout - please try again")
    
    def _make_auth_request(self, method: str, endpoint: str, **kwargs) -> httpx.Response:
        """Make an authenticated request to Invidious API."""
        if not self.token:
            raise RuntimeError("Not authenticated - no token available")
        
        headers = kwargs.get("headers", {})
        headers["Authorization"] = f"Bearer {self.token}"
        kwargs["headers"] = headers
        
        url = f"{self.base}{endpoint}"
        
        with httpx.Client(timeout=15.0) as client:
            response = client.request(method, url, **kwargs)
            response.raise_for_status()
            return response
    
    def get_feed(self, max_results: int = 60) -> list[dict]:
        """Get authenticated subscription feed - much faster than polling channels!"""
        try:
            response = self._make_auth_request(
                "GET", 
                "/api/v1/auth/feed",
                params={"max_results": max_results}
            )
            data = response.json()
            
            # Combine notifications and videos 
            videos = data.get("videos", [])
            notifications = data.get("notifications", [])
            
            # Return combined list (notifications first)
            return notifications + videos
        except Exception as e:
            log.error(f"Failed to get authenticated feed: {e}")
            # Fallback to empty list rather than crashing
            return []
    
    def get_subscriptions(self) -> list[dict]:
        """Get user's subscriptions from Invidious account."""
        response = self._make_auth_request("GET", "/api/v1/auth/subscriptions")
        return response.json()
    
    def subscribe(self, ucid: str) -> bool:
        """Subscribe to a channel via Invidious account."""
        try:
            self._make_auth_request("POST", f"/api/v1/auth/subscriptions/{ucid}")
            return True
        except Exception as e:
            log.error(f"Failed to subscribe to {ucid}: {e}")
            return False
    
    def unsubscribe(self, ucid: str) -> bool:
        """Unsubscribe from a channel via Invidious account."""
        try:
            self._make_auth_request("DELETE", f"/api/v1/auth/subscriptions/{ucid}")
            return True
        except Exception as e:
            log.error(f"Failed to unsubscribe from {ucid}: {e}")
            return False
    
    def get_channel_videos(self, ucid: str, sort: str = "newest") -> list[dict]:
        """Get recent videos from a specific subscribed channel."""
        response = self._make_auth_request(
            "GET", 
            f"/api/v1/auth/channels/{ucid}/videos",
            params={"sort": sort}
        )
        return response.json()
    
    def mark_watched(self, video_id: str) -> bool:
        """Mark a video as watched on Invidious account."""
        try:
            self._make_auth_request("POST", f"/api/v1/auth/history/{video_id}")
            return True
        except Exception as e:
            log.error(f"Failed to mark video {video_id} as watched: {e}")
            return False
    
    def get_watch_history(self) -> list[dict]:
        """Get watch history from Invidious account."""
        response = self._make_auth_request("GET", "/api/v1/auth/history")
        return response.json()


def is_valid_invidious_instance(url: str) -> bool:
    """Check if the given URL is a valid Invidious instance."""
    try:
        import urllib.parse
        parsed = urllib.parse.urlparse(url)
        if not parsed.scheme or not parsed.netloc:
            return False
        
        # Remove trailing slash
        clean_url = url.rstrip("/")
        
        # Test if instance is working
        with httpx.Client(timeout=10.0) as client:
            response = client.get(f"{clean_url}/api/v1/stats", headers={"User-Agent": "WhirlTube/1.0"})
            response.raise_for_status()
            
            # Basic check: response should be JSON with required fields
            data = response.json()
            required_fields = {"version", "openRegistrations", "totalUsers", "totalSubscriptions"}
            return all(field in data for field in required_fields)
    except Exception:
        return False

--- FILE: ./src/whirltube/logging_config.py ---
import logging
import sys
from .util import xdg_cache_dir


def setup_logging(debug: bool = False):
    level = logging.DEBUG if debug else logging.INFO

    # Console handler
    console = logging.StreamHandler(sys.stderr)
    console.setFormatter(logging.Formatter(
        '%(asctime)s [%(levelname)s] %(name)s: %(message)s'
    ))

    # File handler (always at DEBUG level)
    log_file = xdg_cache_dir() / "whirltube.log"
    file_handler = logging.FileHandler(log_file, encoding='utf-8')
    file_handler.setLevel(logging.DEBUG)
    file_handler.setFormatter(logging.Formatter(
        '%(asctime)s [%(levelname)s] %(name)s:%(lineno)d: %(message)s'
    ))

    root = logging.getLogger()
    root.setLevel(logging.DEBUG)
    root.addHandler(console)
    root.addHandler(file_handler)

    console.setLevel(level)

    logging.info(f"Logging to {log_file}")

--- FILE: ./src/whirltube/metrics.py ---
import time
import logging
from contextlib import contextmanager

log = logging.getLogger(__name__)

@contextmanager
def timed(operation: str):
    start = time.perf_counter()
    try:
        yield
    finally:
        elapsed = time.perf_counter() - start
        log.info(f"{operation} took {elapsed:.3f}s")

--- FILE: ./src/whirltube/mpv_gl.py ---
from __future__ import annotations

import logging
import locale
from typing import Optional, Mapping, Any

import gi
gi.require_version("Gtk", "4.0")
from gi.repository import Gtk, GLib

log = logging.getLogger(__name__)

try:
    import mpv  # python-mpv must have opengl-cb
    from OpenGL import GL
    HAS_GL = True
except Exception:
    HAS_GL = False
    mpv = None  # type: ignore

class MpvGLWidget(Gtk.GLArea):
    def __init__(self):
        super().__init__()
        self.set_hexpand(True)
        self.set_vexpand(True)
        self._mpv: Optional[mpv.MPV] = None
        self._gl_cb: Optional[mpv.opengl_cb.GLCallback] = None
        self._ready = False
        self.connect("realize", self._on_realize)
        self.connect("unrealize", self._on_unrealize)
        self.connect("render", self._on_render)

    def _on_realize(self, *_a):
        if not HAS_GL:
            log.warning("python-mpv or PyOpenGL missing; GL embed unavailable")
            return
        try:
            locale.setlocale(locale.LC_NUMERIC, "C")
        except Exception:
            pass
        self.make_current()
        if self.get_error():
            log.error("GLArea error; cannot initialize")
            return
        try:
            # Use 'gpu' vo for opengl-cb
            self._mpv = mpv.MPV(vo='gpu', keep_open=True)
            self._gl_cb = mpv.opengl_cb.GLCallback(self._mpv)

            def _get_proc_address(name: str) -> int:
                addr = self.get_proc_address(name)
                return addr or 0

            self._gl_cb.set_get_proc_address(_get_proc_address)
            self._gl_cb.set_update_callback(lambda: GLib.idle_add(self.queue_render))
            self._gl_cb.init_gl()
            self._ready = True
            log.info("MpvGLWidget initialized")
        except Exception as e:
            log.exception("Failed to init MpvGLWidget: %s", e)
            self._ready = False

    def _on_unrealize(self, *_a):
        try:
            if self._gl_cb:
                self.make_current()
                self._gl_cb.uninit_gl()
        except Exception:
            pass
        try:
            if self._mpv:
                self._mpv.terminate()
        except Exception:
            pass
        self._mpv = None
        self._gl_cb = None
        self._ready = False

    def _on_render(self, area: Gtk.GLArea, _ctx) -> bool:
        if not self._ready or not self._gl_cb:
            return False
        w = area.get_allocated_width()
        h = area.get_allocated_height()
        GL.glViewport(0, 0, w, h)
        GL.glClearColor(0.05, 0.05, 0.05, 1.0)
        GL.glClear(GL.GL_COLOR_BUFFER_BIT)
        try:
            self._gl_cb.draw()
        except Exception as e:
            log.debug("GL draw failed: %s", e)
        return True

    @property
    def is_ready(self) -> bool:
        return bool(self._ready and self._mpv)

    def set_ytdl_format(self, fmt: Optional[str]) -> None:
        if self.is_ready and fmt:
            try:
                self._mpv["ytdl-format"] = fmt  # type: ignore[index]
            except Exception:
                pass

    def set_ytdl_raw_options(self, opts: Optional[Mapping[str, Any]]) -> None:
        if self.is_ready and opts:
            try:
                self._mpv["ytdl-raw-options"] = dict(opts)  # type: ignore[index]
            except Exception:
                pass

    def play(self, url: str) -> bool:
        if self.is_ready and self._mpv:
            try:
                self._mpv.play(url)  # type: ignore[attr-defined]
                return True
            except Exception as e:
                log.debug("mpv.play failed: %s", e)
        return False

    def pause_toggle(self) -> None:
        if self.is_ready:
            try:
                self._mpv.command("cycle", "pause")  # type: ignore[attr-defined]
            except Exception:
                pass

    def seek(self, secs: float) -> None:
        if self.is_ready:
            try:
                self._mpv.command("seek", secs, "relative")  # type: ignore[attr-defined]
            except Exception:
                pass

    def set_speed(self, speed: float) -> None:
        if self.is_ready:
            try:
                self._mpv["speed"] = max(0.1, min(4.0, float(speed)))  # type: ignore[index]
            except Exception:
                pass

    def current_time(self) -> int:
        if not self.is_ready:
            return 0
        try:
            pos = getattr(self._mpv, "time_pos", None)
            return int(pos or 0)
        except Exception:
            return 0

    def stop(self) -> None:
        if self.is_ready:
            try:
                self._mpv.command("stop")  # type: ignore[attr-defined]
            except Exception:
                pass


--- FILE: ./src/whirltube/quick_quality.py ---
"""Quick quality download presets."""
from __future__ import annotations

from pathlib import Path

from .dialogs import DownloadOptions


# Preset configurations
QUALITY_PRESETS = {
    "2160p": {
        "label": "4K",
        "tooltip": "Download in 4K (2160p)",
        "format": "bv*[height<=2160]+ba/b[height<=2160]",
        "sort": "res:2160",
    },
    "1440p": {
        "label": "2K",
        "tooltip": "Download in 2K (1440p)",
        "format": "bv*[height<=1440]+ba/b[height<=1440]",
        "sort": "res:1440",
    },
    "1080p": {
        "label": "1080p",
        "tooltip": "Download in Full HD (1080p)",
        "format": "bv*[height<=1080]+ba/b[height<=1080]",
        "sort": "res:1080",
    },
    "720p": {
        "label": "720p",
        "tooltip": "Download in HD (720p)",
        "format": "bv*[height<=720]+ba/b[height<=720]",
        "sort": "res:720",
    },
    "480p": {
        "label": "480p",
        "tooltip": "Download in SD (480p)",
        "format": "bv*[height<=480]+ba/b[height<=480]",
        "sort": "res:480",
    },
    "audio": {
        "label": "ðŸŽµ Audio",
        "tooltip": "Download audio only (best quality)",
        "format": "ba/b",
        "audio_only": True,
    },
}


def get_quick_quality_options(quality_key: str, target_dir: Path | None = None) -> DownloadOptions:
    """
    Get DownloadOptions for a quality preset.
    
    Args:
        quality_key: One of "2160p", "1440p", "1080p", "720p", "480p", "audio"
        target_dir: Optional target directory override
        
    Returns:
        DownloadOptions configured for the preset
    """
    preset = QUALITY_PRESETS.get(quality_key)
    if not preset:
        # Default to 1080p if invalid key
        preset = QUALITY_PRESETS["1080p"]
    
    opts = DownloadOptions(
        quality_mode="custom",
        custom_format=preset["format"],
        sort_string=preset.get("sort", ""),
        target_dir=target_dir,
    )
    
    # For audio-only, add extraction flags
    if preset.get("audio_only"):
        opts.extra_flags = "-x --audio-format mp3 --audio-quality 0"
    
    return opts


def get_enabled_presets(setting_value: str | None = None) -> list[str]:
    """
    Get list of enabled quality presets.
    
    Args:
        setting_value: Comma-separated preset keys, or None for defaults
        
    Returns:
        List of preset keys in order
    """
    if setting_value:
        # Parse user setting
        presets = [p.strip() for p in setting_value.split(",") if p.strip()]
        # Validate all presets exist
        return [p for p in presets if p in QUALITY_PRESETS]
    
    # Default presets
    return ["1080p", "720p", "audio"]


def get_preset_label(quality_key: str) -> str:
    """Get display label for preset"""
    return QUALITY_PRESETS.get(quality_key, {}).get("label", quality_key)


def get_preset_tooltip(quality_key: str) -> str:
    """Get tooltip for preset"""
    return QUALITY_PRESETS.get(quality_key, {}).get("tooltip", f"Download in {quality_key}")

--- FILE: ./src/whirltube/subscription_feed.py ---
from __future__ import annotations
import json
from .util import xdg_data_dir

_WATCHED = xdg_data_dir() / "watched_videos.json"

def _load() -> dict[str, bool]:
    if not _WATCHED.exists():
        return {}
    try:
        return json.loads(_WATCHED.read_text(encoding="utf-8"))
    except Exception:
        return {}

def _save(data: dict):
    _WATCHED.parent.mkdir(parents=True, exist_ok=True)
    _WATCHED.write_text(json.dumps(data), encoding="utf-8")

def is_watched(video_id: str) -> bool:
    return _load().get(video_id, False)

def mark_as_watched(video_id: str):
    data = _load()
    data[video_id] = True
    _save(data)

def mark_as_unwatched(video_id: str):
    data = _load()
    data.pop(video_id, None)
    _save(data)

--- FILE: ./src/whirltube/thumbnail_cache.py ---
"""Thumbnail caching system to reduce bandwidth and improve performance."""
from __future__ import annotations

import hashlib
import logging
import time
from pathlib import Path
from typing import Optional

from .util import xdg_cache_dir

log = logging.getLogger(__name__)

CACHE_DIR = xdg_cache_dir() / "thumbnails"
CACHE_MAX_AGE_DAYS = 30  # Clean thumbnails older than 30 days
CACHE_MAX_SIZE_MB = 500  # Maximum cache size in MB


def _ensure_cache_dir() -> None:
    """Ensure cache directory exists"""
    try:
        CACHE_DIR.mkdir(parents=True, exist_ok=True)
    except Exception as e:
        log.warning(f"Failed to create thumbnail cache directory: {e}")


def _get_cache_path(url: str) -> Path:
    """
    Get cache file path for a thumbnail URL.
    
    Args:
        url: Thumbnail URL
        
    Returns:
        Path to cached file
    """
    # Use MD5 hash of URL as filename
    cache_key = hashlib.md5(url.encode('utf-8')).hexdigest()
    return CACHE_DIR / f"{cache_key}.jpg"


def get_cached_thumbnail(url: str) -> Optional[Path]:
    """
    Get cached thumbnail path if it exists and is valid.
    
    Args:
        url: Thumbnail URL
        
    Returns:
        Path to cached file if valid, None otherwise
    """
    if not url:
        return None
    
    try:
        cache_path = _get_cache_path(url)
        
        if not cache_path.exists():
            return None
        
        # Check file is not empty
        if cache_path.stat().st_size == 0:
            log.debug(f"Cached thumbnail is empty, removing: {cache_path}")
            cache_path.unlink()
            return None
        
        # Check file is not too old (optional freshness check)
        age_days = (time.time() - cache_path.stat().st_mtime) / 86400
        if age_days > CACHE_MAX_AGE_DAYS:
            log.debug(f"Cached thumbnail expired ({age_days:.1f} days old): {cache_path}")
            cache_path.unlink()
            return None
        
        log.debug(f"Thumbnail cache hit: {url[:50]}...")
        return cache_path
        
    except Exception as e:
        log.debug(f"Error checking thumbnail cache: {e}")
        return None


def cache_thumbnail(url: str, data: bytes) -> Optional[Path]:
    """
    Save thumbnail data to cache.
    
    Args:
        url: Thumbnail URL
        data: Thumbnail image data
        
    Returns:
        Path to cached file, or None on failure
    """
    if not url or not data:
        return None
    
    try:
        _ensure_cache_dir()
        cache_path = _get_cache_path(url)
        
        # Write atomically using temporary file
        tmp_path = cache_path.with_suffix('.tmp')
        tmp_path.write_bytes(data)
        tmp_path.replace(cache_path)
        
        log.debug(f"Cached thumbnail ({len(data)} bytes): {url[:50]}...")
        return cache_path
        
    except Exception as e:
        log.warning(f"Failed to cache thumbnail: {e}")
        return None


def get_cache_size() -> int:
    """
    Get total size of thumbnail cache in bytes.
    
    Returns:
        Cache size in bytes
    """
    if not CACHE_DIR.exists():
        return 0
    
    try:
        total = 0
        for path in CACHE_DIR.iterdir():
            if path.is_file():
                total += path.stat().st_size
        return total
    except Exception as e:
        log.debug(f"Error calculating cache size: {e}")
        return 0


def clear_cache() -> int:
    """
    Clear all cached thumbnails.
    
    Returns:
        Number of files removed
    """
    if not CACHE_DIR.exists():
        return 0
    
    try:
        count = 0
        for path in CACHE_DIR.iterdir():
            if path.is_file():
                path.unlink()
                count += 1
        log.info(f"Cleared {count} cached thumbnails")
        return count
    except Exception as e:
        log.error(f"Failed to clear cache: {e}")
        return 0


def cleanup_old_cache() -> int:
    """
    Remove thumbnails older than CACHE_MAX_AGE_DAYS.
    
    Returns:
        Number of files removed
    """
    if not CACHE_DIR.exists():
        return 0
    
    try:
        count = 0
        cutoff = time.time() - (CACHE_MAX_AGE_DAYS * 86400)
        
        for path in CACHE_DIR.iterdir():
            if path.is_file() and path.stat().st_mtime < cutoff:
                path.unlink()
                count += 1
        
        if count > 0:
            log.info(f"Cleaned up {count} old cached thumbnails")
        return count
    except Exception as e:
        log.error(f"Failed to cleanup old cache: {e}")
        return 0


def enforce_cache_size_limit() -> int:
    """
    Remove oldest thumbnails if cache exceeds size limit.
    
    Returns:
        Number of files removed
    """
    if not CACHE_DIR.exists():
        return 0
    
    try:
        max_bytes = CACHE_MAX_SIZE_MB * 1024 * 1024
        current_size = get_cache_size()
        
        if current_size <= max_bytes:
            return 0
        
        # Get all files sorted by modification time (oldest first)
        files = []
        for path in CACHE_DIR.iterdir():
            if path.is_file():
                files.append((path.stat().st_mtime, path.stat().st_size, path))
        
        files.sort()
        
        # Remove oldest files until under limit
        count = 0
        for mtime, size, path in files:
            if current_size <= max_bytes:
                break
            path.unlink()
            current_size -= size
            count += 1
        
        if count > 0:
            log.info(f"Removed {count} thumbnails to enforce size limit")
        return count
        
    except Exception as e:
        log.error(f"Failed to enforce cache size limit: {e}")
        return 0


def get_cache_stats() -> dict[str, any]:
    """
    Get statistics about the thumbnail cache.
    
    Returns:
        Dictionary with cache statistics
    """
    if not CACHE_DIR.exists():
        return {
            'file_count': 0,
            'total_size_bytes': 0,
            'total_size_mb': 0.0,
            'oldest_file_age_days': 0.0,
        }
    
    try:
        files = list(CACHE_DIR.iterdir())
        file_count = len([f for f in files if f.is_file()])
        total_size = get_cache_size()
        
        oldest_age = 0.0
        if file_count > 0:
            oldest_mtime = min(f.stat().st_mtime for f in files if f.is_file())
            oldest_age = (time.time() - oldest_mtime) / 86400
        
        return {
            'file_count': file_count,
            'total_size_bytes': total_size,
            'total_size_mb': round(total_size / (1024 * 1024), 2),
            'oldest_file_age_days': round(oldest_age, 1),
        }
    except Exception as e:
        log.debug(f"Error getting cache stats: {e}")
        return {
            'file_count': 0,
            'total_size_bytes': 0,
            'total_size_mb': 0.0,
            'oldest_file_age_days': 0.0,
        }

--- FILE: ./src/whirltube/watch_later.py ---
"""Watch Later queue management."""
from __future__ import annotations

import json
import logging
import time

from .models import Video
from .util import xdg_data_dir

log = logging.getLogger(__name__)

_WATCH_LATER = xdg_data_dir() / "watch_later.jsonl"


def add_to_watch_later(video: Video) -> bool:
    """
    Add video to watch later queue.
    
    Args:
        video: Video to add
        
    Returns:
        True if added, False if already exists
    """
    try:
        _WATCH_LATER.parent.mkdir(parents=True, exist_ok=True)
        
        # Check if already exists
        if is_in_watch_later(video.id):
            log.debug(f"Video {video.id} already in watch later")
            return False
        
        data = {
            "id": video.id,
            "title": video.title,
            "url": video.url,
            "channel": video.channel,
            "duration": video.duration,
            "thumb_url": video.thumb_url,
            "kind": video.kind,
            "added": int(time.time()),
        }
        
        with _WATCH_LATER.open("a", encoding="utf-8") as f:
            f.write(json.dumps(data, ensure_ascii=False) + "\n")
        
        log.info(f"Added to watch later: {video.title}")
        return True
    except Exception as e:
        log.exception(f"Failed to add to watch later: {e}")
        return False


def remove_from_watch_later(video_id: str) -> bool:
    """
    Remove video from watch later queue.
    
    Args:
        video_id: Video ID to remove
        
    Returns:
        True if removed, False if not found
    """
    if not _WATCH_LATER.exists():
        return False
    
    try:
        lines = _WATCH_LATER.read_text(encoding="utf-8").splitlines()
        new_lines = []
        removed = False
        
        for line in lines:
            if not line.strip():
                continue
            try:
                data = json.loads(line)
                if data.get("id") != video_id:
                    new_lines.append(line)
                else:
                    removed = True
                    log.info(f"Removed from watch later: {video_id}")
            except json.JSONDecodeError:
                # Keep malformed lines to avoid data loss
                new_lines.append(line)
        
        if removed:
            # Write atomically
            tmp = _WATCH_LATER.with_suffix(".tmp")
            tmp.write_text("\n".join(new_lines) + ("\n" if new_lines else ""), encoding="utf-8")
            tmp.replace(_WATCH_LATER)
        
        return removed
    except Exception as e:
        log.exception(f"Failed to remove from watch later: {e}")
        return False


def is_in_watch_later(video_id: str) -> bool:
    """
    Check if video is in watch later queue.
    
    Args:
        video_id: Video ID to check
        
    Returns:
        True if in queue, False otherwise
    """
    if not _WATCH_LATER.exists():
        return False
    
    try:
        for line in _WATCH_LATER.read_text(encoding="utf-8").splitlines():
            if not line.strip():
                continue
            try:
                data = json.loads(line)
                if data.get("id") == video_id:
                    return True
            except json.JSONDecodeError:
                continue
    except Exception as e:
        log.debug(f"Error checking watch later status: {e}")
    
    return False


def list_watch_later(limit: int | None = None) -> list[Video]:
    """
    Get all videos in watch later queue.
    
    Args:
        limit: Maximum number of videos to return (None for all)
        
    Returns:
        List of videos, most recently added first
    """
    if not _WATCH_LATER.exists():
        return []
    
    videos = []
    try:
        for line in _WATCH_LATER.read_text(encoding="utf-8").splitlines():
            if not line.strip():
                continue
            try:
                data = json.loads(line)
                videos.append(Video(
                    id=str(data.get("id", "")),
                    title=data.get("title", ""),
                    url=data.get("url", ""),
                    channel=data.get("channel"),
                    duration=data.get("duration"),
                    thumb_url=data.get("thumb_url"),
                    kind=data.get("kind", "video"),
                ))
            except Exception as e:
                log.debug(f"Failed to parse watch later entry: {e}")
                continue
    except Exception as e:
        log.exception(f"Failed to list watch later: {e}")
        return []
    
    # Most recent first
    videos.reverse()
    
    if limit is not None and limit > 0:
        videos = videos[:limit]
    
    return videos


def clear_watch_later() -> int:
    """
    Clear all videos from watch later queue.
    
    Returns:
        Number of videos cleared
    """
    if not _WATCH_LATER.exists():
        return 0
    
    try:
        count = len(list_watch_later())
        _WATCH_LATER.unlink()
        log.info(f"Cleared {count} videos from watch later")
        return count
    except Exception as e:
        log.exception(f"Failed to clear watch later: {e}")
        return 0


def get_watch_later_count() -> int:
    """
    Get count of videos in watch later queue.
    
    Returns:
        Number of videos
    """
    if not _WATCH_LATER.exists():
        return 0
    
    try:
        count = 0
        for line in _WATCH_LATER.read_text(encoding="utf-8").splitlines():
            if line.strip():
                count += 1
        return count
    except Exception:
        return 0

--- FILE: ./src/whirltube/providers/base.py ---
from __future__ import annotations

from typing import Protocol, TYPE_CHECKING

if TYPE_CHECKING:
    from ..models import Video, Format

class Provider(Protocol):
    """
    Protocol defining the interface for all data providers (e.g., yt-dlp, Invidious, InnerTube).
    """
    def search(self, query: str, limit: int, filters: dict[str, str] | None = None) -> list[Video]:
        ...

    def trending(self) -> list[Video]:
        ...

    def related(self, video_id: str) -> list[Video]:
        ...

    def comments(self, video_id: str) -> list[Video]:
        ...

    def channel_tab(self, channel_url: str, tab: str) -> list[Video]:
        ...

    def fetch_formats(self, url: str) -> list[Format]:
        ...

    def get_video_info(self, url: str) -> Video | None:
        ...

    def set_cookies_from_browser(self, spec: str) -> None:
        """Set cookies for the provider from a browser specification string."""
        ...

    def suggestions(self, query: str, max_items: int = 10) -> list[str]:
        """Get search suggestions/autocomplete."""
        ...

    def get_proxy(self) -> str | None:
        """Get the configured proxy string."""
        ...


--- FILE: ./src/whirltube/providers/hybrid.py ---
from __future__ import annotations

import logging

from ..models import Video, Format
from .base import Provider
from .innertube_web import InnerTubeWeb
from .ytdlp import YTDLPProvider

log = logging.getLogger(__name__)

class HybridProvider(Provider):
    """
    A provider that intelligently delegates calls to a fast provider (InnerTubeWeb)
    for lightweight tasks (suggestions, trending) and a robust provider (YTDLPProvider)
    for heavy tasks (search, formats, comments).
    """
    def __init__(self, fast_provider: InnerTubeWeb, robust_provider: YTDLPProvider) -> None:
        self._fast = fast_provider
        self._robust = robust_provider

    # --- Fast Path (InnerTubeWeb) ---

    def suggestions(self, query: str, max_items: int = 10) -> list[str]:
        return self._fast.suggestions(query, max_items)

    def trending(self) -> list[Video]:
        # InnerTubeWeb delegates to its fallback (which is YTDLPProvider)
        # so calling _fast.trending() is sufficient.
        return self._fast.trending()

    # --- Robust Path (YTDLPProvider) ---

    def search(self, query: str, limit: int, filters: dict[str, str] | None = None) -> list[Video]:
        # YTDLPProvider handles search with filters
        return self._robust.search(query, limit, filters)

    def related(self, video_id: str) -> list[Video]:
        return self._robust.related(video_id)

    def comments(self, video_id: str) -> list[Video]:
        return self._robust.comments(video_id)

    def channel_tab(self, channel_url: str, tab: str) -> list[Video]:
        return self._robust.channel_tab(channel_url, tab)

    def fetch_formats(self, url: str) -> list[Format]:
        return self._robust.fetch_formats(url)

    def get_video_info(self, url: str) -> Video | None:
        # This is a robust operation, delegate to ytdlp
        return self._robust.get_video_info(url)

    def set_cookies_from_browser(self, spec: str) -> None:
        # Cookies are primarily for yt-dlp to access region-locked content
        self._robust.set_cookies_from_browser(spec)

    def get_proxy(self) -> str | None:
        return self._robust.get_proxy()

--- FILE: ./src/whirltube/providers/innertube_web.py ---
from __future__ import annotations

import logging
import httpx
import json

from ..models import Video, Format
from ..util import safe_httpx_proxy
from .base import Provider

log = logging.getLogger(__name__)

# Base URL for InnerTube API (used by web clients)
# This is a placeholder and would require a full InnerTube implementation
# For now, we will use a simple search suggestion endpoint.
_SUGGEST_URL = "https://suggestqueries-clients6.youtube.com/complete/search"
_TRENDING_URL = "https://www.youtube.com/feed/trending" # Fallback to scraping/ytdlp for now

class InnerTubeWeb(Provider):
    """
    Provider for fast, lightweight tasks using direct YouTube/InnerTube endpoints.
    Primarily for suggestions and trending.
    """
    def __init__(self, hl: str = "en", gl: str = "US", proxy: str | None = None, fallback: Provider | None = None) -> None:
        self.hl = hl
        self.gl = gl
        self.proxy = proxy
        self._fallback = fallback
        self._client: httpx.Client | None = None
        self._init_client()

    def _init_client(self) -> None:
        try:
            if self._client:
                self._client.close()
        except Exception:
            pass
        proxy = safe_httpx_proxy(self.proxy)
        self._client = httpx.Client(
            timeout=5.0,
            proxy=proxy,
            headers={"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/128.0.0.0 Safari/537.36"},
            http2=False,
        )

    def suggestions(self, query: str, max_items: int = 10) -> list[str]:
        """Get search suggestions/autocomplete using the suggestqueries endpoint."""
        if not query:
            return []
        
        params = {
            "client": "youtube",
            "ds": "yt",
            "q": query,
            "hl": self.hl,
            "gl": self.gl,
        }
        
        try:
            r = self._client.get(_SUGGEST_URL, params=params)
            r.raise_for_status()
            
            # Response is a JSONP-like string: 'window.google.ac.h(data)'
            # We need to strip the function call wrapper
            text = r.text
            if text.startswith("window.google.ac.h("):
                text = text[len("window.google.ac.h("):-1]
            
            data = json.loads(text)
            
            # Data structure: [query, [[suggestion1, type], [suggestion2, type], ...]]
            if isinstance(data, list) and len(data) > 1 and isinstance(data[1], list):
                return [str(s[0]) for s in data[1] if isinstance(s, list) and len(s) > 0][:max_items]
            
        except Exception as e:
            log.debug(f"InnerTubeWeb suggestions failed: {e}")
            if self._fallback:
                return self._fallback.suggestions(query, max_items)
        return []

    def trending(self) -> list[Video]:
        """
        For InnerTubeWeb, we delegate trending to the fallback (yt-dlp)
        as a full InnerTube implementation is complex.
        """
        if self._fallback:
            return self._fallback.trending()
        return []

    # --- Delegated/Unsupported methods ---

    def search(self, query: str, limit: int, filters: dict[str, str] | None = None) -> list[Video]:
        if self._fallback:
            return self._fallback.search(query, limit, filters)
        return []

    def related(self, video_id: str) -> list[Video]:
        if self._fallback:
            return self._fallback.related(video_id)
        return []

    def comments(self, video_id: str) -> list[Video]:
        if self._fallback:
            return self._fallback.comments(video_id)
        return []

    def channel_tab(self, channel_url: str, tab: str) -> list[Video]:
        if self._fallback:
            return self._fallback.channel_tab(channel_url, tab)
        return []

    def fetch_formats(self, url: str) -> list[Format]:
        if self._fallback:
            return self._fallback.fetch_formats(url)
        return []

    def get_video_info(self, url: str) -> Video | None:
        if self._fallback:
            return self._fallback.get_video_info(url)
        return None

    def set_cookies_from_browser(self, spec: str) -> None:
        # Not supported by this provider, delegate to fallback
        if self._fallback:
            self._fallback.set_cookies_from_browser(spec)

    def get_proxy(self) -> str | None:
        return self.proxy

--- FILE: ./src/whirltube/providers/invidious.py ---
from __future__ import annotations

import logging
import time
from dataclasses import dataclass
from typing import Any

import httpx

from ..models import Video
from .ytdlp import YTDLPProvider  # reuse helpers where helpful
from ..util import safe_httpx_proxy
from .base import Provider

DEFAULT_TIMEOUT = 12.0
UA = "Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0"

log = logging.getLogger(__name__)

@dataclass(slots=True)
class _Cfg:
    base: str
    proxy: str | None = None
    timeout: float = DEFAULT_TIMEOUT

class InvidiousProvider(Provider):
    """
    Minimal Invidious API provider for search and channel videos.
    Falls back to YTDLPProvider for unsupported operations.
    """
    def __init__(self, base_url: str, proxy: str | None = None, fallback: YTDLPProvider | None = None) -> None:
        self.cfg = _Cfg(base=base_url.rstrip("/"), proxy=proxy)
        
        # Ensure fallback is YTDLPProvider, not InvidiousProvider
        if fallback and not isinstance(fallback, YTDLPProvider):
            log.warning(f"Invalid fallback type: {type(fallback)}, using default YTDLPProvider")
            fallback = None
        
        self._fallback = fallback or YTDLPProvider()
        self._client: httpx.Client | None = None
        self._init_client()
        self._prefer_invidious_links = True  # return base/watch?v=ID

    def _watch_url(self, vid: str) -> str:
        if not vid:
            return ""
        if self._prefer_invidious_links:
            return f"{self.cfg.base}/watch?v={vid}"
        return f"https://www.youtube.com/watch?v={vid}"

    def set_proxy(self, proxy: str | None) -> None:
        self.cfg.proxy = proxy or None
        self._init_client()

    def _init_client(self) -> None:
        try:
            if self._client:
                self._client.close()
        except Exception:
            pass
        proxy = safe_httpx_proxy(self.cfg.proxy)
        # http2 off avoids some flaky proxies; UA set to a browser for compatibility
        self._client = httpx.Client(
            timeout=self.cfg.timeout,
            proxy=proxy,
            headers={"User-Agent": UA},
            http2=False,
        )

    def _robust_api_call(self, endpoint: str, params: dict | None = None) -> dict | list:
        """Try API call with multiple fallback strategies"""
        params = params or {}
        strategies = [
            (self._client, {}),  # Normal with proxy
            (httpx.Client(timeout=self.cfg.timeout, proxy=self.cfg.proxy, headers={"User-Agent": UA}, http2=False, verify=False), {'verify': False}),
            (httpx.Client(timeout=self.cfg.timeout, headers={"User-Agent": UA}, http2=False, verify=False, trust_env=False), {'no_proxy': True, 'verify': False}),
        ]
        
        for client, opts in strategies:
            try:
                # Use client directly if it's self._client, otherwise use a context manager
                if client is self._client:
                    r = client.get(f"{self.cfg.base}{endpoint}", params=params)
                else:
                    with client as c:
                        r = c.get(f"{self.cfg.base}{endpoint}", params=params)
                
                r.raise_for_status()
                return r.json()
            except Exception as e:
                log.debug(f"Strategy {opts} failed for {endpoint}: {e}")
                continue
        
        raise RuntimeError(f"All strategies failed for {endpoint}")

    def trending(self, limit: int = 20, region: str | None = None) -> list[Video]:
        """
        Return trending videos. Tries Invidious API; falls back to yt-dlp.
        """
        params: dict[str, Any] = {"type": "video"}
        if region:
            params["region"] = region
        
        items: list[dict] = []
        try:
            data = self._robust_api_call("/api/v1/trending", params=params)
            items = data if isinstance(data, list) else []
        except RuntimeError:
            log.debug("Invidious trending failed; trying /popular fallback.")
            try:
                data = self._robust_api_call("/api/v1/popular")
                items = data if isinstance(data, list) else []
            except RuntimeError as e:
                log.debug("Invidious /popular also failed (%s); using yt-dlp", e)
                return self._fallback.trending()

        vids: list[Video] = []
        for it in items:
            try:
                if it.get("type") and it.get("type") != "video":
                    continue
                vid = str(it.get("videoId") or "")
                if not vid:
                    continue
                dur = int(it.get("lengthSeconds") or 0) or None
                thumbs = it.get("videoThumbnails") or []
                thumb = None
                if isinstance(thumbs, list):
                    best = max((t for t in thumbs if isinstance(t, dict)), key=lambda x: int(x.get("width") or 0), default=None)
                    if best:
                        thumb = best.get("url")
                vids.append(
                    Video(
                        id=vid,
                        title=it.get("title") or "(untitled)",
                        url=self._watch_url(vid),
                        channel=it.get("author") or None,
                        duration=dur,
                        thumb_url=thumb,
                        kind="video",
                    )
                )
                if len(vids) >= limit:
                    break
            except Exception:
                continue
        return vids

    # ---------- Search ----------

    def search(self, query: str, limit: int = 20, order: str | None = None, duration: str | None = None, period: str | None = None) -> list[Video]:
        q = (query or "").strip()
        if not q:
            return []
        params: dict[str, Any] = {
            "q": q,
            "type": "video",
            "page": 1,
        }
        # Map order
        ordv = (order or "").lower().strip()
        if ordv == "date":
            params["sort_by"] = "upload_date"
        elif ordv == "views":
            params["sort_by"] = "view_count"
        else:
            params["sort_by"] = "relevance"

        # Optional search filters (best effort)
        # period -> time; Invidious may support 'hour','day','week','month','year' in some instances. We'll approximate client-side below as well.
        per = (period or "").lower().strip()
        if per == "today":
            params["date"] = "today"
        elif per == "week":
            params["date"] = "week"
        elif per == "month":
            params["date"] = "month"

        # Fetch
        try:
            data = self._robust_api_call("/api/v1/search", params=params)
            items: list[dict] = data if isinstance(data, list) else []
        except RuntimeError as e:
            log.debug("Invidious search failed (%s); fallback to yt-dlp", e)
            # Fallback to yt-dlp provider with same filters
            return self._fallback.search(query, limit=limit, order=order, duration=duration, period=period)

        vids: list[Video] = []
        now = int(time.time())

        def _dur_ok(seconds: int | None) -> bool:
            d = int(seconds or 0)
            dtag = (duration or "").lower().strip()
            if not dtag or dtag == "any":
                return True
            if dtag == "short":
                return 0 < d < 4 * 60
            if dtag == "medium":
                return 4 * 60 <= d <= 20 * 60
            if dtag == "long":
                return d > 20 * 60
            return True

        def _time_ok(published: int | None) -> bool:
            ptag = (period or "").lower().strip()
            if not ptag or ptag == "any":
                return True
            if not published:
                return True  # keep unknowns
            day = 86400
            cutoff = now - (day if ptag == "today" else 7 * day if ptag == "week" else 30 * day)
            return published >= cutoff

        for it in items:
            try:
                if it.get("type") != "video":
                    continue
                dur = int(it.get("lengthSeconds") or 0)
                pub = int(it.get("published") or 0)
                if not _dur_ok(dur) or not _time_ok(pub):
                    continue
                vid = str(it.get("videoId") or "")
                url = self._watch_url(vid) if vid else (it.get("videoThumbnails") or [{}])[0].get("url", "")
                thumb = None
                thumbs = it.get("videoThumbnails") or []
                if thumbs and isinstance(thumbs, list):
                    # pick the widest
                    best = max((t for t in thumbs if isinstance(t, dict)), key=lambda x: int(x.get("width") or 0), default=None)
                    if best:
                        thumb = best.get("url")
                vids.append(
                    Video(
                        id=vid or url,
                        title=it.get("title") or "(untitled)",
                        url=url,
                        channel=it.get("author") or None,
                        duration=dur or None,
                        thumb_url=thumb,
                        kind="video",
                    )
                )
                if len(vids) >= limit:
                    break
            except Exception:
                continue
        return vids

    def suggestions(self, query: str) -> list[str]:
        q = (query or "").strip()
        if not q:
            return []
        params = {"q": q}
        try:
            data = self._robust_api_call("/api/v1/search/suggestions", params=params)
            if isinstance(data, dict):
                suggestions = data.get("suggestions")
                if isinstance(suggestions, list):
                    return [str(s) for s in suggestions if isinstance(s, str)]
        except RuntimeError as e:
            log.debug("Invidious suggestions failed (%s); fallback", e)
            return self._fallback.suggestions(query)
        return []

    # ---------- Browse helpers ----------

    def _channel_id_from_url(self, url: str) -> str | None:
        u = (url or "").strip()
        # Only support /channel/UC... robustly; other forms fallback
        i = u.find("/channel/")
        if i >= 0:
            cid = u[i + len("/channel/") :].split("/")[0]
            if cid:
                return cid
        return None

    def channel_tab(self, chan_url: str, tab: str = "videos") -> list[Video]:
        cid = self._channel_id_from_url(chan_url)
        if not cid:
            return self._fallback.channel_tab(chan_url, tab=tab)
        try:
            data = self._robust_api_call(f"/api/v1/channels/{cid}/videos", params={"page": 1})
            items: list[dict] = data.get("videos") if isinstance(data, dict) else []
        except RuntimeError as e:
            log.debug("Invidious channel_tab failed (%s); fallback to yt-dlp", e)
            return self._fallback.channel_tab(chan_url, tab=tab)

        out: list[Video] = []
        for it in items or []:
            try:
                vid = str(it.get("videoId") or "")
                url = self._watch_url(vid) if vid else ""
                dur = int(it.get("lengthSeconds") or 0) or None
                thumb = None
                thumbs = it.get("videoThumbnails") or []
                if thumbs and isinstance(thumbs, list):
                    best = max((t for t in thumbs if isinstance(t, dict)), key=lambda x: int(x.get("width") or 0), default=None)
                    if best:
                        thumb = best.get("url")
                out.append(
                    Video(
                        id=vid or url,
                        title=it.get("title") or "(untitled)",
                        url=url or it.get("authorUrl") or "",
                        channel=it.get("author") or None,
                        duration=dur,
                        thumb_url=thumb,
                        kind="video",
                    )
                )
            except Exception:
                continue
        return out

    def browse_url(self, url: str) -> list[Video]:
        # We can only handle channels robustly when /channel/UC...; otherwise fallback
        if "/channel/" in (url or ""):
            return self.channel_tab(url, "videos")
        return self._fallback.browse_url(url)

    # ---------- Delegated methods ----------

    def playlist(self, playlist_url: str) -> list[Video]:
        return self._fallback.playlist(playlist_url)

    def related(self, video_url: str) -> list[Video]:
        return self._fallback.related(video_url)

    def comments(self, video_url: str, max_comments: int = 100) -> list[Video]:
        return self._fallback.comments(video_url, max_comments=max_comments)

    def fetch_formats(self, url: str) -> list[tuple[str, str]]:
        return self._fallback.fetch_formats(url)

    def channel_url_of(self, video_url: str) -> str | None:
        return self._fallback.channel_url_of(video_url)

--- FILE: ./src/whirltube/providers/ytdlp.py ---
from __future__ import annotations

import logging
import datetime
import time

from yt_dlp import YoutubeDL

from ..models import Video
from .base import Provider

log = logging.getLogger(__name__)

_BASE_OPTS = {
    "quiet": True,
    "nocheckcertificate": True,
    "retries": 3,
    "fragment_retries": 2,
    # Hint language/region + UA to reduce redirects
    "http_headers": {
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0",
        "Accept-Language": "en-US,en;q=0.9",
    },
}


class YTDLPProvider(Provider):
    """YouTube operations via yt-dlp. No API keys required."""

    def __init__(self, proxy: str | None = None) -> None:
        self._opts_base: dict = dict(_BASE_OPTS)
        if proxy:
            self._opts_base["proxy"] = proxy
        self._reinit()

    def set_proxy(self, proxy: str | None) -> None:
        # Update base options and reinitialize internal extractors
        self._opts_base = dict(_BASE_OPTS)
        if proxy:
            self._opts_base["proxy"] = proxy
        self._reinit()

    def _parse_cookie_spec(self, spec: str) -> tuple[str | None, str | None, str | None, str | None]:
        """Parse yt-dlp cookie spec string into (browser, keyring, profile, container) tuple."""
        if not spec:
            return None, None, None, None

        # Split into browser_part and profile_part at first ':'
        if ':' not in spec:
            browser_part = spec
            profile_part = None
        else:
            browser_part, profile_part = spec.split(':', 1)

        # Parse browser_part: browser[+keyring]
        if '+' in browser_part:
            browser, keyring = browser_part.split('+', 1)
        else:
            browser = browser_part
            keyring = None

        # Parse profile_part: profile[::container]
        if profile_part is None:
            profile = None
            container = None
        else:
            if '::' in profile_part:
                p, c = profile_part.split('::', 1)
                profile = p if p else None
                container = c if c else None
            else:
                profile = profile_part if profile_part else None
                container = None

        return browser, profile, keyring, container  # yt-dlp expects (browser, profile, keyring, container)


    def set_cookies_from_browser(self, spec: str | None) -> None:
        """spec example: 'firefox+gnomekeyring:default::Work'"""
        self._opts_base = dict(_BASE_OPTS)
        if "proxy" in self._opts_base:
            # re-add proxy if it was in original base options
            self._opts_base["proxy"] = _BASE_OPTS.get("proxy", None)
        if spec and spec.strip():
            # Add basic validation to prevent malformed cookie specs from causing crashes
            clean_spec = spec.strip()
            # yt-dlp's _parse_browser_specification expects up to 4 parts: browser, keyring, profile, container
            # Check for potential problematic patterns before passing to yt-dlp
            try:
                # Basic check: don't allow too many separators which might cause too many parts
                colon_parts = clean_spec.split(':')
                for part in colon_parts:
                    # each part after colon split, check for double-colon patterns
                    double_colon_count = part.count('::')
                    if double_colon_count > 1:
                        # potentially malformed, skip setting cookies to prevent crash
                        log.warning(f"Potentially malformed cookie spec: {clean_spec}, skipping")
                        self._reinit()
                        return
                
                # Also check for overall structure (shouldn't have too many colons overall)
                # Normal format: browser+keyring:profile::container (3 colons, 4 conceptual parts)
                if clean_spec.count(':') > 3:
                    log.warning(f"Cookie spec has too many colons: {clean_spec}, skipping")
                    self._reinit()
                    return

                # Parse the spec into tuple for yt-dlp API
                browser, profile, keyring, container = self._parse_cookie_spec(clean_spec)  # Unpack in correct order: browser, profile, keyring, container
                if browser:  # Only set if valid browser
                    self._opts_base["cookiesfrombrowser"] = (browser, profile, keyring, container)  # yt-dlp expects (browser, profile, keyring, container)
                else:
                    log.warning(f"Invalid browser in cookie spec: {clean_spec}, skipping")
            except Exception as e:
                log.warning(f"Error validating cookie spec {spec}: {e}, skipping")
                # Continue with reinit without cookies to avoid crash
        self._reinit()

    def _reinit(self) -> None:
        # Sanitize the options before creating YoutubeDL instances
        opts_base = dict(self._opts_base)
        if "cookiesfrombrowser" in opts_base:
            cookie_spec = opts_base["cookiesfrombrowser"]
            valid = True
            
            if isinstance(cookie_spec, str):
                # We should have already parsed this to tuple in set_cookies_from_browser
                # If it's still a string, something went wrong
                log.warning(f"cookiesfrombrowser is still a string, should be tuple: {cookie_spec}")
                valid = False
            elif isinstance(cookie_spec, (list, tuple)):
                # Validate tuple format: (browser, profile, keyring, container)
                if not (1 <= len(cookie_spec) <= 4):
                    log.warning(f"Invalid cookie spec tuple length: {len(cookie_spec)}")
                    valid = False
                elif not cookie_spec[0]:  # browser must be non-empty
                    log.warning("Invalid cookie spec: browser is empty")
                    valid = False
            else:
                log.warning(f"Invalid type for cookiesfrombrowser: {type(cookie_spec)}")
                valid = False

            if not valid:
                # Remove the invalid cookiesfrombrowser setting to prevent yt-dlp crash
                opts_base = {k: v for k, v in opts_base.items() if k != "cookiesfrombrowser"}
        
        # Flat for listings
        self._ydl_flat = YoutubeDL(dict(opts_base, **{"skip_download": True, "extract_flat": "in_playlist"}))
        # Full for details when needed
        self._ydl_full = YoutubeDL(dict(opts_base, **{"skip_download": True}))

    # ---------- Search ----------

    def search(self, query: str, limit: int = 20, order: str | None = None, duration: str | None = None, period: str | None = None) -> list[Video]:
        """
        order: None|"relevance"|"date"|"views"
        duration: None|"short"|"medium"|"long"
        period: None|"today"|"week"|"month"
        """
        query = query.strip()
        if not query:
            return []
        limit = max(1, min(limit, 50))
        ordv = (order or "").lower().strip()
        if ordv == "date":
            spec = f"ytsearchdate{limit}:{query}"
        else:
            spec = f"ytsearch{limit}:{query}"
        log.debug("yt-dlp search: %s (order=%s, duration=%s, period=%s)", spec, order, duration, period)
        info = self._ydl_flat.extract_info(spec, download=False)
        entries: list[dict] = [e for e in (info.get("entries") or []) if isinstance(e, dict)]

        # Optional sort by views if we didn't use ytsearchdate
        if ordv == "views":
            try:
                entries.sort(key=lambda e: int(e.get("view_count") or 0), reverse=True)
            except Exception:
                pass

        # Duration filter
        dur = (duration or "").lower().strip()
        if dur in {"short", "medium", "long"}:
            def _dur_ok(e: dict) -> bool:
                try:
                    d = int(e.get("duration") or 0)
                except Exception:
                    d = 0
                if dur == "short":
                    return d and d < 4 * 60
                if dur == "medium":
                    return 4 * 60 <= d <= 20 * 60
                if dur == "long":
                    return d and d > 20 * 60
                return True
            entries = [e for e in entries if _dur_ok(e)]

        # Period filter (best effort)
        per = (period or "").lower().strip()
        if per in {"today", "week", "month"}:
            now = int(time.time())
            day = 24 * 3600
            if per == "today":
                cutoff = now - day
            elif per == "week":
                cutoff = now - 7 * day
            else:
                cutoff = now - 30 * day
            def _ts(e: dict) -> int | None:
                t = e.get("timestamp")
                if isinstance(t, (int, float)):
                    return int(t)
                ud = e.get("upload_date")  # YYYYMMDD
                if isinstance(ud, str) and len(ud) == 8 and ud.isdigit():
                    try:
                        dt = datetime.datetime.strptime(ud, "%Y%m%d").replace(tzinfo=datetime.timezone.utc)
                        return int(dt.timestamp())
                    except Exception:
                        return None
                return None
            ent2 = []
            for e in entries:
                ts = _ts(e)
                if ts is None:
                    # keep when unknown (avoid over-filtering)
                    ent2.append(e)
                elif ts >= cutoff:
                    ent2.append(e)
            entries = ent2

        return [_entry_to_video(e) for e in entries]

    # ---------- Browse helpers ----------

    def trending(self) -> list[Video]:
        """List trending feed with multiple fallbacks."""
        urls = [
            # Mobile + region/language hints first
            "https://m.youtube.com/feed/trending?gl=US&hl=en",
            "https://m.youtube.com/explore?gl=US&hl=en",
            # Desktop with hints
            "https://www.youtube.com/feed/trending?gl=US&hl=en",
            "https://www.youtube.com/explore?gl=US&hl=en",
            # Legacy/alt
            "https://www.youtube.com/feed/trending",
            "https://www.youtube.com/feed/explore",
            "https://www.youtube.com/explore",
            "https://www.youtube.com/feed/trending?bp=6gQJRkVleHBsb3Jl",
        ]
        
        # First try with normal settings (including proxy if configured)
        last_exc = None
        # Create a new instance with timeout settings
        timeout_opts = dict(
            self._opts_base,
            **{
                "skip_download": True,
                "extract_flat": "in_playlist",
                "socket_timeout": 10,  # Add timeout
                "extractor_retries": 2,  # Limit retries
                "ignoreerrors": True,  # Don't crash
            }
        )
        ydl_timeout = YoutubeDL(timeout_opts)
        
        for url in urls:
            log.debug("yt-dlp browse trending: %s", url)
            try:
                data = ydl_timeout.extract_info(url, download=False)
                if not isinstance(data, dict):
                    continue
                entries = data.get("entries") or []
                out = [_entry_to_video(e) for e in entries if isinstance(e, dict)]
                if out:
                    return out
            except Exception as e:
                last_exc = e
                log.debug("yt-dlp trending URL failed: %s - %s", url, e)
                continue
        
        # If that fails and we had a proxy, try without proxy as fallback
        if last_exc and "proxy" in self._opts_base:
            log.debug("trending failed with proxy, trying without proxy...")
            try:
                # Create a temporary YoutubeDL without proxy
                opts_no_proxy = {k: v for k, v in self._opts_base.items() if k != "proxy"}
                ydl_no_proxy = YoutubeDL(dict(
                    opts_no_proxy,
                    **{
                        "skip_download": True,
                        "extract_flat": "in_playlist",
                        "socket_timeout": 10,  # Add timeout
                        "extractor_retries": 2,  # Limit retries
                        "ignoreerrors": True,  # Don't crash
                    }
                ))
                
                for url in urls:
                    log.debug("yt-dlp browse trending (no proxy): %s", url)
                    try:
                        data = ydl_no_proxy.extract_info(url, download=False)
                        if not isinstance(data, dict):
                            continue
                        entries = data.get("entries") or []
                        out = [_entry_to_video(e) for e in entries if isinstance(e, dict)]
                        if out:
                            log.debug("trending succeeded without proxy")
                            return out
                    except Exception as e:
                        log.debug("yt-dlp trending URL failed (no proxy): %s - %s", url, e)
                        continue
            except Exception as e:
                log.debug("trending no-proxy attempt failed: %s", e)
        
        if last_exc:
            log.warning("trending failed: %s", last_exc)
        return []

    def browse_url(self, url: str) -> list[Video]:
        """
        Generic "open URL" listing: video -> single entry; playlist/channel -> flat entries.
        """
        url = url.strip()
        if not url:
            return []
        log.debug("browse url: %s", url)
        try:
            data = self._ydl_flat.extract_info(url, download=False)
            if not isinstance(data, dict):
                raise RuntimeError("yt-dlp returned no data")
            entries = data.get("entries") or []
            if entries:
                return [_entry_to_video(e) for e in entries if isinstance(e, dict)]
            # Single item
            return [_info_to_video(data)]
        except Exception as e:
            log.exception("browse_url failed: %s", e)
            return []

    def channel_tab(self, chan_url: str, tab: str = "videos") -> list[Video]:
        """Browse a channel tab: /videos, /streams, /playlists."""
        tab = tab.strip("/").lower()
        base = _ensure_channel_root(chan_url)
        if not base.endswith(f"/{tab}"):
            url = base.rstrip("/") + f"/{tab}"
        else:
            url = base
        log.debug("channel_tab: %s", url)
        return self.browse_url(url)

    def playlist(self, playlist_url: str) -> list[Video]:
        """Browse a playlist entries."""
        return self.browse_url(playlist_url)

    def related(self, video_url: str) -> list[Video]:
        """Fetch related/suggested items. Falls back to title-based search if missing."""
        try:
            info = self._ydl_full.extract_info(video_url, download=False)
            if not isinstance(info, dict):
                log.debug("related: no data for %s", video_url)
                return []
        except Exception as e:
            log.exception("related failed: %s", e)
            return []
        out: list[Video] = []
        if isinstance(info, dict):
            rel = info.get("related") or info.get("related_videos") or []
            if isinstance(rel, list):
                for e in rel:
                    if isinstance(e, dict):
                        out.append(_entry_to_video(e))
            if out:
                return out
            # Fallback: title search
            title = (info.get("title") or "").strip()
            if title:
                spec = f"ytsearch20:{title}"
                try:
                    s = self._ydl_flat.extract_info(spec, download=False)
                    if not isinstance(s, dict):
                        log.debug("related fallback: no data for %s", spec)
                        return out
                    entries = s.get("entries") or []
                    out = [_entry_to_video(e) for e in entries if isinstance(e, dict)]
                    # Filter out the same URL if present
                    out = [v for v in out if v.url != video_url]
                except Exception as e:
                    log.debug("related fallback search failed: %s", e)
        return out

    # ---------- Metadata helpers ----------
    def channel_url_of(self, video_url: str) -> str | None:
        """
        Return the channel URL for a given video URL if available.
        """
        try:
            info = self._ydl_full.extract_info(video_url, download=False)
            if not isinstance(info, dict):
                log.debug("channel_url_of: no data for %s", video_url)
                return None
        except Exception:
            return None
        ch = info.get("channel_url") or info.get("uploader_url")
        if isinstance(ch, str) and ch.strip():
            return ch.strip()
        cid = info.get("channel_id") or info.get("uploader_id")
        if isinstance(cid, str) and cid.strip() and cid.startswith("UC"):
            return f"https://www.youtube.com/channel/{cid.strip()}"
        return None

    def comments(self, video_url: str, max_comments: int = 100) -> list[Video]:
        """Fetch top-level comments when available via yt-dlp API."""
        opts = dict(self._opts_base, **{
            "skip_download": True,
            "getcomments": True,
            "socket_timeout": 5,           # Abort socket after 5s
            "extractor_retries": 1,         # Only retry once
            "fragment_retries": 0,
            "ignoreerrors": True,           # Don't crash on errors
        })
        
        # NEW: Use separate YoutubeDL instance to avoid state pollution
        try:
            with YoutubeDL(opts) as ydl:
                info = ydl.extract_info(video_url, download=False)
        except Exception as e:
            log.warning(f"Comment extraction failed: {e}")
            return []
        
        if not isinstance(info, dict):
            return []
        
        comments = info.get("comments") or []
        
        # CRITICAL: Limit iteration immediately
        out: list[Video] = []
        for i, c in enumerate(comments[:max_comments]):  # Slice BEFORE iterating
            comment_id = c.get("id") or c.get("comment_id") or ""
            author = c.get("author") or "Comment"
            text = (c.get("text") or "(empty)")[:200]  # Truncate long comments
            url = f"{video_url}&lc={comment_id}" if comment_id else video_url
            
            out.append(Video(
                id=str(comment_id),
                title=text,
                url=url,
                channel=author,
                duration=None,
                thumb_url=None,
                kind="comment",
            ))
        
        return out

    def fetch_formats(self, url: str) -> list[tuple[str, str]]:
        """Return list of (format_id, label) for a given URL."""
        opts = dict(_BASE_OPTS, **{"skip_download": True, "listformats": False})
        y = YoutubeDL(opts)
        info = y.extract_info(url, download=False)
        fmts = info.get("formats") or []
        out: list[tuple[str, str]] = []
        for f in fmts:
            fid = str(f.get("format_id"))
            v = f.get("vcodec") or "â€”"
            a = f.get("acodec") or "â€”"
            h = f.get("height") or "?"
            w = f.get("width") or "?"
            res = f"{w}x{h}"
            br = f.get("tbr") or f.get("abr") or f.get("vbr") or "?"
            label = f"{res} {v}/{a} @ {br}k"
            out.append((fid, label))
        return out

    def suggestions(self, query: str) -> list[str]:
        return []


def _entry_to_video(e: dict) -> Video:
    vid = e.get("id") or e.get("url") or ""
    title = e.get("title") or "(untitled)"
    webpage = e.get("webpage_url") or e.get("original_url") or e.get("url") or _watch_url(vid)
    channel = e.get("channel") or e.get("uploader")
    duration = e.get("duration")
    thumb = _pick_thumb(e.get("thumbnails"))
    
    # NEW: Extract view count
    view_count = e.get("view_count")
    
    # NEW: Extract upload date
    upload_date = e.get("upload_date")  # YYYYMMDD format

    # Kind inference
    kind = "video"
    t = e.get("_type")
    ie = (e.get("ie_key") or "").strip()
    if t == "playlist" or ie in {"YoutubePlaylist", "YoutubeTab"}:
        kind = "playlist"
        webpage = e.get("webpage_url") or webpage
    elif (
        ie in {"YoutubeChannel"}
        or (not e.get("duration") and str(e.get("id") or "").startswith("UC"))
        or (not e.get("duration") and "youtube.com/channel/" in str(e.get("webpage_url") or e.get("url") or ""))
    ):
        kind = "channel"
        ch = e.get("channel_url") or e.get("uploader_url") or e.get("url") or webpage
        if ch:
            webpage = _ensure_channel_root(ch) + "/videos"
    elif t == "url" and "playlist" in (e.get("url") or ""):
        kind = "playlist"

    return Video(
        id=str(vid),
        title=title,
        url=webpage,
        channel=channel,
        duration=int(duration) if duration else None,
        thumb_url=thumb,
        kind=kind,
        view_count=int(view_count) if view_count else None,  # NEW
        upload_date=upload_date,  # NEW
    )

def _info_to_video(info: dict) -> Video:
    return _entry_to_video(info)

def _watch_url(vid: str) -> str:
    return f"https://www.youtube.com/watch?v={vid}" if vid else ""

def _ensure_channel_root(url: str) -> str:
    """
    Return a canonical channel root or user/handle root:
    Works with /channel/UC..., /@handle, /user/..., /c/...
    """
    u = (url or "").rstrip("/")
    for seg in ("/channel/", "/user/", "/c/", "/@"):
        if seg in u:
            return u
    if "/" not in u:
        return "https://www.youtube.com/channel/" + u
    return u

def _pick_thumb(thumbs: object) -> str | None:
    if not isinstance(thumbs, list) or not thumbs:
        return None
    best = None
    best_w = -1
    for t in thumbs:
        if not isinstance(t, dict):
            continue
        w = t.get("width") or 0
        url = t.get("url")
        if url and w > best_w:
            best = url
            best_w = w
    return best

--- FILE: ./src/whirltube/providers/__init__.py ---
from .ytdlp import YTDLPProvider
from .invidious import InvidiousProvider
from .innertube_web import InnerTubeWeb
from .hybrid import HybridProvider
from .base import Provider
__all__ = ['YTDLPProvider', 'InvidiousProvider', 'InnerTubeWeb', 'HybridProvider', 'Provider']

--- FILE: ./src/whirltube/services/mpv_launcher.py ---
from __future__ import annotations
from dataclasses import dataclass
from pathlib import Path
import subprocess
import shlex
import os
import tempfile
import secrets
from ..player import start_mpv, has_mpv
import logging

log = logging.getLogger(__name__)

@dataclass
class MpvConfig:
    quality: str | None
    cookies_browser: str | None
    cookies_keyring: str | None
    cookies_profile: str | None
    cookies_container: str | None
    http_proxy: str | None
    fullscreen: bool
    custom_args: str | None
    sb_enabled: bool
    sb_mode: str
    sb_categories: str


class MpvLauncher:
    def __init__(self, assets_dir: Path):
        self.assets_dir = assets_dir
    
    def _build_cookie_spec(self, cfg: MpvConfig) -> str | None:
        if not cfg.cookies_browser:
            return None
        val = cfg.cookies_browser
        if cfg.cookies_keyring:
            val += f"+{cfg.cookies_keyring}"
        if cfg.cookies_profile and cfg.cookies_container:
            val += f":{cfg.cookies_profile}::{cfg.cookies_container}"
        elif cfg.cookies_profile:
            val += f":{cfg.cookies_profile}"
        elif cfg.cookies_container:
            val += f"::{cfg.cookies_container}"
        return val
    
    def build_args(self, url: str, config: MpvConfig, playback_mode: str = "external", extra_mpv_args: list[str] | None = None) -> tuple[list[str], str | None, subprocess.Popen | None]:
        if not has_mpv():
            log.error("MPV not found in PATH")
            return [], None, None
        
        args = ["mpv", "--force-window=yes"]
        
        # Quality
        if config.quality and config.quality != "auto":
            try:
                h = int(config.quality)
                quality_format = f'bv*[height<={h}]+ba/b[height<={h}]'
                args.append(f'--ytdl-format={quality_format}')
            except Exception:
                pass
        
        # Fullscreen options
        from ..player import mpv_supports_option
        session = (os.environ.get("XDG_SESSION_TYPE") or "").lower()
        is_wayland = session == "wayland" or bool(os.environ.get("WAYLAND_DISPLAY"))
        
        if is_wayland and mpv_supports_option("wayland-app-id"):
            args.append("--wayland-app-id=org.whirltube.WhirlTube")
        if not is_wayland and mpv_supports_option("class"):
            args.append("--class=org.whirltube.WhirlTube")
        
        # Add custom mpv args if provided
        if config.custom_args:
            try:
                custom_args_list = shlex.split(config.custom_args)
                args.extend(custom_args_list)
            except Exception:
                log.warning("Failed to parse MPV args; launching without user args")
        
        # Add extra MPV args if provided
        if extra_mpv_args:
            args.extend(extra_mpv_args)
        
        # Cookie and proxy handling via ytdl-raw-options
        ytdl_raw_parts = []
        
        if config.cookies_browser:
            cookie_spec = self._build_cookie_spec(config)
            if cookie_spec:
                ytdl_raw_parts.append(f"cookies-from-browser={cookie_spec}")
        
        if config.http_proxy:
            ytdl_raw_parts.append(f"proxy={config.http_proxy}")
        
        if ytdl_raw_parts:
            args.append(f"--ytdl-raw-options={','.join(ytdl_raw_parts)}")
        
        # SponsorBlock for external playback mode
        if config.sb_enabled and playback_mode != "embedded":
            script_path = self.assets_dir / "scripts" / "sponsorblock.lua"
            if script_path.exists():
                args += ["--script", str(script_path)]
                # Map to Lua script config
                sb_opts = [
                    f"sponsorblock-categories={config.sb_categories or 'sponsor,intro'}",
                    f"sponsorblock-skip_categories={config.sb_categories if config.sb_mode=='skip' else ''}",
                    "sponsorblock-local_database=no",
                    "sponsorblock-make_chapters=yes",
                ]
                args.append("--script-opts=" + ",".join(sb_opts))
        
        args.append(url)
        
        # Create unique IPC socket path
        rnd = secrets.token_hex(4)
        ipc_dir = Path(tempfile.gettempdir())
        ipc_path = str(ipc_dir / f"whirltube-mpv-{os.getpid()}-{rnd}.sock")
        log_file = str(ipc_dir / f"whirltube-mpv-{os.getpid()}-{rnd}.log") if os.environ.get("WHIRLTUBE_DEBUG") else None
        
        args.insert(2, f"--input-ipc-server={ipc_path}")  # Insert IPC after basic options
        
        # Proxy env
        extra_env = {}
        if config.http_proxy:
            extra_env["http_proxy"] = config.http_proxy
            extra_env["https_proxy"] = config.http_proxy
        
        # Launch MPV
        try:
            proc = start_mpv(
                url,
                extra_args=args[3:],  # Skip mpv and --force-window=yes, --input-ipc-server from front
                ipc_server_path=ipc_path,
                extra_env=extra_env,
                log_file_path=log_file,
            )
            return args, ipc_path, proc
        except Exception as e:
            log.error("Failed to start mpv: %s", e)
            if os.environ.get("WHIRLTUBE_DEBUG") and log_file:
                log.error(f"Failed to start mpv. See log: {log_file}")
            else:
                log.error("Failed to start mpv. See logs for details.")
            return [], None, None

    def launch(self, args: list[str], ipc_path: str, extra_env: dict | None = None, url: str = "") -> subprocess.Popen | None:
        try:
            proc = start_mpv(
                url,
                extra_args=args,
                ipc_server_path=ipc_path,
                extra_env=extra_env,
            )
            return proc
        except Exception as e:
            log.error("Failed to start mpv: %s", e)
            return None

--- FILE: ./src/whirltube/services/native_resolver.py ---
from __future__ import annotations
import httpx

def get_ios_hls(video_id: str, hl: str = "en", gl: str = "US") -> str | None:
    headers = {
        "User-Agent": "com.google.ios.youtube/20.03.02(iPhone16,2; U; CPU iOS 18_2_1 like Mac OS X; US)",
        "X-Goog-Api-Format-Version": "2",
        "Content-Type": "application/json",
    }
    ctx = {
        "context": {
            "client": {
                "clientName": "IOS",
                "clientVersion": "20.03.02",
                "hl": hl, "gl": gl,
                "deviceMake": "Apple",
                "deviceModel": "iPhone16,2",
                "osName": "iOS",
                "osVersion": "18.2.1.22C161",
                "utcOffsetMinutes": 0,
            },
            "request": {"useSsl": True, "internalExperimentFlags": []},
            "user": {"lockedSafetyMode": False},
        },
        "videoId": video_id,
        "contentCheckOk": True,
        "racyCheckOk": True,
    }
    url = "https://youtubei.googleapis.com/youtubei/v1/player?prettyPrint=false"
    try:
        with httpx.Client(timeout=8.0) as c:
            r = c.post(url, headers=headers, json=ctx)
            r.raise_for_status()
            js = r.json()
            sd = js.get("streamingData") or {}
            hls = sd.get("hlsManifestUrl")
            return hls
    except Exception:
        return None


--- FILE: ./src/whirltube/services/playback.py ---
from __future__ import annotations

import logging
import os
import tempfile
import shlex
import secrets
import subprocess
import threading
from pathlib import Path
from typing import Callable, Any

from ..models import Video
from ..mpv_embed import MpvWidget
from ..player import has_mpv, start_mpv, mpv_send_cmd
from ..app import APP_ID
from .native_resolver import get_ios_hls

from gi.repository import GLib, Gdk

log = logging.getLogger(__name__)


class PlaybackService:
    def __init__(self, mpv_widget: MpvWidget, get_setting: Callable[[str, Any], Any]):
        self.mpv_widget = mpv_widget
        self.get_setting = get_setting
        # External MPV state
        self._proc: subprocess.Popen | None = None
        self._ipc: str | None = None
        self._current_url: str | None = None
        self._speed = 1.0
        self.native_playback_enabled = False
        # Callbacks for UI updates
        self._on_started_callback = None
        self._on_stopped_callback = None

    def set_callbacks(self, on_started=None, on_stopped=None):
        """Set callbacks for playback events"""
        self._on_started_callback = on_started
        self._on_stopped_callback = on_stopped

    # Helper methods for IPC property access
    def get_ipc_path(self) -> str | None:
        """Get IPC socket path for external MPV"""
        return self._ipc

    def get_ipc_property(self, name: str):
        """Get property from external MPV via IPC"""
        if not self._ipc:
            return None
        try:
            r = mpv_send_cmd(self._ipc, ["get_property", name])
            return r.get("data") if isinstance(r, dict) else None
        except Exception:
            return None

    def get_cookie_spec(self) -> str | None:
        """Get the ytdl cookie specification string from settings"""
        if not self.get_setting("mpv_cookies_enable"):
            return None
        browser = (self.get_setting("mpv_cookies_browser") or "").strip()
        if not browser:
            return None
        keyring = (self.get_setting("mpv_cookies_keyring") or "").strip()
        profile = (self.get_setting("mpv_cookies_profile") or "").strip()
        container = (self.get_setting("mpv_cookies_container") or "").strip()
        return self._cookie_spec(browser, keyring, profile, container)

    def play(self, video: Video) -> bool:
        # Fetch settings internally
        playback_mode = self.get_setting("playback_mode", "external")
        mpv_args = self.get_setting("mpv_args", "") or ""
        quality = (self.get_setting("mpv_quality") or "auto").strip()
        cookies_enabled = self.get_setting("mpv_cookies_enable")
        cookies_browser = self.get_setting("mpv_cookies_browser") or ""
        cookies_keyring = self.get_setting("mpv_cookies_keyring") or ""
        cookies_profile = self.get_setting("mpv_cookies_profile") or ""
        cookies_container = self.get_setting("mpv_cookies_container") or ""
        http_proxy = (self.get_setting("http_proxy") or "").strip() or None
        fullscreen = bool(self.get_setting("mpv_fullscreen"))
        sb_enabled = bool(self.get_setting("sb_playback_enable"))
        sb_mode = (self.get_setting("sb_playback_mode") or "mark").strip()
        sb_categories = (self.get_setting("sb_playback_categories") or "default").strip()

        # Detect Wayland/X11
        session = (os.environ.get("XDG_SESSION_TYPE") or "").lower()
        is_wayland = session == "wayland" or bool(os.environ.get("WAYLAND_DISPLAY"))

        # --- Native Playback Resolution ---
        play_url = video.url
        yt_id = self._extract_video_id(video.url)
        native_url = None
        
        if yt_id and self.native_playback_enabled:
            log.debug("Native playback enabled. Attempting to resolve iOS HLS URL.")
            try:
                # Use hardcoded hl/gl for native resolver for now
                native_url = get_ios_hls(yt_id, hl="en", gl="US")
                if native_url:
                    play_url = native_url
                    log.debug("Resolved native HLS URL.")
                else:
                    log.debug("Native HLS resolution failed. Falling back to yt-dlp.")
            except Exception as e:
                log.warning("Error during native HLS resolution: %s", e)
        
        # Quality preset -> ytdl-format
        ytdl_fmt_val = None
        if quality and quality != "auto":
            try:
                h = int(quality)
                ytdl_fmt_val = f'bv*[height<={h}]+ba/b[height<={h}]'
            except Exception:
                pass

        # Build base mpv args
        mpv_args_list = []
        if mpv_args:
            try:
                mpv_args_list = shlex.split(mpv_args)
            except Exception:
                log.warning("Failed to parse MPV args; launching without user args")

        if ytdl_fmt_val:
            mpv_args_list.append(f'--ytdl-format={ytdl_fmt_val}')

        # Fullscreen
        from ..player import mpv_supports_option
        extra_platform_args = []
        if is_wayland and mpv_supports_option("wayland-app-id"):
            extra_platform_args.append(f"--wayland-app-id={APP_ID}")
        if not is_wayland and mpv_supports_option("class"):
            extra_platform_args.append(f"--class={APP_ID}")
        final_mpv_args_list = mpv_args_list + extra_platform_args

        # Build ytdl-raw-options map (cookies + optional proxy - sponsorblock handled separately)
        ytdl_raw: dict[str, str] = {}

        if cookies_enabled:
            val = self._cookie_spec(cookies_browser, cookies_keyring, cookies_profile, cookies_container)
            if val:
                ytdl_raw["cookies-from-browser"] = val

        # SponsorBlock for external MPV: use Lua script approach only
        sb_mode_l = (sb_mode or "mark").strip().lower()
        if sb_enabled and playback_mode != "embedded":
            script_dir = Path(__file__).parent.parent / "assets" / "scripts"
            script_path = script_dir / "sponsorblock.lua"
            if script_path.exists():
                final_mpv_args_list += ["--script", str(script_path)]
                # Map to Lua script config
                sb_opts = [
                    f"sponsorblock-categories={sb_categories or 'sponsor,intro'}",
                    f"sponsorblock-skip_categories={sb_categories if sb_mode_l=='skip' else ''}",
                    "sponsorblock-local_database=no",
                    "sponsorblock-make_chapters=yes",
                ]
                final_mpv_args_list += ["--script-opts=" + ",".join(sb_opts)]
        
        # For embedded mode: SponsorBlock features may be limited to what MPV supports directly
        # The ytdl-raw-options approach for SponsorBlock doesn't work properly as these are post-processing options
        # So we only handle external MPV with Lua script; embedded will not have SponsorBlock support

        # Embedded path
        if playback_mode == "embedded":
            log.debug("Attempting embedded playback")
            try:
                self.mpv_widget.set_ytdl_format(ytdl_fmt_val)
            except Exception:
                pass
            # Pass ytdl-raw-options dict directly
            try:
                # Add proxy to raw opts for embedded too
                raw_opts = dict(ytdl_raw)
                if http_proxy:
                    raw_opts["proxy"] = http_proxy
                self.mpv_widget.set_ytdl_raw_options(raw_opts)
            except Exception:
                pass
            ok = self.mpv_widget.play(play_url)
            if ok:
                log.debug("Embedded playback started successfully")
                if self._on_started_callback:
                    self._on_started_callback("embedded")
                return True
            else:
                log.debug("Embedded playback failed, falling back to external")
        else:
            log.debug("Using external playback mode")

        # External MPV
        if not has_mpv():
            log.error("MPV not found in PATH")
            return False

        # Proxy env for mpv/ytdl
        extra_env = {}
        if http_proxy:
            extra_env["http_proxy"] = http_proxy
            extra_env["https_proxy"] = http_proxy

        # Unique IPC + optional log
        rnd = secrets.token_hex(4)
        ipc_dir = Path(tempfile.gettempdir())
        ipc_path = str(ipc_dir / f"whirltube-mpv-{os.getpid()}-{rnd}.sock")
        log_file = str(ipc_dir / f"whirltube-mpv-{os.getpid()}-{rnd}.log") if os.environ.get("WHIRLTUBE_DEBUG") else None

        # Append combined ytdl-raw-options CLI (single arg) if any
        ytdl_raw_cli = self._format_ytdl_raw_cli(ytdl_raw)
        if ytdl_raw_cli:
            final_mpv_args_list.append(f"--ytdl-raw-options={ytdl_raw_cli}")

        log.debug("Launching mpv: args=%s proxy=%s", final_mpv_args_list, bool(http_proxy))
        try:
            proc = start_mpv(
                play_url,
                extra_args=final_mpv_args_list,
                ipc_server_path=ipc_path,
                extra_env=extra_env,
                log_file_path=log_file,
            )
            self._proc = proc
            self._ipc = ipc_path
            self._current_url = video.url # Store original URL for timestamp copying
            self._speed = 1.0
            if self._on_started_callback:
                self._on_started_callback("external")
            def _watch():
                """Watch process and clean up on exit"""
                try:
                    # Keep local reference to IPC path for cleanup
                    ipc_to_clean = ipc_path
                    exit_code = proc.wait()  # Use local proc variable
                    log.debug(f"MPV process exited with code {exit_code}")
                except Exception as e:
                    log.warning(f"Error waiting for MPV process: {e}")
                    ipc_to_clean = ipc_path
                
                # Clean up IPC socket regardless of how we got here
                try:
                    if ipc_to_clean and os.path.exists(ipc_to_clean):
                        os.remove(ipc_to_clean)
                        log.debug(f"Cleaned up IPC socket: {ipc_to_clean}")
                except Exception as e:
                    log.warning(f"Failed to clean IPC socket {ipc_to_clean}: {e}")
                
                # Schedule UI update on main thread
                try:
                    GLib.idle_add(self._on_external_mpv_exit)
                except Exception as e:
                    # App might be shutting down
                    log.debug(f"Could not schedule MPV exit callback: {e}")
            threading.Thread(target=_watch, daemon=True).start()
            return True
        except Exception as e:
            log.error("Failed to start mpv: %s", e)
            if os.environ.get("WHIRLTUBE_DEBUG") and log_file:
                log.error(f"Failed to start mpv. See log: {log_file}")
            else:
                log.error("Failed to start mpv. See logs for details.")
            return False

    # --- helpers ---

    def _extract_video_id(self, url: str) -> str | None:
        """Extract YouTube video ID from URL"""
        if not url:
            return None
        
        # Handle various YouTube URL formats
        import urllib.parse
        try:
            parsed = urllib.parse.urlparse(url)
            
            # Standard watch URL
            if "youtube.com" in parsed.netloc and parsed.path == "/watch":
                query = urllib.parse.parse_qs(parsed.query)
                if "v" in query:
                    return query["v"][0]
            
            # Short URL
            if "youtu.be" in parsed.netloc:
                return parsed.path.lstrip("/")
            
            # Embed URL
            if "youtube.com" in parsed.netloc and "/embed/" in parsed.path:
                parts = parsed.path.split("/embed/")
                if len(parts) > 1:
                    return parts[1].split("?")[0]
            
            # Watch URL with different format
            if "youtube.com" in parsed.netloc and "/watch/" in parsed.path:
                parts = parsed.path.split("/watch/")
                if len(parts) > 1:
                    query = urllib.parse.parse_qs(parsed.query)
                    if "v" in query:
                        return query["v"][0]
        except Exception:
            pass
        
        return None

    def _cookie_spec(self, browser: str, keyring: str, profile: str, container: str) -> str:
        if not browser:
            return ""
        val = browser
        if keyring:
            val += f"+{keyring}"
        
        # Handle profile and container correctly
        if profile and container:
            val += f":{profile}::{container}"
        elif profile:
            val += f":{profile}"
        elif container:
            val += f"::{container}"
        
        return val


    def _format_ytdl_raw_cli(self, opts: dict[str, str]) -> str:
        """
        Build a single --ytdl-raw-options value like:
          cookies-from-browser=firefox,sponsorblock-mark=default
        Values with commas are escaped as '\\,' for mpv's parser.
        """
        parts = []
        for k, v in opts.items():
            if v is None:
                continue
            v = str(v)
            if "," in v:
                v = v.replace(",", r"\,")
            parts.append(f"{k}={v}")
        return ",".join(parts)

    def _on_external_mpv_exit(self) -> None:
        """Called when external MPV process exits"""
        # Clean up the IPC socket file
        try:
            if self._ipc and os.path.exists(self._ipc):
                os.remove(self._ipc)
        except OSError as e:
            log.warning("Failed to remove mpv IPC socket %s: %s", self._ipc or "", e)

        self._proc = None
        self._ipc = None
        self._current_url = None
        
        if self._on_stopped_callback:
            self._on_stopped_callback()

    def is_running(self) -> bool:
        """Check if any MPV player is running (external or embedded)"""
        if self._proc is not None:
            # Check if the process is still alive
            if self._proc.poll() is None:
                return True
            else:
                # Process died, clean up
                self._cleanup_external()
                return False
        # Check if embedded player is ready
        return self.mpv_widget.is_ready

    def _cleanup_external(self):
        """Clean up external MPV resources"""
        if self._ipc and os.path.exists(self._ipc):
            try:
                os.remove(self._ipc)
            except OSError:
                pass
        self._proc = None
        self._ipc = None
        self._current_url = None

    def cycle_pause(self):
        """Toggle play/pause for external MPV or embedded"""
        if self._ipc:
            mpv_send_cmd(self._ipc, ["cycle", "pause"])
        else:
            # Embedded path
            try:
                self.mpv_widget.pause_toggle()
            except Exception:
                pass

    def seek(self, secs: int):
        """Seek for external MPV or embedded"""
        if self._ipc:
            mpv_send_cmd(self._ipc, ["seek", secs, "relative"])
        else:
            try:
                self.mpv_widget.seek(secs)
            except Exception:
                pass

    def change_speed(self, delta: float):
        """Change playback speed for external MPV or embedded"""
        if self._ipc:
            try:
                self._speed = max(0.1, min(4.0, self._speed + delta))
            except Exception:
                self._speed = 1.0
            mpv_send_cmd(self._ipc, ["set_property", "speed", round(self._speed, 2)])
        else:
            # embedded
            try:
                self._speed = max(0.1, min(4.0, self._speed + delta))
            except Exception:
                self._speed = 1.0
            try:
                self.mpv_widget.set_speed(self._speed)
            except Exception:
                pass

    def stop(self):
        """Stop external MPV or embedded"""
        # Embedded stop
        if not self._ipc:
            try:
                self.mpv_widget.stop()
            except Exception:
                pass
            return
        
        # External path: prefer quit over kill where possible
        ipc_path = self._ipc
        if ipc_path:
            mpv_send_cmd(ipc_path, ["quit"])
        
        proc = self._proc
        if proc:
            try:
                proc.terminate()
            except Exception:
                pass
            try:
                proc.wait(timeout=2)
            except Exception:
                try:
                    proc.kill()
                except Exception:
                    pass
        
        # Clean up IPC socket
        if ipc_path and os.path.exists(ipc_path):
            try:
                os.remove(ipc_path)
                log.debug(f"Removed IPC socket: {ipc_path}")
            except OSError as e:
                log.warning(f"Failed to remove IPC socket {ipc_path}: {e}")
        
        self._proc = None
        self._ipc = None
        self._current_url = None

    def copy_timestamp(self) -> str | None:
        """Get current timestamp for external MPV or embedded and return URL with timestamp"""
        pos = 0
        if self._ipc:
            # Ask external mpv for current playback position
            try:
                resp = mpv_send_cmd(self._ipc, ["get_property", "time-pos"])
                if isinstance(resp, dict) and "data" in resp:
                    v = resp.get("data")
                    if isinstance(v, (int, float)):
                        pos = int(v)
            except Exception:
                pos = 0
        else:
            # Embedded mpv
            try:
                pos = int(self.mpv_widget.current_time())
            except Exception:
                pos = 0
        
        url = self._current_url or ""
        if not url and self._ipc:
            # Try to get from MPV path property as fallback
            try:
                resp2 = mpv_send_cmd(self._ipc, ["get_property", "path"])
                if isinstance(resp2, dict) and isinstance(resp2.get("data"), str):
                    url = str(resp2["data"])
            except Exception:
                pass
        
        if not url:
            return None
        
        sep = "&" if "?" in url else "?"
        return f"{url}{sep}t={pos}s"

    def copy_timestamp_to_clipboard(self) -> bool:
        """Copy the current timestamp URL to clipboard (Wayland-safe)"""
        timestamp_url = self.copy_timestamp()
        if not timestamp_url:
            return False
        
        disp = None
        try:
            disp = Gdk.Display.get_default()
            if not disp:
                return False
            clipboard = disp.get_clipboard()
            
            # Store provider to avoid GC on Wayland
            self._clipboard_provider = Gdk.ContentProvider.new_for_value(timestamp_url)
            clipboard.set_content(self._clipboard_provider)
            return True
        except Exception:
            pass
        
        # Fallback to primary
        try:
            if disp:  # Now disp is always defined
                primary = disp.get_primary_clipboard()
                if primary:
                    self._clipboard_provider_primary = Gdk.ContentProvider.new_for_value(timestamp_url)
                    primary.set_content(self._clipboard_provider_primary)
                    return True
        except Exception:
            pass
        
        return False

    def cleanup(self):
        """Cleanup all resources"""
        if self._proc:
            try:
                self._proc.terminate()
                try:
                    self._proc.wait(timeout=1)
                except subprocess.TimeoutExpired:
                    self._proc.kill()
            except Exception:
                pass
        if self._ipc and os.path.exists(self._ipc):
            try:
                os.remove(self._ipc)
            except Exception:
                pass
        self._proc = None
        self._ipc = None
        self._current_url = None

--- FILE: ./src/whirltube/services/__init__.py ---


--- FILE: ./src/whirltube/ui/widgets/mpv_controls.py ---
"""MPV controls header bar widget with progress bar and volume control."""
from __future__ import annotations

import logging
import threading
import time

import gi
gi.require_version("Adw", "1")
gi.require_version("Gtk", "4.0")
from gi.repository import Adw, Gtk, Gio, GLib

from ...services.playback import PlaybackService

log = logging.getLogger(__name__)


class MpvControls(Adw.Bin):
    """MPV controls header bar widget with progress bar and volume control"""
    
    def __init__(self, playback_service: PlaybackService) -> None:
        super().__init__()
        
        self._playback_service = playback_service
        
        # Create the header bar for MPV controls
        self.ctrl_bar = Adw.HeaderBar()
        self.ctrl_bar.set_title_widget(Gtk.Label(label="MPV Controls", css_classes=["dim-label"]))
        
        # Progress bar (for external MPV via IPC)
        self.progress_bar = Gtk.Scale(
            orientation=Gtk.Orientation.HORIZONTAL,
            hexpand=True
        )
        self.progress_bar.set_range(0, 100)
        self.progress_bar.set_draw_value(False)
        self.progress_bar.connect("value-changed", self._on_seek)
        self.progress_bar.set_visible(False)  # Hidden by default
        
        # Time labels
        self.time_label = Gtk.Label(label="0:00 / 0:00")
        self.time_label.add_css_class("caption")
        self.time_label.set_visible(False)  # Hidden by default
        
        # Volume slider
        self.volume_slider = Gtk.Scale(
            orientation=Gtk.Orientation.HORIZONTAL
        )
        self.volume_slider.set_range(0, 100)
        self.volume_slider.set_value(100)
        self.volume_slider.set_size_request(100, -1)
        self.volume_slider.connect("value-changed", self._on_volume_change)
        self.volume_slider.set_visible(False)  # Hidden by default
        
        # Control buttons: Seek -10, Play/Pause, Seek +10, Speed -, Speed +, Stop, Copy TS
        self.btn_seek_back = Gtk.Button(icon_name="media-seek-backward-symbolic")
        self.btn_play_pause = Gtk.Button(icon_name="media-playback-pause-symbolic")
        self.btn_seek_fwd = Gtk.Button(icon_name="media-seek-forward-symbolic")
        self.btn_speed_down = Gtk.Button(label="Speed -")
        self.btn_speed_up = Gtk.Button(label="Speed +")
        self.btn_stop_mpv = Gtk.Button(icon_name="media-playback-stop-symbolic")
        self.btn_copy_ts = Gtk.Button(icon_name="edit-copy-symbolic")
        self.btn_copy_ts.set_tooltip_text("Copy URL at current time (T)")
        
        # Connect button signals to playback service methods
        self.btn_seek_back.connect("clicked", self._on_seek_back_clicked)
        self.btn_play_pause.connect("clicked", self._on_play_pause_clicked)
        self.btn_seek_fwd.connect("clicked", self._on_seek_fwd_clicked)
        self.btn_speed_down.connect("clicked", self._on_speed_down_clicked)
        self.btn_speed_up.connect("clicked", self._on_speed_up_clicked)
        self.btn_stop_mpv.connect("clicked", self._on_stop_clicked)
        self.btn_copy_ts.connect("clicked", self._on_copy_ts_clicked)
        
        # Pack controls
        # Left side: Progress controls
        left_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        left_box.append(self.time_label)
        left_box.append(self.progress_bar)
        self.ctrl_bar.pack_start(left_box)
        
        # Right side: Buttons
        self.ctrl_bar.pack_end(self.btn_stop_mpv)
        self.ctrl_bar.pack_end(self.btn_copy_ts)
        self.ctrl_bar.pack_end(self.btn_speed_up)
        self.ctrl_bar.pack_end(self.btn_speed_down)
        self.ctrl_bar.pack_end(self.btn_seek_fwd)
        self.ctrl_bar.pack_end(self.btn_play_pause)
        self.ctrl_bar.pack_end(self.btn_seek_back)
        
        # Volume control (packed separately)
        vol_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        vol_box.append(Gtk.Label(label="ðŸ”Š"))
        vol_box.append(self.volume_slider)
        self.ctrl_bar.pack_end(vol_box)
        
        # Initially hidden
        self.ctrl_bar.set_visible(False)
        
        # Start property polling for external MPV
        self._start_ipc_polling()
    
    def _start_ipc_polling(self):
        """Poll MPV IPC for time-pos, duration, etc. using existing mpv_send_cmd"""
        def poll():
            while True:
                # Check if we have an IPC connection
                ipc_path = self._playback_service.get_ipc_path()
                if not ipc_path or not self._playback_service.is_running():
                    time.sleep(0.5)
                    continue
                
                try:
                    # Get time position and duration using existing method
                    time_pos = self._playback_service.get_ipc_property("time-pos") or 0
                    duration = self._playback_service.get_ipc_property("duration") or 0
                    pause = self._playback_service.get_ipc_property("pause") or False
                    
                    # Update UI on main thread
                    GLib.idle_add(self._update_progress, time_pos, duration, pause)
                except Exception as e:
                    log.debug(f"IPC polling error: {e}")
                
                time.sleep(0.5)
        
        threading.Thread(target=poll, daemon=True).start()
    
    def _update_progress(self, time_pos: float, duration: float, paused: bool):
        """Update progress bar (on main thread)"""
        if duration > 0:
            fraction = (time_pos / duration) * 100
            self.progress_bar.set_value(fraction)
            
            t_str = self._format_time(time_pos)
            d_str = self._format_time(duration)
            self.time_label.set_text(f"{t_str} / {d_str}")
            
            # Show progress controls
            self.progress_bar.set_visible(True)
            self.time_label.set_visible(True)
        else:
            # Hide progress controls when no duration
            self.progress_bar.set_visible(False)
            self.time_label.set_visible(False)
        
        # Update play/pause button icon
        if paused:
            self.btn_play_pause.set_icon_name("media-playback-start-symbolic")
        else:
            self.btn_play_pause.set_icon_name("media-playback-pause-symbolic")
    
    def _format_time(self, seconds: float) -> str:
        """Format seconds as H:MM:SS or M:SS"""
        s = int(seconds)
        h = s // 3600
        m = (s % 3600) // 60
        sec = s % 60
        if h:
            return f"{h}:{m:02}:{sec:02}"
        return f"{m}:{sec:02}"
    
    def _on_seek(self, scale: Gtk.Scale):
        """Handle progress bar seeking"""
        ipc_path = self._playback_service.get_ipc_path()
        if not ipc_path:
            return
        
        duration_val = self._playback_service.get_ipc_property("duration")
        if duration_val and duration_val > 0:
            fraction = scale.get_value() / 100
            target_time = duration_val * fraction
            from ...player import mpv_send_cmd
            mpv_send_cmd(ipc_path, ["seek", str(target_time), "absolute"])
    
    def _on_volume_change(self, scale: Gtk.Scale):
        """Handle volume slider"""
        vol = int(scale.get_value())
        ipc_path = self._playback_service.get_ipc_path()
        if ipc_path:
            from ...player import mpv_send_cmd
            mpv_send_cmd(ipc_path, ["set_property", "volume", vol])
    
    def _on_seek_back_clicked(self, button) -> None:
        """Handle seek backward button click"""
        self._playback_service.seek(-10)
    
    def _on_play_pause_clicked(self, button) -> None:
        """Handle play/pause button click"""
        self._playback_service.cycle_pause()
    
    def _on_seek_fwd_clicked(self, button) -> None:
        """Handle seek forward button click"""
        self._playback_service.seek(10)
    
    def _on_speed_down_clicked(self, button) -> None:
        """Handle speed down button click"""
        self._playback_service.change_speed(-0.1)
    
    def _on_speed_up_clicked(self, button) -> None:
        """Handle speed up button click"""
        self._playback_service.change_speed(0.1)
    
    def _on_stop_clicked(self, button) -> None:
        """Handle stop button click"""
        self._playback_service.stop()
    
    def _on_copy_ts_clicked(self, button) -> None:
        """Handle copy timestamp button click"""
        self._playback_service.copy_timestamp_to_clipboard()
    
    def set_visible(self, visible: bool) -> None:
        """Set visibility of the control bar"""
        self.ctrl_bar.set_visible(visible)
    
    def get_ctrl_bar(self):
        """Get the underlying control bar"""
        return self.ctrl_bar
    
    def update_controls_visibility(self, is_mpv_running: bool, autohide_enabled: bool, 
                                 current_stack_page: str | None = None) -> None:
        """Update visibility based on MPV state and settings"""
        visible = False
        if is_mpv_running:
            # Honor autohide preference: show only on player view when enabled
            if autohide_enabled:
                visible = (current_stack_page == "player")
            else:
                visible = True
        
        self.set_visible(visible)
    
    def add_actions_to_window(self, window: Adw.ApplicationWindow) -> None:
        """Add MPV actions to the window for keyboard shortcuts"""
        # Define actions
        a_play_pause = Gio.SimpleAction.new("mpv_play_pause", None)
        a_play_pause.connect("activate", lambda *_: self._playback_service.cycle_pause())
        window.add_action(a_play_pause)

        a_seek_back = Gio.SimpleAction.new("mpv_seek_back", None)
        a_seek_back.connect("activate", lambda *_: self._playback_service.seek(-10))
        window.add_action(a_seek_back)

        a_seek_fwd = Gio.SimpleAction.new("mpv_seek_fwd", None)
        a_seek_fwd.connect("activate", lambda *_: self._playback_service.seek(10))
        window.add_action(a_seek_fwd)

        a_speed_down = Gio.SimpleAction.new("mpv_speed_down", None)
        a_speed_down.connect("activate", lambda *_: self._playback_service.change_speed(-0.1))
        window.add_action(a_speed_down)

        a_speed_up = Gio.SimpleAction.new("mpv_speed_up", None)
        a_speed_up.connect("activate", lambda *_: self._playback_service.change_speed(0.1))
        window.add_action(a_speed_up)

        a_copy_ts = Gio.SimpleAction.new("mpv_copy_ts", None)
        a_copy_ts.connect("activate", lambda *_: self._playback_service.copy_timestamp_to_clipboard())
        window.add_action(a_copy_ts)

        a_stop = Gio.SimpleAction.new("stop_mpv", None)
        a_stop.connect("activate", lambda *_: self._playback_service.stop())
        a_stop.set_enabled(False)  # only enabled when mpv running initially
        window.add_action(a_stop)
        
        # Store reference to stop action to enable/disable it based on MPV state
        window._mpv_stop_action = a_stop
    
    def install_accelerators(self, application: Gio.Application) -> None:
        """Install keyboard accelerators for MPV actions"""
        # YouTube-like keys: j/k/l and +/- for speed, x to stop
        if application:
            application.set_accels_for_action("win.mpv_play_pause", ["K", "k"])
            application.set_accels_for_action("win.mpv_seek_back", ["J", "j"])
            application.set_accels_for_action("win.mpv_seek_fwd", ["L", "l"])
            application.set_accels_for_action("win.mpv_speed_down", ["minus", "KP_Subtract"])
            application.set_accels_for_action("win.mpv_speed_up", ["equal", "KP_Add"])
            application.set_accels_for_action("win.mpv_copy_ts", ["T", "t"])
            application.set_accels_for_action("win.stop_mpv", ["X", "x"])
    
    def handle_key_press(self, keyval: int, keycode: int, state) -> bool:
        """Handle key press events for MPV controls"""
        import gi
        gi.require_version("Gdk", "4.0")
        from gi.repository import Gdk
        
        # Only handle when MPV is running
        if not self._playback_service.is_running():
            return False
            
        k = Gdk.keyval_name(keyval) or ""
        k = k.lower()
        handled = False
        
        if k == "j":
            self._playback_service.seek(-10)
            handled = True
        elif k == "k":
            self._playback_service.cycle_pause()
            handled = True
        elif k == "l":
            self._playback_service.seek(10)
            handled = True
        elif k in ("minus", "kp_subtract"):
            self._playback_service.change_speed(-0.1)
            handled = True
        elif k in ("equal", "kp_add", "plus"):
            self._playback_service.change_speed(0.1)
            handled = True
        elif k == "x":
            self._playback_service.stop()
            handled = True
        elif k == "t":
            self._playback_service.copy_timestamp_to_clipboard()
            handled = True
            
        return handled
    
    def set_ipc_socket(self, socket_path: str | None):
        """Set IPC socket path for external MPV"""
        self._ipc_socket_path = socket_path
        # No need to reconnect client since we don't store an IPC client anymore

--- FILE: ./src/whirltube/ui/widgets/result_row.py ---
from __future__ import annotations

import logging
from concurrent.futures import ThreadPoolExecutor
from typing import Callable

import httpx

import gi
gi.require_version("Gtk", "4.0")
gi.require_version("Adw", "1")
gi.require_version("Gdk", "4.0")
gi.require_version("GdkPixbuf", "2.0")
from gi.repository import Gdk, GdkPixbuf, Gio, GLib, Gtk

from ...models import Video
from ...dialogs import DownloadOptions
from ...thumbnail_cache import get_cached_thumbnail, cache_thumbnail
from ...util import safe_httpx_proxy, is_valid_youtube_url
from ...subscription_feed import is_watched, mark_as_watched, mark_as_unwatched
from ...watch_later import is_in_watch_later, add_to_watch_later, remove_from_watch_later
from ...quick_quality import get_enabled_presets, get_preset_label, get_preset_tooltip, get_quick_quality_options
from ...metrics import timed

HEADERS = {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0"}

log = logging.getLogger(__name__)

# Shared HTTP client for thumbnail loading to reuse connections
_http_client: httpx.Client | None = None

def _get_http_client(proxy: str | None) -> httpx.Client:
    global _http_client
    if _http_client is None or _http_client.is_closed:
        _http_client = httpx.Client(
            timeout=10.0,
            follow_redirects=True,
            headers=HEADERS,
            proxy=safe_httpx_proxy(proxy),
            limits=httpx.Limits(max_connections=20, max_keepalive_connections=5)
        )
    return _http_client


class ResultRow(Gtk.Box):
    def __init__(
        self,
        video: Video,
        on_play: Callable[[Video], None],
        on_download_opts: Callable[[Video], None],
        on_open: Callable[[Video], None],
        on_related: Callable[[Video], None],
        on_comments: Callable[[Video], None],
        thumb_loader_pool: ThreadPoolExecutor,
        http_proxy: str | None = None,
        on_follow: Callable[[Video], None] | None = None,
        on_unfollow: Callable[[Video], None] | None = None,
        followed: bool = False,
        on_open_channel: Callable[[Video], None] | None = None,
        on_toast: Callable[[str], None] | None = None,
        get_setting: Callable[[str], any] | None = None,  # NEW parameter
        on_quick_download: Callable[[Video, DownloadOptions], None] | None = None,  # NEW parameter
    ) -> None:
        super().__init__(orientation=Gtk.Orientation.HORIZONTAL, spacing=12)
        self.video = video
        self.on_play = on_play
        self.on_download_opts = on_download_opts
        self.on_open = on_open
        self.on_related = on_related
        self.on_comments = on_comments
        self.on_open_channel = on_open_channel
        self.thumb_loader_pool = thumb_loader_pool
        self.on_follow = on_follow
        self.on_unfollow = on_unfollow
        self._followed = followed
        self._http_proxy = http_proxy
        self.on_toast = on_toast
        self._get_setting = get_setting or (lambda k: None)  # NEW
        self._on_quick_download = on_quick_download  # NEW
        self._proxies = safe_httpx_proxy(http_proxy)
        self._thumb_future = None  # Track thumbnail loading future to prevent memory leaks

        self.set_margin_top(6)
        self.set_margin_bottom(6)

        # Thumbnail stack with placeholder and image
        self._has_thumb = self.video.kind != "comment"
        if self._has_thumb:
            self.thumb_stack = Gtk.Stack()
            self.thumb_stack.set_size_request(160, 90)
            
            # Create placeholder widget once
            self.thumb_placeholder = Gtk.Box(orientation=Gtk.Orientation.VERTICAL)
            self.thumb_placeholder.set_size_request(160, 90)
            self.thumb_placeholder.set_halign(Gtk.Align.FILL)
            self.thumb_placeholder.set_valign(Gtk.Align.FILL)
            lbl = Gtk.Label(label="No thumbnail")
            lbl.set_halign(Gtk.Align.CENTER)
            lbl.set_valign(Gtk.Align.CENTER)
            lbl.add_css_class("dim-label")
            lbl.set_wrap(True)
            self.thumb_placeholder.append(lbl)
            
            # Create picture widget once
            self.thumb = Gtk.Picture(content_fit=Gtk.ContentFit.COVER)
            self.thumb.set_size_request(160, 90)
            
            # Add both to stack
            self.thumb_stack.add_named(self.thumb_placeholder, "placeholder")
            self.thumb_stack.add_named(self.thumb, "picture")
            self.append(self.thumb_stack)
        else:
            # Add a small spacer for alignment if no thumbnail
            spacer = Gtk.Box()
            spacer.set_size_request(16, 1) # Small spacer
            self.append(spacer)

        # Texts
        box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=4, hexpand=True)

        # Title with watched indicator
        title_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=6)
        title = Gtk.Label(label=video.title, wrap=True, xalign=0.0, hexpand=True)
        title.add_css_class("title-3")
        title_box.append(title)

        # NEW: Watched indicator
        if video.is_playable and is_watched(video.id):
            watched_label = Gtk.Label(label="âœ“ Watched")
            watched_label.add_css_class("dim-label")
            watched_label.set_tooltip_text("You've watched this video")
            title_box.append(watched_label)

        box.append(title_box)

        meta = Gtk.Label(label=_fmt_meta(video), xalign=0.0)
        meta.add_css_class("dim-label")
        box.append(meta)
        self.append(box)

        # Buttons
        btn_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        if video.is_playable:
            play_btn = Gtk.Button(label="Play")
            play_btn.connect("clicked", self._on_play_clicked)
            btn_box.append(play_btn)
            
            # NEW: Quick quality download buttons in a horizontal box
            quick_dl_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=2)
            quick_dl_box.set_homogeneous(True)
            
            # Get enabled presets from settings
            enabled_presets = get_enabled_presets(
                self._get_setting("quick_quality_presets") if self._get_setting else None
            )
            
            for preset_key in enabled_presets:
                preset_btn = Gtk.Button(label=get_preset_label(preset_key))
                preset_btn.set_tooltip_text(get_preset_tooltip(preset_key))
                preset_btn.add_css_class("flat")
                preset_btn.connect("clicked", self._on_quick_download, preset_key)
                quick_dl_box.append(preset_btn)
            
            btn_box.append(quick_dl_box)
            
            # Original download options button (now labeled "More...")
            dl_opts_btn = Gtk.Button(label="âš™ Moreâ€¦")
            dl_opts_btn.set_tooltip_text("Advanced download options")
            dl_opts_btn.connect("clicked", self._on_download_clicked)
            btn_box.append(dl_opts_btn)
            
            # NEW: Watch Later button
            self._in_watch_later = is_in_watch_later(video.id)
            self.wl_btn = Gtk.Button()
            self._update_wl_button_label()
            self.wl_btn.connect("clicked", self._on_watch_later_clicked)
            btn_box.append(self.wl_btn)
            
            # Compact "Moreâ€¦" menu
            more = Gtk.MenuButton(label="Moreâ€¦")
            pop = Gtk.Popover()
            vbx = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6, margin_top=6, margin_bottom=6, margin_start=6, margin_end=6)
            
            # NEW: Toggle watched status
            watched = is_watched(self.video.id)
            b_watch = Gtk.Button(label="Mark as Unwatched" if watched else "Mark as Watched")
            b_watch.connect("clicked", self._on_toggle_watched)
            vbx.append(b_watch)
            
            # NEW: SponsorBlock boundary marker
            
            b_rel = Gtk.Button(label="Related")
            b_rel.connect("clicked", lambda *_: self.on_related(self.video))
            b_cmt = Gtk.Button(label="Comments")
            b_cmt.connect("clicked", lambda *_: self.on_comments(self.video))
            b_ch = Gtk.Button(label="Open channel")
            b_ch.set_tooltip_text("Open the uploader's channel")
            b_ch.connect("clicked", lambda *_: self.on_open_channel(self.video))
            b_web = Gtk.Button(label="Open in Browser")
            b_web.connect("clicked", lambda *_: self._open_in_browser())
            b_cu = Gtk.Button(label="Copy URL")
            b_cu.connect("clicked", lambda *_: self._copy_url())
            b_ct = Gtk.Button(label="Copy Title")
            b_ct.connect("clicked", lambda *_: self._copy_title())
            for b in (b_rel, b_cmt, b_ch, b_web, b_cu, b_ct):
                vbx.append(b)
            pop.set_child(vbx)
            more.set_popover(pop)
            btn_box.append(more)
        else:
            # Non-playable kinds
            if self.video.kind == "playlist":
                open_btn = Gtk.Button(label="Open")
                open_btn.set_tooltip_text("Open this playlist")
                open_btn.connect("clicked", lambda *_: self.on_open(self.video))
                btn_box.append(open_btn)
                # Playlist may be downloaded (folder structure)
                dl_btn = Gtk.Button(label="Downloadâ€¦")
                dl_btn.connect("clicked", lambda *_: self.on_download_opts(self.video))
                btn_box.append(dl_btn)
            elif self.video.kind == "channel":
                open_btn = Gtk.Button(label="Open")
                open_btn.set_tooltip_text("Open this channel")
                open_btn.connect("clicked", lambda *_: self.on_open(self.video))
                btn_box.append(open_btn)
                label = "Unfollow" if self._followed else "Follow"
                follow_btn = Gtk.Button(label=label)
                def _toggle_follow(_btn):
                    try:
                        if self._followed:
                            if self.on_unfollow:
                                self.on_unfollow(self.video)
                            self._followed = False
                            _btn.set_label("Follow")
                            if self.on_toast:
                                self.on_toast("Unfollowed channel")
                        else:
                            if self.on_follow:
                                self.on_follow(self.video)
                            self._followed = True
                            _btn.set_label("Unfollow")
                            if self.on_toast:
                                self.on_toast("Followed channel")
                    except Exception:
                        pass
                follow_btn.connect("clicked", _toggle_follow)
                btn_box.append(follow_btn)
            else:
                # comment or other: no "Open" or "Downloadâ€¦" actions
                pass
            # Compact "Moreâ€¦" for common actions
            more = Gtk.MenuButton(label="Moreâ€¦")
            pop = Gtk.Popover()
            vbx = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6, margin_top=6, margin_bottom=6, margin_start=6, margin_end=6)
            b_web = Gtk.Button(label="Open in Browser")
            b_web.connect("clicked", lambda *_: self._open_in_browser())
            b_cu = Gtk.Button(label="Copy URL")
            b_cu.connect("clicked", lambda *_: self._copy_url())
            b_ct = Gtk.Button(label="Copy Title")
            b_ct.connect("clicked", lambda *_: self._copy_title())
            for b in (b_web, b_cu, b_ct):
                vbx.append(b)
            pop.set_child(vbx)
            more.set_popover(pop)
            btn_box.append(more)
        self.append(btn_box)

        # Load thumbnail
        if self._has_thumb:
            if video.thumb_url:
                self._thumb_future = self.thumb_loader_pool.submit(self._load_thumb)
            else:
                # No URL -> placeholder
                GLib.idle_add(self._set_thumb_placeholder)

    def _on_play_clicked(self, *_a):
        import logging
        log = logging.getLogger("whirltube.ui.widgets.result_row")
        try:
            log.debug("ResultRow Play clicked: %s (%s)", self.video.title, self.video.url)
            if callable(self.on_play):
                self.on_play(self.video)
            else:
                log.error("on_play is not callable: %r", self.on_play)
        except Exception as e:
            log.exception("on_play failed: %s", e)

    def _on_download_clicked(self, *_a):
        import logging
        log = logging.getLogger("whirltube.ui.widgets.result_row")
        log.debug("ResultRow Download clicked: %s", self.video.title)
        if callable(self.on_download_opts):
            self.on_download_opts(self.video)

    def _load_thumb(self) -> None:
        with timed(f"Thumbnail load: {self.video.title[:30]}"):
            # Check cancellation early
            if not hasattr(self, '_thumb_future') or (hasattr(self._thumb_future, 'done') and self._thumb_future.done()):
                return
            
            # Check cache first
            cached_path = get_cached_thumbnail(self.video.thumb_url)
            if cached_path:
                try:
                    data = cached_path.read_bytes()
                    # Check cancellation before updating UI
                    if not hasattr(self, '_thumb_future') or (hasattr(self._thumb_future, 'done') and self._thumb_future.done()):
                        return
                    GLib.idle_add(self._set_thumb, data)
                    return
                except Exception as e:
                    log.debug(f"Failed to read cached thumbnail: {e}")
                    # Fall through to download
            
            # Try download with shared client
            data: bytes | None = None
            try:
                # For httpx 0.28.1+, use proxy parameter directly
                client = _get_http_client(self._http_proxy)
                r = client.get(self.video.thumb_url)
                r.raise_for_status()
                data = r.content
            except Exception:
                data = None
                # Fallback: retry without proxy if we had one
                try:
                    # Create temporary client without proxy
                    temp_client = httpx.Client(timeout=10.0, follow_redirects=True, headers=HEADERS)
                    r2 = temp_client.get(self.video.thumb_url)
                    r2.raise_for_status()
                    data = r2.content
                    temp_client.close()
                except Exception:
                    data = None
            
            if data is None:
                # Check cancellation before updating UI
                if not hasattr(self, '_thumb_future') or (hasattr(self._thumb_future, 'done') and self._thumb_future.done()):
                    return
                GLib.idle_add(self._set_thumb_placeholder)
                return
            
            # Check cancellation before caching
            if not hasattr(self, '_thumb_future') or (hasattr(self._thumb_future, 'done') and self._thumb_future.done()):
                return
            
            # Cache the downloaded thumbnail
            try:
                cache_thumbnail(self.video.thumb_url, data)
            except Exception as e:
                log.debug(f"Failed to cache thumbnail: {e}")
            
            # Check cancellation before updating UI
            if not hasattr(self, '_thumb_future') or (hasattr(self._thumb_future, 'done') and self._thumb_future.done()):
                return
            GLib.idle_add(self._set_thumb, data)

    def _set_thumb(self, data: bytes) -> None:
        # Check content type and convert WebP to JPEG if needed
        try:
            # First try to load directly
            loader = GdkPixbuf.PixbufLoader()
            loader.write(data)
            loader.close()
            pixbuf = loader.get_pixbuf()
            
            if pixbuf is None:
                # If direct load fails, try to detect content type
                if data.startswith(b'RIFF') and b'WEBP' in data[:12]:
                    # This is a WebP image, try to convert it
                    import io
                    try:
                        from PIL import Image
                        img = Image.open(io.BytesIO(data))
                        # Convert WebP to JPEG in memory
                        output = io.BytesIO()
                        img.convert('RGB').save(output, format='JPEG')
                        jpeg_data = output.getvalue()
                        
                        # Now load the JPEG
                        loader2 = GdkPixbuf.PixbufLoader()
                        loader2.write(jpeg_data)
                        loader2.close()
                        pixbuf = loader2.get_pixbuf()
                    except ImportError:
                        # PIL not available, show placeholder
                        self._set_thumb_placeholder()
                        return
                    except Exception:
                        # Conversion failed, show placeholder
                        self._set_thumb_placeholder()
                        return
            
            if pixbuf:
                # Check for tiny placeholder images (e.g. 1x1)
                if pixbuf.get_width() < 10 or pixbuf.get_height() < 10:
                    self._set_thumb_placeholder()
                    return
                texture = Gdk.Texture.new_for_pixbuf(pixbuf)
                self.thumb.set_paintable(texture)
                # Show the picture in the stack
                self.thumb_stack.set_visible_child_name("picture")
                return
        except Exception:
            pass
        # If decoding fails, show placeholder
        self._set_thumb_placeholder()

    def _set_thumb_placeholder(self) -> None:
        # Show the placeholder in the stack
        self.thumb_stack.set_visible_child_name("placeholder")

    def _open_in_browser(self) -> None:
        try:
            if self.video and self.video.url:
                # Validate URL scheme
                if not is_valid_youtube_url(self.video.url):
                    if self.on_toast:
                        self.on_toast("Cannot open: invalid URL")
                    return
                Gio.AppInfo.launch_default_for_uri(self.video.url, None)
        except Exception as e:
            if self.on_toast:
                self.on_toast(f"Failed to open browser: {e}")

    def _copy_url(self) -> None:
        text = self.video.url or ""
        if not text:
            return
        self._do_copy_text(text, "URL copied to clipboard")

    def _copy_title(self) -> None:
        text = self.video.title or ""
        if not text:
            return
        self._do_copy_text(text, "Title copied to clipboard")

    def _do_copy_text(self, text: str, toast_msg: str) -> None:
        """
        Copy text to clipboard with Wayland-safe async handling.
        Keeps a reference to the ContentProvider to avoid GC before paste.
        """
        def copy_on_main():
            try:
                disp = Gdk.Display.get_default()
                if not disp:
                    return False
                clipboard = disp.get_clipboard()
                
                # Create a ContentProvider for text
                # Store it as an instance variable so it doesn't get GC'd (Wayland needs this)
                self._clipboard_provider = Gdk.ContentProvider.new_for_value(text)
                clipboard.set_content(self._clipboard_provider)
                
                if self.on_toast:
                    self.on_toast(toast_msg)
            except Exception:
                # Fallback: try the primary clipboard (X11 middle-click selection)
                try:
                    if disp:
                        primary = disp.get_primary_clipboard()
                        if primary:
                            self._clipboard_provider_primary = Gdk.ContentProvider.new_for_value(text)
                            primary.set_content(self._clipboard_provider_primary)
                except Exception:
                    pass
            return False
        
        GLib.idle_add(copy_on_main)

    def cancel_thumbnail_loading(self) -> None:
        """
        Cancel pending thumbnail loading if still in progress.
        This helps prevent memory leaks when rows are scrolled away.
        """
        if self._thumb_future and not self._thumb_future.done():
            self._thumb_future.cancel()
            self._thumb_future = None

    def _update_wl_button_label(self) -> None:
        """Update Watch Later button label based on current state"""
        if self._in_watch_later:
            self.wl_btn.set_label("âœ“ Saved")
            self.wl_btn.set_tooltip_text("Remove from Watch Later")
        else:
            self.wl_btn.set_label("Watch Later")
            self.wl_btn.set_tooltip_text("Save for later")

    def _on_watch_later_clicked(self, *_a) -> None:
        """Toggle Watch Later status"""
        if self._in_watch_later:
            # Remove from watch later
            if remove_from_watch_later(self.video.id):
                self._in_watch_later = False
                self._update_wl_button_label()
                if self.on_toast:
                    self.on_toast("Removed from Watch Later")
            else:
                if self.on_toast:
                    self.on_toast("Failed to remove from Watch Later")
        else:
            # Add to watch later
            if add_to_watch_later(self.video):
                self._in_watch_later = True
                self._update_wl_button_label()
                if self.on_toast:
                    self.on_toast("Added to Watch Later")
            else:
                if self.on_toast:
                    self.on_toast("Already in Watch Later")

    def _on_quick_download(self, btn: Gtk.Button, preset_key: str) -> None:
        """Handle quick quality download button click"""
        try:
            opts = get_quick_quality_options(preset_key)
            
            if self._on_quick_download:
                self._on_quick_download(self.video, opts)
            else:
                # Fallback to regular download dialog
                self.on_download_opts(self.video)
            
            if self.on_toast:
                quality = get_preset_label(preset_key)
                self.on_toast(f"Downloading {self.video.title} ({quality})")
        except Exception as e:
            log.exception(f"Quick download failed: {e}")
            if self.on_toast:
                self.on_toast(f"Download failed: {e}")

    def _on_toggle_watched(self, btn: Gtk.Button) -> None:
        """Toggle watched status and remove from watch later if watched"""
        if is_watched(self.video.id):
            mark_as_unwatched(self.video.id)
            btn.set_label("Mark as Watched")
            if self.on_toast:
                self.on_toast("Marked as unwatched")
        else:
            mark_as_watched(self.video.id)
            btn.set_label("Mark as Unwatched")
            
            # NEW: Auto-remove from watch later when marked watched
            if is_in_watch_later(self.video.id):
                from ...watch_later import remove_from_watch_later
                remove_from_watch_later(self.video.id)
                if self.on_toast:
                    self.on_toast("Marked as watched and removed from Watch Later")
            else:
                if self.on_toast:
                    self.on_toast("Marked as watched")

        # This would open a dialog to mark segment boundaries
        # and submit them to the SponsorBlock database

def _fmt_meta(v: Video) -> str:
    """Format metadata line with duration, views, date, channel"""
    parts = []
    
    # Channel name
    if v.channel:
        parts.append(v.channel)
    
    # View count (if available)
    if v.view_count_str:
        parts.append(v.view_count_str)
    
    # Upload date (if available)
    if v.upload_date_str:
        parts.append(v.upload_date_str)
    
    # Duration (for videos)
    if v.duration_str and v.kind == "video":
        parts.append(v.duration_str)
    
    # Kind indicator for non-videos
    if v.kind in ("playlist", "channel"):
        parts.append(f"[{v.kind.title()}]")
    
    return " â€¢ ".join(parts) if parts else "Unknown"

--- FILE: ./src/whirltube/ui/widgets/__init__.py ---


--- FILE: ./src/whirltube/ui/controllers/browse.py ---
from __future__ import annotations

import threading
from gi.repository import Gtk, GLib

from ...models import Video
from ...providers.base import Provider
from ...navigation_controller import NavigationController
from ...util import is_valid_youtube_url

import logging
log = logging.getLogger(__name__)

HEADERS = {"User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0"}





def open_url_dialog(main_window, provider: Provider, navigation_controller: NavigationController, 
                   extract_ytid_from_url, show_error, populate_results, _play_video, show_loading_cb) -> None:
    """Show dialog for opening a URL"""
    dlg = Gtk.Dialog(title="Open URL", transient_for=main_window, modal=True)
    entry = Gtk.Entry()
    entry.set_placeholder_text("Paste a YouTube URL (video/channel/playlist)â€¦")
    box = dlg.get_content_area()
    box.append(entry)
    dlg.add_button("Open", Gtk.ResponseType.OK)
    dlg.add_button("Cancel", Gtk.ResponseType.CANCEL)
    dlg.set_default_response(Gtk.ResponseType.OK)
    dlg.present()

    def on_response(d: Gtk.Dialog, resp):
        try:
            if resp == Gtk.ResponseType.OK:
                url = entry.get_text().strip()
                if url:
                    # Allow Invidious host when "use_invidious" is enabled
                    extra = []
                    if bool(main_window.settings.get("use_invidious")):
                        host = (main_window.settings.get("invidious_instance") or "").strip()
                        if host:
                            from urllib.parse import urlparse
                            host_parsed = urlparse(host).hostname
                            if host_parsed:
                                extra.append(host_parsed)
                                # common subdomain case
                                if not host_parsed.startswith("www."):
                                    extra.append("www." + host_parsed)
                    if not is_valid_youtube_url(url, extra):
                        show_error("This doesn't look like a YouTube/Invidious URL.")
                    else:
                        # If this looks like a direct video URL, play immediately
                        vid = extract_ytid_from_url(url)
                        if vid:
                            v = Video(id=vid, title=url, url=url, channel=None, duration=None, thumb_url=None, kind="video")
                            _play_video(v)
                        else:
                            # Otherwise open as a listing (playlist/channel/etc.)
                            browse_url(url, provider, navigation_controller, show_error, populate_results, show_loading_cb)
        finally:
            d.destroy()

    dlg.connect("response", on_response)


def browse_url(url: str, provider: Provider, navigation_controller: NavigationController, 
              show_error, populate_results, show_loading_cb) -> None:
    """Browse a URL (playlist, channel, etc.)"""


    def worker():
        show_loading_cb("Opening URL...")
        vids = provider.browse_url(url)
        GLib.idle_add(populate_results, vids)

    threading.Thread(target=worker, daemon=True).start()


def open_playlist(url: str, provider: Provider, navigation_controller: NavigationController, 
                 show_error, populate_results, show_loading_cb) -> None:
    """Open a playlist URL"""


    def worker():
        show_loading_cb("Opening playlist...")
        vids = provider.playlist(url)
        GLib.idle_add(populate_results, vids)

    threading.Thread(target=worker, daemon=True).start()


def open_channel(url: str, provider: Provider, navigation_controller: NavigationController, 
                show_error, populate_results, show_loading_cb) -> None:
    """Open a channel URL"""


    def worker():
        show_loading_cb("Opening channel...")
        try:
            vids = provider.channel_tab(url, "videos")
            GLib.idle_add(populate_results, vids)
        except Exception as e:
            log.error("Failed to open channel %s: %s", url, e)
            GLib.idle_add(show_error, "Could not open channel or fetch videos.")

    threading.Thread(target=worker, daemon=True).start()


def on_related(video: Video, provider: Provider, navigation_controller: NavigationController, 
              show_error, populate_results, show_loading_cb) -> None:
    """Show related videos to a given video"""


    def worker():
        show_loading_cb("Fetching related videos...")
        try:
            vids = provider.related(video.url)
            GLib.idle_add(populate_results, vids)
            if not vids:
                GLib.idle_add(show_error, "No related videos found.")
        except Exception as e:
            log.error("Failed to get related videos for %s: %s", video.url, e)
            GLib.idle_add(show_error, "Failed to fetch related videos.")

    threading.Thread(target=worker, daemon=True).start()


def on_comments(video: Video, provider: Provider, navigation_controller: NavigationController, 
               show_error, populate_results, show_loading_cb) -> None:
    """Show comments for a given video"""
    show_loading_cb(f"Comments for: {video.title}")

    # Use Event for proper thread coordination
    completed = threading.Event()
    
    def watchdog():
        # Wait for 20 seconds or until completed
        if not completed.wait(timeout=20.0):
            # Timeout occurred, worker hasn't completed
            GLib.idle_add(show_error, "Comments timed out (YouTube may be rate-limiting)")
    
    def worker():
        try:
            vids = provider.comments(video.url, max_comments=100)
        except Exception as e:
            if not completed.is_set():
                completed.set()
                GLib.idle_add(show_error, f"Comments failed: {e}")
            return
        
        if not completed.is_set():
            completed.set()
            GLib.idle_add(populate_results, vids)
    
    threading.Thread(target=watchdog, daemon=True).start()
    threading.Thread(target=worker, daemon=True).start()


def open_channel_from_video(video: Video, provider: Provider, navigation_controller: NavigationController, 
                           show_error, populate_results, open_channel_func, show_loading_cb) -> None:
    """Resolve channel URL from a video, then open channel view"""

    
    def worker():
        show_loading_cb("Resolving channel...")
        try:
            url = provider.channel_url_of(video.url)
        except Exception:
            url = None
        if not url:
            GLib.idle_add(show_error, "Unable to resolve channel for this video.")
            return
        # Reuse existing channel opener
        def go():
            open_channel_func(url)
            return False
        GLib.idle_add(go)
    
    threading.Thread(target=worker, daemon=True).start()


def open_item(video: Video, provider: Provider, navigation_controller: NavigationController, 
             show_error, populate_results, _play_video, open_playlist_func, open_channel_func, show_loading_cb) -> None:
    """Generic open item function that handles different video kinds"""
    # For playlists/channels/comments: open URL to list inner entries or view.
    if video.kind == "playlist":
        open_playlist_func(video.url)
    elif video.kind == "channel":
        open_channel_func(video.url)
    elif video.kind == "comment":
        browse_url(video.url, provider, navigation_controller, show_error, populate_results, show_loading_cb)
    else:
        _play_video(video)

--- FILE: ./src/whirltube/ui/controllers/search.py ---
from __future__ import annotations

import logging
import threading
from typing import TYPE_CHECKING

from gi.repository import Gtk, GLib

from ...history import add_search_term
from ...search_filters import normalize_search_filters
from ...util import save_settings

if TYPE_CHECKING:
    from ...providers.base import Provider

log = logging.getLogger(__name__)


def on_search_activate(
    entry: Gtk.SearchEntry,
    run_search_func: callable,
) -> None:
    """Handle search entry activation (Enter key)"""
    query = entry.get_text().strip()
    if not query:
        return
    add_search_term(query)
    run_search_func(query)


def run_search(
    query: str,
    provider: Provider,
    settings: dict,
    search_generation: int,
    show_loading_func: callable,
    show_error_func: callable,
    populate_results_func: callable,
    set_search_generation_func: callable,
    limit: int,
    last_filters: dict[str, str] | None,
    timed_func: callable,
    search_lock: threading.Lock | None = None,  # NEW PARAMETER
) -> None:
    """Execute the search query in a worker thread."""
    log.info("Searching: %s", query)
    show_loading_func(f"Searching: {query}", cancellable=True)

    with (search_lock if search_lock else threading.Lock()):
        gen = set_search_generation_func(search_generation + 1)
        current_gen = gen

    def worker() -> None:
        with timed_func(f"Search: {query}"):
            try:
                if last_filters:
                    order = last_filters.get('order')
                    duration = last_filters.get('duration')
                    period = last_filters.get('period')
                else:
                    # Normalize filters from settings to provider-friendly form
                    order, duration, period = normalize_search_filters(settings)
                
                results = provider.search(query, limit=limit, order=order, duration=duration, period=period)
            except Exception as e:
                log.exception("Search failed")
                GLib.idle_add(show_error_func, f"Search failed: {e}")
                return
        
        # Check if still the current search with lock
        if search_lock:
            with search_lock:
                if current_gen != settings.get("_search_generation", 0):
                    log.debug(f"Search '{query}' cancelled (generation mismatch: {current_gen} != {settings.get('_search_generation')})")
                    return
        else:
            if current_gen != settings.get("_search_generation", 0):
                log.debug(f"Search '{query}' cancelled (generation mismatch: {current_gen} != {settings.get('_search_generation')})")
                return
        
        GLib.idle_add(populate_results_func, results)

    threading.Thread(target=worker, daemon=True).start()


def filters_load_from_settings(
    settings: dict,
    dd_dur: Gtk.DropDown,
    dd_period: Gtk.DropDown,
    dd_order: Gtk.DropDown,
) -> None:
    """Load filter settings from config into the UI dropdowns."""
    dur = (settings.get("search_duration") or "any").lower()
    per = (settings.get("search_period") or "any").lower()
    ordv = (settings.get("search_order") or "relevance").lower()
    # Map to indices
    dur_idx = {"any":0, "short":1, "medium":2, "long":3}.get(dur, 0)
    per_idx = {"any":0, "today":1, "week":2, "month":3}.get(per, 0)
    ord_idx = {"relevance":0, "date":1, "views":2}.get(ordv, 0)
    try:
        dd_dur.set_selected(dur_idx)
        dd_period.set_selected(per_idx)
        dd_order.set_selected(ord_idx)
    except Exception as e:
        log.warning("Failed to load search filters from settings: %s", e)


def filters_apply(
    settings: dict,
    dd_dur: Gtk.DropDown,
    dd_period: Gtk.DropDown,
    dd_order: Gtk.DropDown,
    filters_pop: Gtk.Popover,
    search_entry: Gtk.SearchEntry,
    run_search_func: callable,
    set_last_filters_func: callable,
) -> None:
    """Apply filter selections, save to settings, and re-run search if active."""
    # Save UI selections into settings and persist
    dur_map = {0:"any", 1:"short", 2:"medium", 3:"long"}
    per_map = {0:"any", 1:"today", 2:"week", 3:"month"}
    ord_map = {0:"relevance", 1:"date", 2:"views"}
    
    duration = dur_map.get(dd_dur.get_selected(), "any")
    period = per_map.get(dd_period.get_selected(), "any")
    order = ord_map.get(dd_order.get_selected(), "relevance")
    
    settings["search_duration"] = duration
    settings["search_period"] = period
    settings["search_order"] = order
    save_settings(settings)
    filters_pop.popdown()
    
    # Persist to window instance for re-running search on view switch
    set_last_filters_func({
        'duration': duration,
        'period': period,
        'order': order,
    })
    
    # If there is a current query, re-run search with new filters
    try:
        q = (search_entry.get_text() or "").strip()
        if q:
            run_search_func(q)
    except Exception as e:
        log.error("Error applying filters and re-running search: %s", e)


def filters_clear(
    settings: dict,
    load_filters_func: callable,
    search_entry: Gtk.SearchEntry,
    run_search_func: callable,
) -> None:
    """Clear all search filters, save to settings, and re-run search if active."""
    settings["search_duration"] = "any"
    settings["search_period"] = "any"
    settings["search_order"] = "relevance"
    save_settings(settings)
    load_filters_func()
    # Optionally re-run current search after clearing
    try:
        q = (search_entry.get_text() or "").strip()
        if q:
            run_search_func(q)
    except Exception as e:
        log.error("Error clearing filters and re-running search: %s", e)

--- FILE: ./src/whirltube/ui/controllers/__init__.py ---


--- FILE: ./src/whirltube/ui/__init__.py ---


--- FILE: ./pyproject.toml ---
[build-system]
requires = ["hatchling>=1.24"]
build-backend = "hatchling.build"

[project]
name = "whirltube"
version = "0.4.5"
description = "WhirlTube: lightweight GTK4 frontend for YouTube using mpv and yt-dlp"
readme = "README.md"
license = { text = "GPL-3.0-or-later" }
authors = [{ name = "WhirlTube contributors" }]
requires-python = ">=3.12"
dependencies = [
  "httpx>=0.27",
  "yt-dlp>=2024.8.6",
  "keyring>=24.0",
  "secretstorage>=3.3; sys_platform=='linux'",
]

[project.optional-dependencies]
dev = [
  "ruff>=0.6.9",
  "mypy>=1.11",
  "pytest>=8.3",
  "pytest-cov>=5.0",
]
embed = [
  "python-mpv>=1.0.6",
]

[project.scripts]
whirltube = "whirltube.app:main"

[tool.hatch.build.targets.wheel]
packages = ["src/whirltube"]
include = [
  "src/whirltube/assets/**",
  "data/**",
]

[tool.hatch.build.targets.sdist]
include = [
  "src/**",
  "README.md",
  "CHANGELOG.md",
  "LICENSE",
  "pyproject.toml",
  "mypy.ini",
  "ruff.toml",
  "tests/**",
  "data/**",
  "flatpak/**",
]

[tool.ruff]
line-length = 100
target-version = "py312"
lint.select = ["E","F","W","I","UP","B","SIM","C90"]
lint.ignore = ["E203","E501"]
src = ["src"]

[tool.pytest.ini_options]
testpaths = ["tests"]
addopts = "-q"


--- FILE: ./README.md ---
# WhirlTube

Wayland-first, GTK 4 + Libadwaita frontend for YouTube that:
- Plays videos with MPV (external window by default; optional in-window embed on X11).
- Searches and downloads with yt-dlp (no API keys).
- Minimal dependencies; robust, async UI.

Status: v0.4.5

## Highlights
- Search YouTube via yt-dlp (no API), browse Open URL (video/playlist/channel), view Related and Comments.
- External MPV playback with quality presets (Auto/2160/1440/1080/720/480) and extra args; optional X11 embedding via python-mpv.
- Unified downloads with robust JSON progress (main Download dialog + Quick Download).
- Quick Download: batch URLs, Video/Audio tabs, SponsorBlock, cookies, custom yt-dlp path; per-tab output directories.
- History: persistent search and watch history.
- Smooth UX: loading spinners, cached settings, thumbnail placeholders on failures.

## Requirements
System packages:
- GTK4, Libadwaita, PyGObject (gi)
- MPV
- FFmpeg
- Python 3.12+ (3.13 OK)

Arch:
  sudo pacman -S --needed gtk4 libadwaita python-gobject mpv ffmpeg

Optional (for tiny build):
  sudo pacman -S --needed python-httpx python-yt-dlp

If your venv cannot see system PyGObject:
  pip install PyGObject pycairo

## Install (from source)
- Dev deps:
  pip install -e .[dev]

- Run:
  whirltube
  # or
  python -m whirltube

- Logs:
  WHIRLTUBE_DEBUG=1 whirltube

## Build (zipapp)
Vendored deps:
  bash scripts/build_and_verify.sh

Tiny system deps:
  bash scripts/build_zipapp_systemdeps.sh && bash scripts/deep_verify.sh

Run:
  ./dist/whirltube

## Features
- Search via yt-dlp (ytsearchN); thumbnails via httpx (thread pool, fallback placeholders).
- Browse: Open URL (video/playlist/channel), Related videos, Comments.
- Watch and search history with persistent storage.
- External MPV playback (default) with custom MPV args in Preferences.
- Optional in-window playback via python-mpv (X11 only); falls back on Wayland.
- Preferred playback quality: Auto/2160/1440/1080/720/480 (sets MPV --ytdl-format height cap).
- Downloads via yt-dlp:
  - Per-item Download dialog (presets/custom format; subtitles, SponsorBlock, cookies, advanced flags).
  - Quick Download (batch URLs; Video/Audio tabs, SponsorBlock, cookies, custom yt-dlp path).

## Navigation
- Back: Escape, Backspace, Alt+Left, Ctrl+Backspace.
- Open URL: Works for single videos, playlists, and channels (/videos tab).

## Packaging
AUR:
- whirltube-git: tracks main branch tip
- whirltube: stable releases (tags)
See packaging/arch/ for PKGBUILD examples.

Flatpak: planned for v1.0.0.

## Screenshots
(TBD)

## Icons
- App icon is at src/whirltube/assets/icons/hicolor/scalable/apps/whirltube.svg
- Runtime registers icon so About/Window icons work from source and wheel.

## License
GPL-3.0-or-later. See LICENSE.


--- FILE: ./CHANGELOG.md ---
# Changelog

All notable changes to this project will be documented in this file.

## 0.4.5
- Downloads:
  - Cleaner UI: actions moved into an "Actions" popover menu (Cancel, Retry, Remove, Open/Show in folder).
  - Configurable filename template (Preferences â†’ Downloads).
  - Queue, Cancel All, Clear Finished, Retry/Remove rows (from previous batches).
  - In-app toasts and desktop notifications on finish/error (from previous batches).
- Player:
  - "Auto-hide MPV controls outside Player view" setting (Preferences â†’ Playback).
  - MPV hotkeys (J/K/L, +/- , X) and Copy URL @ time (T) (from previous batches).
- Provider:
  - Invidious toggle and instance (Preferences â†’ Provider) (from previous batches).
- Packaging:
  - Desktop file, AppStream metainfo, Flatpak scaffold (from previous batches).
- Internal:
  - Safer proxy handling and test coverage.
  - Lazy GI imports for testability.

## 0.4.4
- Downloads:
  - Retry/Remove per row, Cancel All and Clear Finished menu items.
- Provider:
  - Wire Subscriptions menu actions.

## 0.4.3
- Downloads:
  - Queue with configurable max concurrency.
  - "Open in Browser", "Copy URL", "Copy Title".
- Misc: URL validation and alignment fixes.

## 0.4.2
- Initial public release series baseline.

--- FILE: ./CONTRIBUTING.md ---
# Contributing to WhirlTube

Thanks for your interest! This project aims to be a lean, native YouTube client for GNOME/Wayland using MPV + yt-dlp. Small, focused PRs are very welcome.

## Dev Setup
- Arch deps:
  sudo pacman -S --needed gtk4 libadwaita python-gobject mpv ffmpeg
- Python:
  python -m venv .venv && source .venv/bin/activate
  pip install -e .[dev]
- Build:
  bash scripts/build_and_verify.sh
- Run:
  WHIRLTUBE_DEBUG=1 ./dist/whirltube

## Coding Style
- Ruff (PEP8 + curated rules), mypy (py312), small functions, minimal diffs.
- One feature/bug per PR (~300 lines max ideal).
- Conventional commits (feat:, fix:, docs:, chore:, refactor:, test:, build:).

## Tests
- Run: pytest -q
- Please add tests for parsers (ytdlp_runner), options mapping (dialogs), and provider helpers.

## PR Checklist
- [ ] ruff, mypy, pytest pass
- [ ] scripts/build_and_verify.sh passes locally
- [ ] No stray *.bak files
- [ ] Clear description; link issues if any

## Reporting Issues
- Use the bug report template; include OS/distro, logs (WHIRLTUBE_DEBUG=1), and steps to reproduce.

Thanks!

--- FILE: ./ruff.toml ---
# Ruff config is in pyproject.toml; this file exists for sdist completeness.


--- FILE: ./mypy.ini ---
[mypy]
python_version = 3.12
warn_unused_ignores = True
exclude = (?x)(
    ^tests/  # ignore tests
)

[mypy-gi.*]
ignore_missing_imports = True

[mypy-GdkPixbuf.*]
ignore_missing_imports = True

[mypy-mpv.*]
ignore_missing_imports = True


--- FILE: ./.pre-commit-config.yaml ---
repos:
  - repo: https://github.com/charliermarsh/ruff-pre-commit
    rev: v0.6.9
    hooks:
      - id: ruff
        args: [--fix]
  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.11.2
    hooks:
      - id: mypy
        additional_dependencies: []

--- FILE: ./.github/workflows/ci.yml ---
name: CI

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

jobs:
  build:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ["3.12"]
    steps:
      - uses: actions/checkout @v4
      - name: Set up Python
        uses: actions/setup-python @v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'
      - name: Install project (with dev extras)
        run: |
          python -m pip install --upgrade pip
          pip install -e ".[dev]"
      - name: Ruff
        run: |
          ruff --version
          ruff check .
      - name: Mypy
        run: |
          mypy --version
          mypy
      - name: Pytest
        run: |
          pytest -q

--- FILE: ./flatpak/org.whirltube.WhirlTube.yml ---
app-id: org.whirltube.WhirlTube
runtime: org.gnome.Platform
runtime-version: '46'
sdk: org.gnome.Sdk
command: whirltube
finish-args:
  - --share=network
  - --socket=x11
  - --socket=wayland
  - --filesystem=home
  - --talk-name=org.freedesktop.secrets
modules:
  - name: python3-deps
    buildsystem: simple
    build-commands:
      - pip3 install --no-cache --prefix=/app httpx yt-dlp
  - name: whirltube
    buildsystem: simple
    build-commands:
      - pip3 install --no-cache --prefix=/app .
    sources:
      - type: dir
        path: ..

--- FILE: ./data/org.whirltube.WhirlTube.desktop ---
[Desktop Entry]
Type=Application
Name=WhirlTube
GenericName=YouTube client
Comment=Lightweight GTK4 frontend for YouTube using mpv and yt-dlp
Exec=whirltube
Icon=whirltube
Terminal=false
Categories=AudioVideo;Video;GTK;
StartupNotify=true
StartupWMClass=org.whirltube.WhirlTube
Keywords=YouTube;Video;MPV;yt-dlp;
DBusActivatable=false

--- FILE: ./data/org.whirltube.WhirlTube.metainfo.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<component type="desktop-application">
  <id>org.whirltube.WhirlTube</id>
  <name>WhirlTube</name>
  <summary>Lightweight GTK4 frontend for YouTube using mpv and yt-dlp</summary>
  <metadata_license>CC0-1.0</metadata_license>
  <project_license>GPL-3.0-or-later</project_license>
  <description>
    <p>WhirlTube is a lightweight GTK4 frontend for YouTube that uses mpv for playback and yt-dlp for searching and downloading.</p>
  </description>
  <launchable type="desktop-id">org.whirltube.WhirlTube.desktop</launchable>
  <categories>
    <category>AudioVideo</category>
    <category>Video</category>
    <category>Network</category>
  </categories>
  <provides>
    <binary>whirltube</binary>
  </provides>
  <url type="homepage">https://github.com/whirltube/whirltube</url>
  <url type="bugtracker">https://github.com/whirltube/whirltube/issues</url>
  <developer_name>WhirlTube contributors</developer_name>
  <releases>
    <release version="0.4.5">
      <description>
        <p>See CHANGELOG in repository.</p>
      </description>
    </release>
  </releases>
</component>

--- FILE: ./whirltube/PKGBUILD ---
pkgname=whirltube
pkgver=0.4.5
pkgrel=1
pkgdesc="Lightweight GTK4 frontend for YouTube using mpv and yt-dlp"
arch=('any')
url="https://github.com/tazdev-ops/WhirlTube"
license=('GPL3')
depends=('python' 'gtk4' 'libadwaita' 'python-gobject' 'yt-dlp' 'python-httpx' 'mpv')
optdepends=(
  'python-mpv: in-window (embedded) playback on X11'
  'libnotify: desktop notifications'
  'python-pillow: thumbnail WebP fallback decoding'
)
makedepends=('python-build' 'python-installer' 'python-hatchling')
provides=('whirltube')
conflicts=('whirltube-git')
source=("https://github.com/tazdev-ops/WhirlTube/archive/refs/tags/v${pkgver}.tar.gz")
sha256sums=('b68b2a015f050b64f7179859b74a8f0d1661f7a078661f96bcd5e873a87a0b5f')

build() {
  cd "WhirlTube-${pkgver}"
  python -m build --wheel --no-isolation
}

package() {
  cd "WhirlTube-${pkgver}"
  python -m installer --destdir="$pkgdir" dist/*.whl

  # Desktop entry (use upstream if present; otherwise create one)
  if [[ -f data/org.whirltube.WhirlTube.desktop ]]; then
    install -Dm644 data/org.whirltube.WhirlTube.desktop \
      "$pkgdir/usr/share/applications/org.whirltube.WhirlTube.desktop"
  else
    install -Dm644 /dev/stdin "$pkgdir/usr/share/applications/org.whirltube.WhirlTube.desktop" <<'EOF'
[Desktop Entry]
Name=WhirlTube
Comment=Lightweight GTK4 frontend for YouTube using mpv and yt-dlp
Exec=whirltube
Icon=whirltube
Terminal=false
Type=Application
Categories=AudioVideo;Network;GTK;
StartupWMClass=org.whirltube.WhirlTube
EOF
  fi

  # Icons (install to system icon theme if available in source)
  for sz in 16 24 32 48 64 128 256 512; do
    for f in "src/whirltube/assets/icons/hicolor/${sz}x${sz}/apps/whirltube.png" \
             "src/whirltube/assets/icons/hicolor/${sz}x${sz}/apps/whirltube.svg"; do
      if [[ -f "$f" ]]; then
        install -Dm644 "$f" "$pkgdir/usr/share/icons/hicolor/${sz}x${sz}/apps/whirltube.${f##*.}"
      fi
    done
  done
  if [[ -f src/whirltube/assets/icons/hicolor/scalable/apps/whirltube.svg ]]; then
    install -Dm644 src/whirltube/assets/icons/hicolor/scalable/apps/whirltube.svg \
      "$pkgdir/usr/share/icons/hicolor/scalable/apps/whirltube.svg"
  fi
}

--- FILE: ./tests/conftest.py ---
from __future__ import annotations

import pytest
from unittest.mock import Mock
from pathlib import Path
from typing import Any

from src.whirltube.models import Video
from src.whirltube.providers.base import Provider

@pytest.fixture
def mock_settings() -> dict[str, Any]:
    """Mock settings dictionary."""
    return {
        "http_proxy": None,
        "use_invidious": False,
        "invidious_instance": "https://yewtu.be",
        "search_duration": "any",
        "search_period": "any",
        "search_order": "relevance",
    }

@pytest.fixture
def mock_provider() -> Mock:
    """Mock Provider instance."""
    mock = Mock(spec=Provider)
    mock.search.return_value = []
    mock.trending.return_value = []
    mock.fetch_formats.return_value = []
    return mock

@pytest.fixture
def sample_videos() -> list[Video]:
    """A list of sample Video objects."""
    return [
        Video(
            id="short_id",
            title="A Short Video",
            url="https://youtu.be/short_id",
            channel="Short Channel",
            duration=120, # 2 minutes
            thumb_url="http://example.com/short.jpg",
            kind="video",
        ),
        Video(
            id="long_id",
            title="A Very Long Video",
            url="https://www.youtube.com/watch?v=long_id",
            channel="Long Channel",
            duration=3600, # 1 hour
            thumb_url="http://example.com/long.jpg",
            kind="video",
        ),
        Video(
            id="playlist_id",
            title="My Playlist",
            url="https://www.youtube.com/playlist?list=playlist_id",
            channel=None,
            duration=None,
            thumb_url=None,
            kind="playlist",
        ),
    ]

@pytest.fixture
def mock_xdg_dirs(tmp_path: Path) -> None:
    """Mock XDG environment variables to use a temporary directory."""
    # This is a bit tricky without patching the functions directly, 
    # but for simple tests, we can rely on the functions being called 
    # with no arguments, which defaults to home dir logic.
    # Since we can't easily mock os.environ here, we'll rely on tests 
    # that use xdg_data_dir/xdg_config_dir to be mocked if needed.
    pass

--- FILE: ./tests/test_dialogs.py ---
from __future__ import annotations

from src.whirltube.dialogs import DownloadOptions
from pathlib import Path

def test_download_options_default_to_ydl_opts():
    opts = DownloadOptions()
    ydl_opts = opts.to_ydl_opts()
    assert ydl_opts["format"] == "bv*+ba/b"
    assert ydl_opts["quiet"] is True
    assert "writesubtitles" not in ydl_opts

def test_download_options_custom_format_to_ydl_opts():
    opts = DownloadOptions(quality_mode="custom", custom_format="bestvideo[height<=1080]+bestaudio")
    ydl_opts = opts.to_ydl_opts()
    assert ydl_opts["format"] == "bestvideo[height<=1080]+bestaudio"

def test_download_options_subtitles_to_ydl_opts():
    opts = DownloadOptions(
        write_subs=True,
        subs_langs="en,fr",
        write_auto_subs=True,
        subs_format="srt"
    )
    ydl_opts = opts.to_ydl_opts()
    assert ydl_opts["writesubtitles"] is True
    assert ydl_opts["subtitleslangs"] == ["en", "fr"]
    assert ydl_opts["writeautomaticsub"] is True
    assert ydl_opts["subtitlesformat"] == "srt"

def test_download_options_default_raw_cli_list():
    opts = DownloadOptions()
    cli_list = opts.raw_cli_list()
    assert "-f" in cli_list
    assert "bv*+ba/b" in cli_list
    assert "--write-subs" not in cli_list
    assert "--sponsorblock-mark" not in cli_list

def test_download_options_full_raw_cli_list():
    opts = DownloadOptions(
        quality_mode="lowest",
        sort_string="res:1080",
        write_subs=True,
        subs_langs="en",
        subs_format="best",
        sb_mark="sponsor",
        sb_remove="selfpromo",
        embed_metadata=True,
        embed_thumbnail=True,
        write_thumbnail=True,
        use_cookies=True,
        cookies_browser="firefox",
        cookies_profile="default",
        cookies_container="personal",
        limit_rate="1M",
        concurrent_fragments=4,
        impersonate="chrome-110",
        extra_flags="--no-mtime -v",
        target_dir=Path("/tmp/downloads")
    )
    cli_list = opts.raw_cli_list()
    
    assert "-f" in cli_list and "worst" in cli_list
    assert "-S" in cli_list and "res:1080" in cli_list
    assert "--write-subs" in cli_list
    assert "--sub-langs" in cli_list and "en" in cli_list
    assert "--sub-format" in cli_list and "best" in cli_list
    assert "--sponsorblock-mark" in cli_list and "sponsor" in cli_list
    assert "--sponsorblock-remove" in cli_list and "selfpromo" in cli_list
    assert "--embed-metadata" in cli_list
    assert "--embed-thumbnail" in cli_list
    assert "--write-thumbnail" in cli_list
    assert "--cookies-from-browser" in cli_list
    assert "firefox:default::personal" in cli_list
    assert "--limit-rate" in cli_list and "1M" in cli_list
    assert "-N" in cli_list and "4" in cli_list
    assert "--impersonate" in cli_list and "chrome-110" in cli_list
    assert "--no-mtime" in cli_list
    assert "-v" in cli_list
    # target_dir is not part of raw_cli_list, it's handled by the caller
    assert Path("/tmp/downloads") not in cli_list

def test_download_options_cookies_keyring():
    opts = DownloadOptions(
        use_cookies=True,
        cookies_browser="chromium",
        cookies_keyring="kwallet",
    )
    cli_list = opts.raw_cli_list()
    assert "chromium+kwallet" in cli_list

def test_download_options_extra_flags_shlex_split():
    opts = DownloadOptions(extra_flags='--postprocessor-args "arg with space"')
    cli_list = opts.raw_cli_list()
    assert cli_list[-2] == "--postprocessor-args"
    assert cli_list[-1] == "arg with space"


--- FILE: ./tests/test_models.py ---
from __future__ import annotations

import pytest
from src.whirltube.models import Video

@pytest.mark.parametrize(
    "duration, expected",
    [
        (0, ""),
        (59, "0:59"),
        (60, "1:00"),
        (3599, "59:59"),
        (3600, "1:00:00"),
        (3661, "1:01:01"),
        (86399, "23:59:59"),
        (None, ""),
    ],
)
def test_video_duration_str(duration, expected):
    video = Video(
        id="test",
        title="test",
        url="test",
        channel=None,
        duration=duration,
        thumb_url=None,
    )
    assert video.duration_str == expected

@pytest.mark.parametrize(
    "kind, expected",
    [
        ("video", True),
        ("playlist", False),
        ("channel", False),
        ("comment", False),
        ("unknown", False),
    ],
)
def test_video_is_playable(kind, expected):
    video = Video(
        id="test",
        title="test",
        url="test",
        channel=None,
        duration=100,
        thumb_url=None,
        kind=kind,
    )
    assert video.is_playable == expected

--- FILE: ./tests/test_parse_line.py ---
from whirltube.ytdlp_runner import parse_line, PREFIX
from typing import Any

# Define a simple Event class for testing purposes, as it's not imported in the test file
class Event:
    def __init__(self, kind: str, payload: Any):
        self.kind = kind
        self.payload = payload

def test_parse_line_progress_event_basic():
    line = f'{PREFIX}{{"type":"downloading","eta":12,"downloaded_bytes":1024,"total_bytes":2048}}'
    evs = parse_line(line)
    assert isinstance(evs, list)
    # The actual parse_line returns a list of DownloadProgress objects, which have 'kind' and 'payload' attributes.
    # Assuming the structure of the returned object is compatible for this test.
    assert evs and evs[0].kind == "downloading"
    payload = evs[0].payload
    assert payload["eta"] == 12
    assert payload["downloaded_bytes"] == 1024
    assert payload["total_bytes"] == 2048


def test_parse_line_non_prefixed_is_none():
    assert parse_line("some random output") is None


def test_parse_line_error_std_and_plain():
    e1 = parse_line("stderr:ERROR: boom")
    assert isinstance(e1, Exception)
    assert "boom" in str(e1)
    e2 = parse_line("ERROR: boom2")
    assert isinstance(e2, Exception)
    assert "boom2" in str(e2)


def test_parse_line_NA_becomes_null():
    line = f'{PREFIX}{{"type":"downloading","eta":NA,"speed":NA}}'
    evs = parse_line(line)
    assert isinstance(evs, list) and evs[0].payload["eta"] is None and evs[0].payload["speed"] is None


--- FILE: ./tests/test_runner_state.py ---
from whirltube.ytdlp_runner import YtDlpRunner


class _StubProc:
    def __init__(self, rc):
        self._rc = rc

    def poll(self):
        return self._rc


def test_runner_is_running_transitions():
    r = YtDlpRunner(lambda _t: None)
    assert not r.is_running()
    # Simulate running process
    r._proc = _StubProc(None)  # type: ignore[attr-defined]
    assert r.is_running()
    # Simulate finished process
    r._proc = _StubProc(0)  # type: ignore[attr-defined]
    assert not r.is_running()

--- FILE: ./tests/test_search_filters.py ---
from whirltube.search_filters import normalize_search_filters


def test_normalize_defaults_to_none():
    s = {}
    order, duration, period = normalize_search_filters(s)
    assert order is None and duration is None and period is None


def test_normalize_any_and_relevance_become_none():
    s = {
        "search_order": "relevance",
        "search_duration": "any",
        "search_period": "any",
    }
    order, duration, period = normalize_search_filters(s)
    assert order is None and duration is None and period is None


def test_normalize_respects_values_case_insensitive():
    s = {
        "search_order": "DATE",
        "search_duration": "Short",
        "search_period": "Week",
    }
    order, duration, period = normalize_search_filters(s)
    assert order == "date" and duration == "short" and period == "week"


def test_normalize_passes_through_known_values():
    s = {
        "search_order": "views",
        "search_duration": "long",
        "search_period": "month",
    }
    assert normalize_search_filters(s) == ("views", "long", "month")

--- FILE: ./tests/test_smoke.py ---
def test_import():
    import whirltube  # noqa: F401


def test_entrypoint():
    from whirltube.app import main

    assert callable(main)


--- FILE: ./tests/test_util.py ---
from __future__ import annotations

import pytest
from unittest.mock import patch
from pathlib import Path
from src.whirltube.util import safe_httpx_proxy, is_valid_youtube_url, xdg_config_dir, xdg_data_dir, xdg_cache_dir

@pytest.mark.parametrize(
    "url, expected",
    [
        ("https://www.youtube.com/watch?v=ID", True),
        ("http://youtu.be/ID", True),
        ("https://www.youtube.com/shorts/ID", True),
        ("https://www.youtube.com/embed/ID", True),
        ("https://invidious.example.com/watch?v=ID", False), # Allowed by default
        ("https://example.com/video", False),
        ("ftp://youtube.com/watch?v=ID", False),
        ("", False),
        (None, False),
    ],
)
def test_is_valid_youtube_url_core(url, expected):
    # Test core YouTube hosts
    assert is_valid_youtube_url(url) == expected

@pytest.mark.parametrize(
    "url, allowed_hosts, expected",
    [
        ("https://myinvidious.net/watch?v=ID", ["myinvidious.net"], True),
        ("https://www.myinvidious.net/watch?v=ID", ["myinvidious.net"], True),
        ("https://sub.myinvidious.net/watch?v=ID", ["myinvidious.net"], True),
        ("https://other.net/watch?v=ID", ["myinvidious.net"], False),
        ("https://www.youtube.com/watch?v=ID", ["myinvidious.net"], True), # Core hosts always allowed
    ],
)
def test_is_valid_youtube_url_allowed_hosts(url, allowed_hosts, expected):
    # Test with explicit allowed hosts (e.g., Invidious instances)
    assert is_valid_youtube_url(url, allowed_hosts) == expected

@pytest.mark.parametrize(
    "proxy_str, expected",
    [
        ("http://127.0.0.1:8080", "http://127.0.0.1:8080"),
        ("socks5://user:pass@host:1080", "socks5://user:pass@host:1080"),
        ("https://proxy.com", "https://proxy.com"),
        ("socks5h://host:1080", "socks5h://host:1080"),
        ("ftp://bad.com", None),
        ("127.0.0.1:8080", None), # Missing scheme
        ("http://", None), # Missing netloc
        ("", None),
        (None, None),
    ],
)
def test_safe_httpx_proxy(proxy_str, expected):
    assert safe_httpx_proxy(proxy_str) == expected

@patch("src.whirltube.util.Path.home", return_value=Path("/home/testuser"))
@patch("src.whirltube.util.os.environ", {"XDG_CONFIG_HOME": "/tmp/config"})
def test_xdg_config_dir_with_env(mock_env, mock_home, tmp_path):
    # Mock Path.mkdir to avoid actual FS changes in tests
    with patch("src.whirltube.util.Path.mkdir") as mock_mkdir:
        result = xdg_config_dir()
        assert result == Path("/tmp/config/whirltube")
        mock_mkdir.assert_called_once_with(parents=True, exist_ok=True)

@patch("src.whirltube.util.Path.home", return_value=Path("/home/testuser"))
@patch("src.whirltube.util.os.environ", {})
def test_xdg_data_dir_default(mock_home, mock_env, tmp_path):
    with patch("src.whirltube.util.Path.mkdir"):
        result = xdg_data_dir()
        assert result == Path("/home/testuser/.local/share/whirltube")

@patch("src.whirltube.util.Path.home", return_value=Path("/home/testuser"))
@patch("src.whirltube.util.os.environ", {"XDG_CACHE_HOME": "/tmp/cache"})
def test_xdg_cache_dir_with_env(mock_env, mock_home, tmp_path):
    with patch("src.whirltube.util.Path.mkdir"):
        result = xdg_cache_dir()
        assert result == Path("/tmp/cache/whirltube")

--- FILE: ./tests/test_utils_proxy.py ---
from whirltube.util import safe_httpx_proxy


def test_safe_httpx_proxy_accepts_valid_http():
    assert safe_httpx_proxy("http://127.0.0.1:8080") == "http://127.0.0.1:8080"
    assert safe_httpx_proxy("https://proxy.local:8443") == "https://proxy.local:8443"


def test_safe_httpx_proxy_accepts_valid_socks():
    assert safe_httpx_proxy("socks5://host:1080") == "socks5://host:1080"
    assert safe_httpx_proxy("socks5h://user:pass @host:1080") == "socks5h://user:pass @host:1080"


def test_safe_httpx_proxy_rejects_invalid():
    assert safe_httpx_proxy("") is None
    assert safe_httpx_proxy(None) is None
    assert safe_httpx_proxy("not a url") is None
    assert safe_httpx_proxy("file:///tmp/foo") is None
    assert safe_httpx_proxy("ftp://proxy:21") is None
    assert safe_httpx_proxy("http:///missing-host") is None

--- FILE: ./tests/test_utils_youtube_url.py ---
from whirltube.util import is_valid_youtube_url


def test_is_valid_youtube_url_basic_youtube():
    assert is_valid_youtube_url("https://www.youtube.com/watch?v=dQw4w9WgXcQ")
    assert is_valid_youtube_url("http://youtube.com/shorts/abc")
    assert is_valid_youtube_url("https://youtu.be/dQw4w9WgXcQ")


def test_is_valid_youtube_url_rejects_non_http():
    assert not is_valid_youtube_url("ftp://youtube.com/video")
    assert not is_valid_youtube_url("file:///tmp/thing")
    assert not is_valid_youtube_url("not a url")
    assert not is_valid_youtube_url("")
    assert not is_valid_youtube_url(None)  # type: ignore[arg-type]


def test_is_valid_youtube_url_allows_invidious_host():
    assert not is_valid_youtube_url("https://yewtu.be/watch?v=foo")
    assert is_valid_youtube_url("https://yewtu.be/watch?v=foo", allowed_hosts=["yewtu.be"])


def test_is_valid_youtube_url_rejects_unknown_host():
    assert not is_valid_youtube_url("https://example.com/watch?v=foo")
    assert not is_valid_youtube_url("https://ex.youtube.evil.example/watch?v=foo")
    assert not is_valid_youtube_url("https://you.tube.com/watch?v=foo")

--- FILE: ./tests/test_ytdlp_runner.py ---
from __future__ import annotations

import json
from src.whirltube.ytdlp_runner import parse_line, PREFIX

def test_parse_line_valid_json():
    json_data = {"type": "downloading", "progress": 0.5}
    line = f"some log line {PREFIX}{json.dumps(json_data)}"
    result = parse_line(line)
    assert isinstance(result, list)
    assert len(result) == 1
    event = result[0]
    assert event.kind == "downloading"
    assert event.payload["progress"] == 0.5

def test_parse_line_multiple_markers():
    # Should only parse the first one
    json_data = {"type": "downloading", "progress": 0.5}
    line = f"log line {PREFIX}{json.dumps(json_data)}"
    result = parse_line(line)
    assert isinstance(result, list)
    assert len(result) == 1
    assert result[0].kind == "downloading"

def test_parse_line_no_marker():
    line = "This is a regular log line."
    assert parse_line(line) is None

def test_parse_line_invalid_json():
    line = f"log {PREFIX} {{invalid json"
    assert parse_line(line) is None

def test_parse_line_error_stderr_prefix():
    line = "stderr:ERROR: This is a specific yt-dlp error."
    result = parse_line(line)
    assert isinstance(result, RuntimeError)
    assert str(result) == "This is a specific yt-dlp error."

def test_parse_line_error_no_prefix():
    line = "ERROR: This is a generic yt-dlp error."
    result = parse_line(line)
    assert isinstance(result, RuntimeError)
    assert str(result) == "This is a generic yt-dlp error."

def test_parse_line_error_stderr_other():
    line = "stderr:Some other error message."
    result = parse_line(line)
    assert isinstance(result, RuntimeError)
    assert str(result) == "yt-dlp error: Some other error message."

def test_parse_line_with_na_values():
    # yt-dlp sometimes outputs 'NA' for null values, which needs to be replaced
    json_data = '{"type":"downloading","eta":NA,"speed":1000}'
    line = f"log {PREFIX}{json_data}"
    result = parse_line(line)
    assert isinstance(result, list)
    assert result[0].payload["eta"] is None
    assert result[0].payload["speed"] == 1000

def test_parse_line_non_dict_json():
    line = f"log {PREFIX} [1, 2, 3]"
    assert parse_line(line) is None

def test_parse_line_missing_type():
    line = f"log {PREFIX} {{\"progress\": 0.5}}"
    assert parse_line(line) is None

